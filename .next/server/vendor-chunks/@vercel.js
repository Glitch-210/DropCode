"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vercel";
exports.ids = ["vendor-chunks/@vercel"];
exports.modules = {

/***/ "(rsc)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* binding */ BlobAccessError),\n/* harmony export */   BlobClientTokenExpiredError: () => (/* binding */ BlobClientTokenExpiredError),\n/* harmony export */   BlobContentTypeNotAllowedError: () => (/* binding */ BlobContentTypeNotAllowedError),\n/* harmony export */   BlobError: () => (/* binding */ BlobError),\n/* harmony export */   BlobFileTooLargeError: () => (/* binding */ BlobFileTooLargeError),\n/* harmony export */   BlobNotFoundError: () => (/* binding */ BlobNotFoundError),\n/* harmony export */   BlobPathnameMismatchError: () => (/* binding */ BlobPathnameMismatchError),\n/* harmony export */   BlobRequestAbortedError: () => (/* binding */ BlobRequestAbortedError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* binding */ BlobServiceNotAvailable),\n/* harmony export */   BlobServiceRateLimited: () => (/* binding */ BlobServiceRateLimited),\n/* harmony export */   BlobStoreNotFoundError: () => (/* binding */ BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* binding */ BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* binding */ BlobUnknownError),\n/* harmony export */   MAXIMUM_PATHNAME_LENGTH: () => (/* binding */ MAXIMUM_PATHNAME_LENGTH),\n/* harmony export */   createCompleteMultipartUploadMethod: () => (/* binding */ createCompleteMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploadMethod: () => (/* binding */ createCreateMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploaderMethod: () => (/* binding */ createCreateMultipartUploaderMethod),\n/* harmony export */   createFolder: () => (/* binding */ createFolder),\n/* harmony export */   createPutMethod: () => (/* binding */ createPutMethod),\n/* harmony export */   createUploadPartMethod: () => (/* binding */ createUploadPartMethod),\n/* harmony export */   disallowedPathnameCharacters: () => (/* binding */ disallowedPathnameCharacters),\n/* harmony export */   getDownloadUrl: () => (/* binding */ getDownloadUrl),\n/* harmony export */   getTokenFromOptionsOrEnv: () => (/* binding */ getTokenFromOptionsOrEnv),\n/* harmony export */   requestApi: () => (/* binding */ requestApi)\n/* harmony export */ });\n/* harmony import */ var is_node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-node-process */ \"(rsc)/./node_modules/is-node-process/lib/index.mjs\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-buffer */ \"(rsc)/./node_modules/is-buffer/index.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var async_retry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! async-retry */ \"(rsc)/./node_modules/async-retry/lib/index.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! undici */ \"(rsc)/./node_modules/@vercel/blob/dist/undici-browser.js\");\n/* harmony import */ var throttleit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! throttleit */ \"(rsc)/./node_modules/throttleit/index.js\");\n// src/helpers.ts\n\n// src/multipart/helpers.ts\n\n\nvar supportsNewBlobFromArrayBuffer = new Promise((resolve)=>{\n    try {\n        const helloAsArrayBuffer = new Uint8Array([\n            104,\n            101,\n            108,\n            108,\n            111\n        ]);\n        const blob = new Blob([\n            helloAsArrayBuffer\n        ]);\n        blob.text().then((text)=>{\n            resolve(text === \"hello\");\n        }).catch(()=>{\n            resolve(false);\n        });\n    } catch  {\n        resolve(false);\n    }\n});\nasync function toReadableStream(value) {\n    if (value instanceof ReadableStream) {\n        return value;\n    }\n    if (value instanceof Blob) {\n        return value.stream();\n    }\n    if (isNodeJsReadableStream(value)) {\n        return stream__WEBPACK_IMPORTED_MODULE_2__.Readable.toWeb(value);\n    }\n    let streamValue;\n    if (value instanceof ArrayBuffer) {\n        streamValue = new Uint8Array(value);\n    } else if (isNodeJsBuffer(value)) {\n        streamValue = value;\n    } else {\n        streamValue = stringToUint8Array(value);\n    }\n    if (await supportsNewBlobFromArrayBuffer) {\n        return new Blob([\n            streamValue\n        ]).stream();\n    }\n    return new ReadableStream({\n        start (controller) {\n            controller.enqueue(streamValue);\n            controller.close();\n        }\n    });\n}\nfunction isNodeJsReadableStream(value) {\n    return typeof value === \"object\" && typeof value.pipe === \"function\" && value.readable && typeof value._read === \"function\" && // @ts-expect-error _readableState does exists on Readable\n    typeof value._readableState === \"object\";\n}\nfunction stringToUint8Array(s) {\n    const enc = new TextEncoder();\n    return enc.encode(s);\n}\nfunction isNodeJsBuffer(value) {\n    return is_buffer__WEBPACK_IMPORTED_MODULE_1__(value);\n}\n// src/bytes.ts\nvar parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i;\nvar map = {\n    b: 1,\n    kb: 1 << 10,\n    mb: 1 << 20,\n    gb: 1 << 30,\n    tb: 1024 ** 4,\n    pb: 1024 ** 5\n};\nfunction bytes(val) {\n    if (typeof val === \"number\" && !Number.isNaN(val)) {\n        return val;\n    }\n    if (typeof val !== \"string\") {\n        return null;\n    }\n    const results = parseRegExp.exec(val);\n    let floatValue;\n    let unit = \"b\";\n    if (!results) {\n        floatValue = parseInt(val, 10);\n    } else {\n        const [, res, , , unitMatch] = results;\n        if (!res) {\n            return null;\n        }\n        floatValue = parseFloat(res);\n        if (unitMatch) {\n            unit = unitMatch.toLowerCase();\n        }\n    }\n    if (Number.isNaN(floatValue)) {\n        return null;\n    }\n    return Math.floor(map[unit] * floatValue);\n}\n// src/helpers.ts\nvar defaultVercelBlobApiUrl = \"https://vercel.com/api/blob\";\nfunction getTokenFromOptionsOrEnv(options) {\n    if (options == null ? void 0 : options.token) {\n        return options.token;\n    }\n    if (process.env.BLOB_READ_WRITE_TOKEN) {\n        return process.env.BLOB_READ_WRITE_TOKEN;\n    }\n    throw new BlobError(\"No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.\");\n}\nvar BlobError = class extends Error {\n    constructor(message){\n        super(`Vercel Blob: ${message}`);\n    }\n};\nfunction getDownloadUrl(blobUrl) {\n    const url = new URL(blobUrl);\n    url.searchParams.set(\"download\", \"1\");\n    return url.toString();\n}\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\nvar disallowedPathnameCharacters = [\n    \"//\"\n];\nvar supportsRequestStreams = (()=>{\n    if ((0,is_node_process__WEBPACK_IMPORTED_MODULE_0__.isNodeProcess)()) {\n        return true;\n    }\n    const apiUrl = getApiUrl();\n    if (apiUrl.startsWith(\"http://localhost\")) {\n        return false;\n    }\n    let duplexAccessed = false;\n    const hasContentType = new Request(getApiUrl(), {\n        body: new ReadableStream(),\n        method: \"POST\",\n        // @ts-expect-error -- TypeScript doesn't yet have duplex but it's in the spec: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1729\n        get duplex () {\n            duplexAccessed = true;\n            return \"half\";\n        }\n    }).headers.has(\"Content-Type\");\n    return duplexAccessed && !hasContentType;\n})();\nfunction getApiUrl(pathname = \"\") {\n    let baseUrl = null;\n    try {\n        baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n    } catch  {}\n    return `${baseUrl || defaultVercelBlobApiUrl}${pathname}`;\n}\nvar TEXT_ENCODER = typeof TextEncoder === \"function\" ? new TextEncoder() : null;\nfunction computeBodyLength(body) {\n    if (!body) {\n        return 0;\n    }\n    if (typeof body === \"string\") {\n        if (TEXT_ENCODER) {\n            return TEXT_ENCODER.encode(body).byteLength;\n        }\n        return new Blob([\n            body\n        ]).size;\n    }\n    if (\"byteLength\" in body && typeof body.byteLength === \"number\") {\n        return body.byteLength;\n    }\n    if (\"size\" in body && typeof body.size === \"number\") {\n        return body.size;\n    }\n    return 0;\n}\nvar createChunkTransformStream = (chunkSize, onProgress)=>{\n    let buffer = new Uint8Array(0);\n    return new TransformStream({\n        transform (chunk, controller) {\n            queueMicrotask(()=>{\n                const newBuffer = new Uint8Array(buffer.length + chunk.byteLength);\n                newBuffer.set(buffer);\n                newBuffer.set(new Uint8Array(chunk), buffer.length);\n                buffer = newBuffer;\n                while(buffer.length >= chunkSize){\n                    const newChunk = buffer.slice(0, chunkSize);\n                    controller.enqueue(newChunk);\n                    onProgress == null ? void 0 : onProgress(newChunk.byteLength);\n                    buffer = buffer.slice(chunkSize);\n                }\n            });\n        },\n        flush (controller) {\n            queueMicrotask(()=>{\n                if (buffer.length > 0) {\n                    controller.enqueue(buffer);\n                    onProgress == null ? void 0 : onProgress(buffer.byteLength);\n                }\n            });\n        }\n    });\n};\nfunction isReadableStream(value) {\n    return globalThis.ReadableStream && // TODO: Can be removed once Node.js 16 is no more required internally\n    value instanceof ReadableStream;\n}\nfunction isStream(value) {\n    if (isReadableStream(value)) {\n        return true;\n    }\n    if (isNodeJsReadableStream(value)) {\n        return true;\n    }\n    return false;\n}\n// src/api.ts\n\n// src/debug.ts\nvar debugIsActive = false;\nvar _a, _b;\ntry {\n    if (((_a = process.env.DEBUG) == null ? void 0 : _a.includes(\"blob\")) || ((_b = process.env.NEXT_PUBLIC_DEBUG) == null ? void 0 : _b.includes(\"blob\"))) {\n        debugIsActive = true;\n    }\n} catch  {}\nfunction debug(message, ...args) {\n    if (debugIsActive) {\n        console.debug(`vercel-blob: ${message}`, ...args);\n    }\n}\n// src/dom-exception.ts\nvar _a2;\nvar DOMException2 = (_a2 = globalThis.DOMException) != null ? _a2 : (()=>{\n    try {\n        atob(\"~\");\n    } catch (err) {\n        return Object.getPrototypeOf(err).constructor;\n    }\n})();\n// src/is-network-error.ts\nvar objectToString = Object.prototype.toString;\nvar isError = (value)=>objectToString.call(value) === \"[object Error]\";\nvar errorMessages = /* @__PURE__ */ new Set([\n    \"network error\",\n    // Chrome\n    \"Failed to fetch\",\n    // Chrome\n    \"NetworkError when attempting to fetch resource.\",\n    // Firefox\n    \"The Internet connection appears to be offline.\",\n    // Safari 16\n    \"Load failed\",\n    // Safari 17+\n    \"Network request failed\",\n    // `cross-fetch`\n    \"fetch failed\",\n    // Undici (Node.js)\n    \"terminated\"\n]);\nfunction isNetworkError(error) {\n    const isValid = error && isError(error) && error.name === \"TypeError\" && typeof error.message === \"string\";\n    if (!isValid) {\n        return false;\n    }\n    if (error.message === \"Load failed\") {\n        return error.stack === void 0;\n    }\n    return errorMessages.has(error.message);\n}\n// src/fetch.ts\n\nvar hasFetch = typeof undici__WEBPACK_IMPORTED_MODULE_4__.fetch === \"function\";\nvar hasFetchWithUploadProgress = hasFetch && supportsRequestStreams;\nvar CHUNK_SIZE = 64 * 1024;\nvar blobFetch = async ({ input, init, onUploadProgress })=>{\n    debug(\"using fetch\");\n    let body;\n    if (init.body) {\n        if (onUploadProgress) {\n            const stream = await toReadableStream(init.body);\n            let loaded = 0;\n            const chunkTransformStream = createChunkTransformStream(CHUNK_SIZE, (newLoaded)=>{\n                loaded += newLoaded;\n                onUploadProgress(loaded);\n            });\n            body = stream.pipeThrough(chunkTransformStream);\n        } else {\n            body = init.body;\n        }\n    }\n    const duplex = supportsRequestStreams && body && isStream(body) ? \"half\" : void 0;\n    return (0,undici__WEBPACK_IMPORTED_MODULE_4__.fetch)(input, // @ts-expect-error -- Blob and Nodejs Blob are triggering type errors, fine with it\n    {\n        ...init,\n        ...init.body ? {\n            body\n        } : {},\n        duplex\n    });\n};\n// src/xhr.ts\nvar hasXhr = typeof XMLHttpRequest !== \"undefined\";\nvar blobXhr = async ({ input, init, onUploadProgress })=>{\n    debug(\"using xhr\");\n    let body = null;\n    if (init.body) {\n        if (isReadableStream(init.body)) {\n            body = await new Response(init.body).blob();\n        } else {\n            body = init.body;\n        }\n    }\n    return new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(init.method || \"GET\", input.toString(), true);\n        if (onUploadProgress) {\n            xhr.upload.addEventListener(\"progress\", (event)=>{\n                if (event.lengthComputable) {\n                    onUploadProgress(event.loaded);\n                }\n            });\n        }\n        xhr.onload = ()=>{\n            var _a3;\n            if ((_a3 = init.signal) == null ? void 0 : _a3.aborted) {\n                reject(new DOMException(\"The user aborted the request.\", \"AbortError\"));\n                return;\n            }\n            const headers = new Headers();\n            const rawHeaders = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n            rawHeaders.forEach((line)=>{\n                const parts = line.split(\": \");\n                const key = parts.shift();\n                const value = parts.join(\": \");\n                if (key) headers.set(key.toLowerCase(), value);\n            });\n            const response = new Response(xhr.response, {\n                status: xhr.status,\n                statusText: xhr.statusText,\n                headers\n            });\n            resolve(response);\n        };\n        xhr.onerror = ()=>{\n            reject(new TypeError(\"Network request failed\"));\n        };\n        xhr.ontimeout = ()=>{\n            reject(new TypeError(\"Network request timed out\"));\n        };\n        xhr.onabort = ()=>{\n            reject(new DOMException(\"The user aborted a request.\", \"AbortError\"));\n        };\n        if (init.headers) {\n            const headers = new Headers(init.headers);\n            headers.forEach((value, key)=>{\n                xhr.setRequestHeader(key, value);\n            });\n        }\n        if (init.signal) {\n            init.signal.addEventListener(\"abort\", ()=>{\n                xhr.abort();\n            });\n            if (init.signal.aborted) {\n                xhr.abort();\n                return;\n            }\n        }\n        xhr.send(body);\n    });\n};\n// src/request.ts\nvar blobRequest = async ({ input, init, onUploadProgress })=>{\n    if (onUploadProgress) {\n        if (hasFetchWithUploadProgress) {\n            return blobFetch({\n                input,\n                init,\n                onUploadProgress\n            });\n        }\n        if (hasXhr) {\n            return blobXhr({\n                input,\n                init,\n                onUploadProgress\n            });\n        }\n    }\n    if (hasFetch) {\n        return blobFetch({\n            input,\n            init\n        });\n    }\n    if (hasXhr) {\n        return blobXhr({\n            input,\n            init\n        });\n    }\n    throw new Error(\"No request implementation available\");\n};\n// src/api.ts\nvar MAXIMUM_PATHNAME_LENGTH = 950;\nvar BlobAccessError = class extends BlobError {\n    constructor(){\n        super(\"Access denied, please provide a valid token for this resource.\");\n    }\n};\nvar BlobContentTypeNotAllowedError = class extends BlobError {\n    constructor(message){\n        super(`Content type mismatch, ${message}.`);\n    }\n};\nvar BlobPathnameMismatchError = class extends BlobError {\n    constructor(message){\n        super(`Pathname mismatch, ${message}. Check the pathname used in upload() or put() matches the one from the client token.`);\n    }\n};\nvar BlobClientTokenExpiredError = class extends BlobError {\n    constructor(){\n        super(\"Client token has expired.\");\n    }\n};\nvar BlobFileTooLargeError = class extends BlobError {\n    constructor(message){\n        super(`File is too large, ${message}.`);\n    }\n};\nvar BlobStoreNotFoundError = class extends BlobError {\n    constructor(){\n        super(\"This store does not exist.\");\n    }\n};\nvar BlobStoreSuspendedError = class extends BlobError {\n    constructor(){\n        super(\"This store has been suspended.\");\n    }\n};\nvar BlobUnknownError = class extends BlobError {\n    constructor(){\n        super(\"Unknown error, please visit https://vercel.com/help.\");\n    }\n};\nvar BlobNotFoundError = class extends BlobError {\n    constructor(){\n        super(\"The requested blob does not exist\");\n    }\n};\nvar BlobServiceNotAvailable = class extends BlobError {\n    constructor(){\n        super(\"The blob service is currently not available. Please try again.\");\n    }\n};\nvar BlobServiceRateLimited = class extends BlobError {\n    constructor(seconds){\n        super(`Too many requests please lower the number of concurrent requests ${seconds ? ` - try again in ${seconds} seconds` : \"\"}.`);\n        this.retryAfter = seconds != null ? seconds : 0;\n    }\n};\nvar BlobRequestAbortedError = class extends BlobError {\n    constructor(){\n        super(\"The request was aborted.\");\n    }\n};\nvar BLOB_API_VERSION = 11;\nfunction getApiVersion() {\n    let versionOverride = null;\n    try {\n        versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n    } catch  {}\n    return `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`;\n}\nfunction getRetries() {\n    try {\n        const retries = process.env.VERCEL_BLOB_RETRIES || \"10\";\n        return parseInt(retries, 10);\n    } catch  {\n        return 10;\n    }\n}\nfunction createBlobServiceRateLimited(response) {\n    const retryAfter = response.headers.get(\"retry-after\");\n    return new BlobServiceRateLimited(retryAfter ? parseInt(retryAfter, 10) : void 0);\n}\nasync function getBlobError(response) {\n    var _a3, _b2, _c;\n    let code;\n    let message;\n    try {\n        const data = await response.json();\n        code = (_b2 = (_a3 = data.error) == null ? void 0 : _a3.code) != null ? _b2 : \"unknown_error\";\n        message = (_c = data.error) == null ? void 0 : _c.message;\n    } catch  {\n        code = \"unknown_error\";\n    }\n    if ((message == null ? void 0 : message.includes(\"contentType\")) && message.includes(\"is not allowed\")) {\n        code = \"content_type_not_allowed\";\n    }\n    if ((message == null ? void 0 : message.includes('\"pathname\"')) && message.includes(\"does not match the token payload\")) {\n        code = \"client_token_pathname_mismatch\";\n    }\n    if (message === \"Token expired\") {\n        code = \"client_token_expired\";\n    }\n    if (message == null ? void 0 : message.includes(\"the file length cannot be greater than\")) {\n        code = \"file_too_large\";\n    }\n    let error;\n    switch(code){\n        case \"store_suspended\":\n            error = new BlobStoreSuspendedError();\n            break;\n        case \"forbidden\":\n            error = new BlobAccessError();\n            break;\n        case \"content_type_not_allowed\":\n            error = new BlobContentTypeNotAllowedError(message);\n            break;\n        case \"client_token_pathname_mismatch\":\n            error = new BlobPathnameMismatchError(message);\n            break;\n        case \"client_token_expired\":\n            error = new BlobClientTokenExpiredError();\n            break;\n        case \"file_too_large\":\n            error = new BlobFileTooLargeError(message);\n            break;\n        case \"not_found\":\n            error = new BlobNotFoundError();\n            break;\n        case \"store_not_found\":\n            error = new BlobStoreNotFoundError();\n            break;\n        case \"bad_request\":\n            error = new BlobError(message != null ? message : \"Bad request\");\n            break;\n        case \"service_unavailable\":\n            error = new BlobServiceNotAvailable();\n            break;\n        case \"rate_limited\":\n            error = createBlobServiceRateLimited(response);\n            break;\n        case \"unknown_error\":\n        case \"not_allowed\":\n        default:\n            error = new BlobUnknownError();\n            break;\n    }\n    return {\n        code,\n        error\n    };\n}\nasync function requestApi(pathname, init, commandOptions) {\n    const apiVersion = getApiVersion();\n    const token = getTokenFromOptionsOrEnv(commandOptions);\n    const extraHeaders = getProxyThroughAlternativeApiHeaderFromEnv();\n    const [, , , storeId = \"\"] = token.split(\"_\");\n    const requestId = `${storeId}:${Date.now()}:${Math.random().toString(16).slice(2)}`;\n    let retryCount = 0;\n    let bodyLength = 0;\n    let totalLoaded = 0;\n    const sendBodyLength = (commandOptions == null ? void 0 : commandOptions.onUploadProgress) || shouldUseXContentLength();\n    if (init.body && // 1. For upload progress we always need to know the total size of the body\n    // 2. In development we need the header for put() to work correctly when passing a stream\n    sendBodyLength) {\n        bodyLength = computeBodyLength(init.body);\n    }\n    if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n        commandOptions.onUploadProgress({\n            loaded: 0,\n            total: bodyLength,\n            percentage: 0\n        });\n    }\n    const apiResponse = await async_retry__WEBPACK_IMPORTED_MODULE_3__(async (bail)=>{\n        let res;\n        try {\n            res = await blobRequest({\n                input: getApiUrl(pathname),\n                init: {\n                    ...init,\n                    headers: {\n                        \"x-api-blob-request-id\": requestId,\n                        \"x-api-blob-request-attempt\": String(retryCount),\n                        \"x-api-version\": apiVersion,\n                        ...sendBodyLength ? {\n                            \"x-content-length\": String(bodyLength)\n                        } : {},\n                        authorization: `Bearer ${token}`,\n                        ...extraHeaders,\n                        ...init.headers\n                    }\n                },\n                onUploadProgress: (commandOptions == null ? void 0 : commandOptions.onUploadProgress) ? (loaded)=>{\n                    var _a3;\n                    const total = bodyLength !== 0 ? bodyLength : loaded;\n                    totalLoaded = loaded;\n                    const percentage = bodyLength > 0 ? Number((loaded / total * 100).toFixed(2)) : 0;\n                    if (percentage === 100 && bodyLength > 0) {\n                        return;\n                    }\n                    (_a3 = commandOptions.onUploadProgress) == null ? void 0 : _a3.call(commandOptions, {\n                        loaded,\n                        // When passing a stream to put(), we have no way to know the total size of the body.\n                        // Instead of defining total as total?: number we decided to set the total to the currently\n                        // loaded number. This is not inaccurate and way more practical for DX.\n                        // Passing down a stream to put() is very rare\n                        total,\n                        percentage\n                    });\n                } : void 0\n            });\n        } catch (error2) {\n            if (error2 instanceof DOMException2 && error2.name === \"AbortError\") {\n                bail(new BlobRequestAbortedError());\n                return;\n            }\n            if (isNetworkError(error2)) {\n                throw error2;\n            }\n            if (error2 instanceof TypeError) {\n                bail(error2);\n                return;\n            }\n            throw error2;\n        }\n        if (res.ok) {\n            return res;\n        }\n        const { code, error } = await getBlobError(res);\n        if (code === \"unknown_error\" || code === \"service_unavailable\" || code === \"internal_server_error\") {\n            throw error;\n        }\n        bail(error);\n    }, {\n        retries: getRetries(),\n        onRetry: (error)=>{\n            if (error instanceof Error) {\n                debug(`retrying API request to ${pathname}`, error.message);\n            }\n            retryCount = retryCount + 1;\n        }\n    });\n    if (!apiResponse) {\n        throw new BlobUnknownError();\n    }\n    if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n        commandOptions.onUploadProgress({\n            loaded: totalLoaded,\n            total: totalLoaded,\n            percentage: 100\n        });\n    }\n    return await apiResponse.json();\n}\nfunction getProxyThroughAlternativeApiHeaderFromEnv() {\n    const extraHeaders = {};\n    try {\n        if (\"VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n            extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n        } else if (\"NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n            extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n        }\n    } catch  {}\n    return extraHeaders;\n}\nfunction shouldUseXContentLength() {\n    try {\n        return process.env.VERCEL_BLOB_USE_X_CONTENT_LENGTH === \"1\";\n    } catch  {\n        return false;\n    }\n}\n// src/put-helpers.ts\nvar putOptionHeaderMap = {\n    cacheControlMaxAge: \"x-cache-control-max-age\",\n    addRandomSuffix: \"x-add-random-suffix\",\n    allowOverwrite: \"x-allow-overwrite\",\n    contentType: \"x-content-type\"\n};\nfunction createPutHeaders(allowedOptions, options) {\n    const headers = {};\n    if (allowedOptions.includes(\"contentType\") && options.contentType) {\n        headers[putOptionHeaderMap.contentType] = options.contentType;\n    }\n    if (allowedOptions.includes(\"addRandomSuffix\") && options.addRandomSuffix !== void 0) {\n        headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix ? \"1\" : \"0\";\n    }\n    if (allowedOptions.includes(\"allowOverwrite\") && options.allowOverwrite !== void 0) {\n        headers[putOptionHeaderMap.allowOverwrite] = options.allowOverwrite ? \"1\" : \"0\";\n    }\n    if (allowedOptions.includes(\"cacheControlMaxAge\") && options.cacheControlMaxAge !== void 0) {\n        headers[putOptionHeaderMap.cacheControlMaxAge] = options.cacheControlMaxAge.toString();\n    }\n    return headers;\n}\nasync function createPutOptions({ pathname, options, extraChecks, getToken }) {\n    if (!pathname) {\n        throw new BlobError(\"pathname is required\");\n    }\n    if (pathname.length > MAXIMUM_PATHNAME_LENGTH) {\n        throw new BlobError(`pathname is too long, maximum length is ${MAXIMUM_PATHNAME_LENGTH}`);\n    }\n    for (const invalidCharacter of disallowedPathnameCharacters){\n        if (pathname.includes(invalidCharacter)) {\n            throw new BlobError(`pathname cannot contain \"${invalidCharacter}\", please encode it if needed`);\n        }\n    }\n    if (!options) {\n        throw new BlobError(\"missing options, see usage\");\n    }\n    if (options.access !== \"public\") {\n        throw new BlobError('access must be \"public\"');\n    }\n    if (extraChecks) {\n        extraChecks(options);\n    }\n    if (getToken) {\n        options.token = await getToken(pathname, options);\n    }\n    return options;\n}\n// src/multipart/complete.ts\nfunction createCompleteMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n    return async (pathname, parts, optionsInput)=>{\n        const options = await createPutOptions({\n            pathname,\n            options: optionsInput,\n            extraChecks,\n            getToken\n        });\n        const headers = createPutHeaders(allowedOptions, options);\n        return completeMultipartUpload({\n            uploadId: options.uploadId,\n            key: options.key,\n            pathname,\n            headers,\n            options,\n            parts\n        });\n    };\n}\nasync function completeMultipartUpload({ uploadId, key, pathname, parts, headers, options }) {\n    const params = new URLSearchParams({\n        pathname\n    });\n    try {\n        const response = await requestApi(`/mpu?${params.toString()}`, {\n            method: \"POST\",\n            headers: {\n                ...headers,\n                \"content-type\": \"application/json\",\n                \"x-mpu-action\": \"complete\",\n                \"x-mpu-upload-id\": uploadId,\n                // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n                // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n                \"x-mpu-key\": encodeURIComponent(key)\n            },\n            body: JSON.stringify(parts),\n            signal: options.abortSignal\n        }, options);\n        debug(\"mpu: complete\", response);\n        return response;\n    } catch (error) {\n        if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n            throw new BlobServiceNotAvailable();\n        } else {\n            throw error;\n        }\n    }\n}\n// src/multipart/create.ts\nfunction createCreateMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n    return async (pathname, optionsInput)=>{\n        const options = await createPutOptions({\n            pathname,\n            options: optionsInput,\n            extraChecks,\n            getToken\n        });\n        const headers = createPutHeaders(allowedOptions, options);\n        const createMultipartUploadResponse = await createMultipartUpload(pathname, headers, options);\n        return {\n            key: createMultipartUploadResponse.key,\n            uploadId: createMultipartUploadResponse.uploadId\n        };\n    };\n}\nasync function createMultipartUpload(pathname, headers, options) {\n    debug(\"mpu: create\", \"pathname:\", pathname);\n    const params = new URLSearchParams({\n        pathname\n    });\n    try {\n        const response = await requestApi(`/mpu?${params.toString()}`, {\n            method: \"POST\",\n            headers: {\n                ...headers,\n                \"x-mpu-action\": \"create\"\n            },\n            signal: options.abortSignal\n        }, options);\n        debug(\"mpu: create\", response);\n        return response;\n    } catch (error) {\n        if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n            throw new BlobServiceNotAvailable();\n        }\n        throw error;\n    }\n}\n// src/multipart/upload.ts\n\nfunction createUploadPartMethod({ allowedOptions, getToken, extraChecks }) {\n    return async (pathname, body, optionsInput)=>{\n        const options = await createPutOptions({\n            pathname,\n            options: optionsInput,\n            extraChecks,\n            getToken\n        });\n        const headers = createPutHeaders(allowedOptions, options);\n        if (isPlainObject(body)) {\n            throw new BlobError(\"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\");\n        }\n        const result = await uploadPart({\n            uploadId: options.uploadId,\n            key: options.key,\n            pathname,\n            part: {\n                blob: body,\n                partNumber: options.partNumber\n            },\n            headers,\n            options\n        });\n        return {\n            etag: result.etag,\n            partNumber: options.partNumber\n        };\n    };\n}\nasync function uploadPart({ uploadId, key, pathname, headers, options, internalAbortController = new AbortController(), part }) {\n    var _a3, _b2, _c;\n    const params = new URLSearchParams({\n        pathname\n    });\n    const responsePromise = requestApi(`/mpu?${params.toString()}`, {\n        signal: internalAbortController.signal,\n        method: \"POST\",\n        headers: {\n            ...headers,\n            \"x-mpu-action\": \"upload\",\n            \"x-mpu-key\": encodeURIComponent(key),\n            \"x-mpu-upload-id\": uploadId,\n            \"x-mpu-part-number\": part.partNumber.toString()\n        },\n        // weird things between undici types and native fetch types\n        body: part.blob\n    }, options);\n    function handleAbort() {\n        internalAbortController.abort();\n    }\n    if ((_a3 = options.abortSignal) == null ? void 0 : _a3.aborted) {\n        handleAbort();\n    } else {\n        (_b2 = options.abortSignal) == null ? void 0 : _b2.addEventListener(\"abort\", handleAbort);\n    }\n    const response = await responsePromise;\n    (_c = options.abortSignal) == null ? void 0 : _c.removeEventListener(\"abort\", handleAbort);\n    return response;\n}\nvar maxConcurrentUploads =  false ? 0 : 8;\nvar partSizeInBytes = 8 * 1024 * 1024;\nvar maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\nfunction uploadAllParts({ uploadId, key, pathname, stream, headers, options, totalToLoad }) {\n    debug(\"mpu: upload init\", \"key:\", key);\n    const internalAbortController = new AbortController();\n    return new Promise((resolve, reject)=>{\n        const partsToUpload = [];\n        const completedParts = [];\n        const reader = stream.getReader();\n        let activeUploads = 0;\n        let reading = false;\n        let currentPartNumber = 1;\n        let rejected = false;\n        let currentBytesInMemory = 0;\n        let doneReading = false;\n        let bytesSent = 0;\n        let arrayBuffers = [];\n        let currentPartBytesRead = 0;\n        let onUploadProgress;\n        const totalLoadedPerPartNumber = {};\n        if (options.onUploadProgress) {\n            onUploadProgress = throttleit__WEBPACK_IMPORTED_MODULE_5__(()=>{\n                var _a3;\n                const loaded = Object.values(totalLoadedPerPartNumber).reduce((acc, cur)=>{\n                    return acc + cur;\n                }, 0);\n                const total = totalToLoad || loaded;\n                const percentage = totalToLoad > 0 ? Number(((loaded / totalToLoad || loaded) * 100).toFixed(2)) : 0;\n                (_a3 = options.onUploadProgress) == null ? void 0 : _a3.call(options, {\n                    loaded,\n                    total,\n                    percentage\n                });\n            }, 150);\n        }\n        read().catch(cancel);\n        async function read() {\n            debug(\"mpu: upload read start\", \"activeUploads:\", activeUploads, \"currentBytesInMemory:\", `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`, \"bytesSent:\", bytes(bytesSent));\n            reading = true;\n            while(currentBytesInMemory < maxBytesInMemory && !rejected){\n                try {\n                    const { value, done } = await reader.read();\n                    if (done) {\n                        doneReading = true;\n                        debug(\"mpu: upload read consumed the whole stream\");\n                        if (arrayBuffers.length > 0) {\n                            partsToUpload.push({\n                                partNumber: currentPartNumber++,\n                                blob: new Blob(arrayBuffers, {\n                                    type: \"application/octet-stream\"\n                                })\n                            });\n                            sendParts();\n                        }\n                        reading = false;\n                        return;\n                    }\n                    currentBytesInMemory += value.byteLength;\n                    let valueOffset = 0;\n                    while(valueOffset < value.byteLength){\n                        const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n                        const endOffset = Math.min(valueOffset + remainingPartSize, value.byteLength);\n                        const chunk = value.slice(valueOffset, endOffset);\n                        arrayBuffers.push(chunk);\n                        currentPartBytesRead += chunk.byteLength;\n                        valueOffset = endOffset;\n                        if (currentPartBytesRead === partSizeInBytes) {\n                            partsToUpload.push({\n                                partNumber: currentPartNumber++,\n                                blob: new Blob(arrayBuffers, {\n                                    type: \"application/octet-stream\"\n                                })\n                            });\n                            arrayBuffers = [];\n                            currentPartBytesRead = 0;\n                            sendParts();\n                        }\n                    }\n                } catch (error) {\n                    cancel(error);\n                }\n            }\n            debug(\"mpu: upload read end\", \"activeUploads:\", activeUploads, \"currentBytesInMemory:\", `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`, \"bytesSent:\", bytes(bytesSent));\n            reading = false;\n        }\n        async function sendPart(part) {\n            activeUploads++;\n            debug(\"mpu: upload send part start\", \"partNumber:\", part.partNumber, \"size:\", part.blob.size, \"activeUploads:\", activeUploads, \"currentBytesInMemory:\", `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`, \"bytesSent:\", bytes(bytesSent));\n            try {\n                const uploadProgressForPart = options.onUploadProgress ? (event)=>{\n                    totalLoadedPerPartNumber[part.partNumber] = event.loaded;\n                    if (onUploadProgress) {\n                        onUploadProgress();\n                    }\n                } : void 0;\n                const completedPart = await uploadPart({\n                    uploadId,\n                    key,\n                    pathname,\n                    headers,\n                    options: {\n                        ...options,\n                        onUploadProgress: uploadProgressForPart\n                    },\n                    internalAbortController,\n                    part\n                });\n                debug(\"mpu: upload send part end\", \"partNumber:\", part.partNumber, \"activeUploads\", activeUploads, \"currentBytesInMemory:\", `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`, \"bytesSent:\", bytes(bytesSent));\n                if (rejected) {\n                    return;\n                }\n                completedParts.push({\n                    partNumber: part.partNumber,\n                    etag: completedPart.etag\n                });\n                currentBytesInMemory -= part.blob.size;\n                activeUploads--;\n                bytesSent += part.blob.size;\n                if (partsToUpload.length > 0) {\n                    sendParts();\n                }\n                if (doneReading) {\n                    if (activeUploads === 0) {\n                        reader.releaseLock();\n                        resolve(completedParts);\n                    }\n                    return;\n                }\n                if (!reading) {\n                    read().catch(cancel);\n                }\n            } catch (error) {\n                cancel(error);\n            }\n        }\n        function sendParts() {\n            if (rejected) {\n                return;\n            }\n            debug(\"send parts\", \"activeUploads\", activeUploads, \"partsToUpload\", partsToUpload.length);\n            while(activeUploads < maxConcurrentUploads && partsToUpload.length > 0){\n                const partToSend = partsToUpload.shift();\n                if (partToSend) {\n                    void sendPart(partToSend);\n                }\n            }\n        }\n        function cancel(error) {\n            if (rejected) {\n                return;\n            }\n            rejected = true;\n            internalAbortController.abort();\n            reader.releaseLock();\n            if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n                reject(new BlobServiceNotAvailable());\n            } else {\n                reject(error);\n            }\n        }\n    });\n}\n// src/multipart/create-uploader.ts\nfunction createCreateMultipartUploaderMethod({ allowedOptions, getToken, extraChecks }) {\n    return async (pathname, optionsInput)=>{\n        const options = await createPutOptions({\n            pathname,\n            options: optionsInput,\n            extraChecks,\n            getToken\n        });\n        const headers = createPutHeaders(allowedOptions, options);\n        const createMultipartUploadResponse = await createMultipartUpload(pathname, headers, options);\n        return {\n            key: createMultipartUploadResponse.key,\n            uploadId: createMultipartUploadResponse.uploadId,\n            async uploadPart (partNumber, body) {\n                if (isPlainObject(body)) {\n                    throw new BlobError(\"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\");\n                }\n                const result = await uploadPart({\n                    uploadId: createMultipartUploadResponse.uploadId,\n                    key: createMultipartUploadResponse.key,\n                    pathname,\n                    part: {\n                        partNumber,\n                        blob: body\n                    },\n                    headers,\n                    options\n                });\n                return {\n                    etag: result.etag,\n                    partNumber\n                };\n            },\n            async complete (parts) {\n                return completeMultipartUpload({\n                    uploadId: createMultipartUploadResponse.uploadId,\n                    key: createMultipartUploadResponse.key,\n                    pathname,\n                    parts,\n                    headers,\n                    options\n                });\n            }\n        };\n    };\n}\n// src/put.ts\n\n// src/multipart/uncontrolled.ts\nasync function uncontrolledMultipartUpload(pathname, body, headers, options) {\n    debug(\"mpu: init\", \"pathname:\", pathname, \"headers:\", headers);\n    const optionsWithoutOnUploadProgress = {\n        ...options,\n        onUploadProgress: void 0\n    };\n    const createMultipartUploadResponse = await createMultipartUpload(pathname, headers, optionsWithoutOnUploadProgress);\n    const totalToLoad = computeBodyLength(body);\n    const stream = await toReadableStream(body);\n    const parts = await uploadAllParts({\n        uploadId: createMultipartUploadResponse.uploadId,\n        key: createMultipartUploadResponse.key,\n        pathname,\n        stream,\n        headers,\n        options,\n        totalToLoad\n    });\n    const blob = await completeMultipartUpload({\n        uploadId: createMultipartUploadResponse.uploadId,\n        key: createMultipartUploadResponse.key,\n        pathname,\n        parts,\n        headers,\n        options: optionsWithoutOnUploadProgress\n    });\n    return blob;\n}\n// src/put.ts\nfunction createPutMethod({ allowedOptions, getToken, extraChecks }) {\n    return async function put(pathname, body, optionsInput) {\n        if (!body) {\n            throw new BlobError(\"body is required\");\n        }\n        if (isPlainObject(body)) {\n            throw new BlobError(\"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\");\n        }\n        const options = await createPutOptions({\n            pathname,\n            options: optionsInput,\n            extraChecks,\n            getToken\n        });\n        const headers = createPutHeaders(allowedOptions, options);\n        if (options.multipart === true) {\n            return uncontrolledMultipartUpload(pathname, body, headers, options);\n        }\n        const onUploadProgress = options.onUploadProgress ? throttleit__WEBPACK_IMPORTED_MODULE_5__(options.onUploadProgress, 100) : void 0;\n        const params = new URLSearchParams({\n            pathname\n        });\n        const response = await requestApi(`/?${params.toString()}`, {\n            method: \"PUT\",\n            body,\n            headers,\n            signal: options.abortSignal\n        }, {\n            ...options,\n            onUploadProgress\n        });\n        return {\n            url: response.url,\n            downloadUrl: response.downloadUrl,\n            pathname: response.pathname,\n            contentType: response.contentType,\n            contentDisposition: response.contentDisposition\n        };\n    };\n}\n// src/create-folder.ts\nasync function createFolder(pathname, options = {}) {\n    const folderPathname = pathname.endsWith(\"/\") ? pathname : `${pathname}/`;\n    const headers = {};\n    headers[putOptionHeaderMap.addRandomSuffix] = \"0\";\n    const params = new URLSearchParams({\n        pathname: folderPathname\n    });\n    const response = await requestApi(`/?${params.toString()}`, {\n        method: \"PUT\",\n        headers,\n        signal: options.abortSignal\n    }, options);\n    return {\n        url: response.url,\n        pathname: response.pathname\n    };\n}\n /*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */  //# sourceMappingURL=chunk-FN6XFH6R.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2h1bmstRk42WEZINlIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCO0FBQytCO0FBRWhELDJCQUEyQjtBQUNNO0FBQ0M7QUFDbEMsSUFBSUcsaUNBQWlDLElBQUlDLFFBQVEsQ0FBQ0M7SUFDaEQsSUFBSTtRQUNGLE1BQU1DLHFCQUFxQixJQUFJQyxXQUFXO1lBQUM7WUFBSztZQUFLO1lBQUs7WUFBSztTQUFJO1FBQ25FLE1BQU1DLE9BQU8sSUFBSUMsS0FBSztZQUFDSDtTQUFtQjtRQUMxQ0UsS0FBS0UsSUFBSSxHQUFHQyxJQUFJLENBQUMsQ0FBQ0Q7WUFDaEJMLFFBQVFLLFNBQVM7UUFDbkIsR0FBR0UsS0FBSyxDQUFDO1lBQ1BQLFFBQVE7UUFDVjtJQUNGLEVBQUUsT0FBTTtRQUNOQSxRQUFRO0lBQ1Y7QUFDRjtBQUNBLGVBQWVRLGlCQUFpQkMsS0FBSztJQUNuQyxJQUFJQSxpQkFBaUJDLGdCQUFnQjtRQUNuQyxPQUFPRDtJQUNUO0lBQ0EsSUFBSUEsaUJBQWlCTCxNQUFNO1FBQ3pCLE9BQU9LLE1BQU1FLE1BQU07SUFDckI7SUFDQSxJQUFJQyx1QkFBdUJILFFBQVE7UUFDakMsT0FBT1osNENBQVFBLENBQUNnQixLQUFLLENBQUNKO0lBQ3hCO0lBQ0EsSUFBSUs7SUFDSixJQUFJTCxpQkFBaUJNLGFBQWE7UUFDaENELGNBQWMsSUFBSVosV0FBV087SUFDL0IsT0FBTyxJQUFJTyxlQUFlUCxRQUFRO1FBQ2hDSyxjQUFjTDtJQUNoQixPQUFPO1FBQ0xLLGNBQWNHLG1CQUFtQlI7SUFDbkM7SUFDQSxJQUFJLE1BQU1YLGdDQUFnQztRQUN4QyxPQUFPLElBQUlNLEtBQUs7WUFBQ1U7U0FBWSxFQUFFSCxNQUFNO0lBQ3ZDO0lBQ0EsT0FBTyxJQUFJRCxlQUFlO1FBQ3hCUSxPQUFNQyxVQUFVO1lBQ2RBLFdBQVdDLE9BQU8sQ0FB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LEVBQUUsRUFBRTRDLE9BQU9sTSxRQUFRLEdBQUcsQ0FBQyxFQUN4QjtRQUNFaUIsUUFBUTtRQUNSRTtRQUNBNEUsUUFBUTlHLFFBQVFzTixXQUFXO0lBQzdCLEdBQ0F0TjtJQUVGLE9BQU87UUFDTFcsS0FBS2dILFNBQVNoSCxHQUFHO1FBQ2pCeUIsVUFBVXVGLFNBQVN2RixRQUFRO0lBQzdCO0FBQ0Y7QUEyQkUsQ0FDRjs7Ozs7Q0FLQyxJQUNELDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ryb3Bjb2RlLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvYmxvYi9kaXN0L2NodW5rLUZONlhGSDZSLmpzPzJhNGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2hlbHBlcnMudHNcbmltcG9ydCB7IGlzTm9kZVByb2Nlc3MgfSBmcm9tIFwiaXMtbm9kZS1wcm9jZXNzXCI7XG5cbi8vIHNyYy9tdWx0aXBhcnQvaGVscGVycy50c1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gXCJpcy1idWZmZXJcIjtcbmltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSBcInN0cmVhbVwiO1xudmFyIHN1cHBvcnRzTmV3QmxvYkZyb21BcnJheUJ1ZmZlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgaGVsbG9Bc0FycmF5QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExXSk7XG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtoZWxsb0FzQXJyYXlCdWZmZXJdKTtcbiAgICBibG9iLnRleHQoKS50aGVuKCh0ZXh0KSA9PiB7XG4gICAgICByZXNvbHZlKHRleHQgPT09IFwiaGVsbG9cIik7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgfSk7XG4gIH0gY2F0Y2gge1xuICAgIHJlc29sdmUoZmFsc2UpO1xuICB9XG59KTtcbmFzeW5jIGZ1bmN0aW9uIHRvUmVhZGFibGVTdHJlYW0odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiB2YWx1ZS5zdHJlYW0oKTtcbiAgfVxuICBpZiAoaXNOb2RlSnNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gUmVhZGFibGUudG9XZWIodmFsdWUpO1xuICB9XG4gIGxldCBzdHJlYW1WYWx1ZTtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBzdHJlYW1WYWx1ZSA9IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc05vZGVKc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICBzdHJlYW1WYWx1ZSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbVZhbHVlID0gc3RyaW5nVG9VaW50OEFycmF5KHZhbHVlKTtcbiAgfVxuICBpZiAoYXdhaXQgc3VwcG9ydHNOZXdCbG9iRnJvbUFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtzdHJlYW1WYWx1ZV0pLnN0cmVhbSgpO1xuICB9XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShzdHJlYW1WYWx1ZSk7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzTm9kZUpzUmVhZGFibGVTdHJlYW0odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUucGlwZSA9PT0gXCJmdW5jdGlvblwiICYmIHZhbHVlLnJlYWRhYmxlICYmIHR5cGVvZiB2YWx1ZS5fcmVhZCA9PT0gXCJmdW5jdGlvblwiICYmIC8vIEB0cy1leHBlY3QtZXJyb3IgX3JlYWRhYmxlU3RhdGUgZG9lcyBleGlzdHMgb24gUmVhZGFibGVcbiAgdHlwZW9mIHZhbHVlLl9yZWFkYWJsZVN0YXRlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9VaW50OEFycmF5KHMpIHtcbiAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHJldHVybiBlbmMuZW5jb2RlKHMpO1xufVxuZnVuY3Rpb24gaXNOb2RlSnNCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIGlzQnVmZmVyKHZhbHVlKTtcbn1cblxuLy8gc3JjL2J5dGVzLnRzXG52YXIgcGFyc2VSZWdFeHAgPSAvXigoLXxcXCspPyhcXGQrKD86XFwuXFxkKyk/KSkgKihrYnxtYnxnYnx0YnxwYikkL2k7XG52YXIgbWFwID0ge1xuICBiOiAxLFxuICBrYjogMSA8PCAxMCxcbiAgbWI6IDEgPDwgMjAsXG4gIGdiOiAxIDw8IDMwLFxuICB0YjogMTAyNCAqKiA0LFxuICBwYjogMTAyNCAqKiA1XG59O1xuZnVuY3Rpb24gYnl0ZXModmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmICFOdW1iZXIuaXNOYU4odmFsKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCByZXN1bHRzID0gcGFyc2VSZWdFeHAuZXhlYyh2YWwpO1xuICBsZXQgZmxvYXRWYWx1ZTtcbiAgbGV0IHVuaXQgPSBcImJcIjtcbiAgaWYgKCFyZXN1bHRzKSB7XG4gICAgZmxvYXRWYWx1ZSA9IHBhcnNlSW50KHZhbCwgMTApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFssIHJlcywgLCAsIHVuaXRNYXRjaF0gPSByZXN1bHRzO1xuICAgIGlmICghcmVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQocmVzKTtcbiAgICBpZiAodW5pdE1hdGNoKSB7XG4gICAgICB1bml0ID0gdW5pdE1hdGNoLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZmxvYXRWYWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gTWF0aC5mbG9vcihtYXBbdW5pdF0gKiBmbG9hdFZhbHVlKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMudHNcbnZhciBkZWZhdWx0VmVyY2VsQmxvYkFwaVVybCA9IFwiaHR0cHM6Ly92ZXJjZWwuY29tL2FwaS9ibG9iXCI7XG5mdW5jdGlvbiBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50b2tlbikge1xuICAgIHJldHVybiBvcHRpb25zLnRva2VuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5CTE9CX1JFQURfV1JJVEVfVE9LRU4pIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuQkxPQl9SRUFEX1dSSVRFX1RPS0VOO1xuICB9XG4gIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgXCJObyB0b2tlbiBmb3VuZC4gRWl0aGVyIGNvbmZpZ3VyZSB0aGUgYEJMT0JfUkVBRF9XUklURV9UT0tFTmAgZW52aXJvbm1lbnQgdmFyaWFibGUsIG9yIHBhc3MgYSBgdG9rZW5gIG9wdGlvbiB0byB5b3VyIGNhbGxzLlwiXG4gICk7XG59XG52YXIgQmxvYkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihgVmVyY2VsIEJsb2I6ICR7bWVzc2FnZX1gKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldERvd25sb2FkVXJsKGJsb2JVcmwpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChibG9iVXJsKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJkb3dubG9hZFwiLCBcIjFcIik7XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSk7XG59XG52YXIgZGlzYWxsb3dlZFBhdGhuYW1lQ2hhcmFjdGVycyA9IFtcIi8vXCJdO1xudmFyIHN1cHBvcnRzUmVxdWVzdFN0cmVhbXMgPSAoKCkgPT4ge1xuICBpZiAoaXNOb2RlUHJvY2VzcygpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYXBpVXJsID0gZ2V0QXBpVXJsKCk7XG4gIGlmIChhcGlVcmwuc3RhcnRzV2l0aChcImh0dHA6Ly9sb2NhbGhvc3RcIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGR1cGxleEFjY2Vzc2VkID0gZmFsc2U7XG4gIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gbmV3IFJlcXVlc3QoZ2V0QXBpVXJsKCksIHtcbiAgICBib2R5OiBuZXcgUmVhZGFibGVTdHJlYW0oKSxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gVHlwZVNjcmlwdCBkb2Vzbid0IHlldCBoYXZlIGR1cGxleCBidXQgaXQncyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0LURPTS1saWItZ2VuZXJhdG9yL3B1bGwvMTcyOVxuICAgIGdldCBkdXBsZXgoKSB7XG4gICAgICBkdXBsZXhBY2Nlc3NlZCA9IHRydWU7XG4gICAgICByZXR1cm4gXCJoYWxmXCI7XG4gICAgfVxuICB9KS5oZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKTtcbiAgcmV0dXJuIGR1cGxleEFjY2Vzc2VkICYmICFoYXNDb250ZW50VHlwZTtcbn0pKCk7XG5mdW5jdGlvbiBnZXRBcGlVcmwocGF0aG5hbWUgPSBcIlwiKSB7XG4gIGxldCBiYXNlVXJsID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBiYXNlVXJsID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfQVBJX1VSTCB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVVJMO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gYCR7YmFzZVVybCB8fCBkZWZhdWx0VmVyY2VsQmxvYkFwaVVybH0ke3BhdGhuYW1lfWA7XG59XG52YXIgVEVYVF9FTkNPREVSID0gdHlwZW9mIFRleHRFbmNvZGVyID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgVGV4dEVuY29kZXIoKSA6IG51bGw7XG5mdW5jdGlvbiBjb21wdXRlQm9keUxlbmd0aChib2R5KSB7XG4gIGlmICghYm9keSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChURVhUX0VOQ09ERVIpIHtcbiAgICAgIHJldHVybiBURVhUX0VOQ09ERVIuZW5jb2RlKGJvZHkpLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQmxvYihbYm9keV0pLnNpemU7XG4gIH1cbiAgaWYgKFwiYnl0ZUxlbmd0aFwiIGluIGJvZHkgJiYgdHlwZW9mIGJvZHkuYnl0ZUxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGg7XG4gIH1cbiAgaWYgKFwic2l6ZVwiIGluIGJvZHkgJiYgdHlwZW9mIGJvZHkuc2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBib2R5LnNpemU7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgY3JlYXRlQ2h1bmtUcmFuc2Zvcm1TdHJlYW0gPSAoY2h1bmtTaXplLCBvblByb2dyZXNzKSA9PiB7XG4gIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIubGVuZ3RoICsgY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIG5ld0J1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgbmV3QnVmZmVyLnNldChuZXcgVWludDhBcnJheShjaHVuayksIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICBidWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoID49IGNodW5rU2l6ZSkge1xuICAgICAgICAgIGNvbnN0IG5ld0NodW5rID0gYnVmZmVyLnNsaWNlKDAsIGNodW5rU2l6ZSk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ld0NodW5rKTtcbiAgICAgICAgICBvblByb2dyZXNzID09IG51bGwgPyB2b2lkIDAgOiBvblByb2dyZXNzKG5ld0NodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShjaHVua1NpemUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICAgICAgb25Qcm9ncmVzcyA9PSBudWxsID8gdm9pZCAwIDogb25Qcm9ncmVzcyhidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSAmJiAvLyBUT0RPOiBDYW4gYmUgcmVtb3ZlZCBvbmNlIE5vZGUuanMgMTYgaXMgbm8gbW9yZSByZXF1aXJlZCBpbnRlcm5hbGx5XG4gIHZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG59XG5mdW5jdGlvbiBpc1N0cmVhbSh2YWx1ZSkge1xuICBpZiAoaXNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNOb2RlSnNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9hcGkudHNcbmltcG9ydCByZXRyeSBmcm9tIFwiYXN5bmMtcmV0cnlcIjtcblxuLy8gc3JjL2RlYnVnLnRzXG52YXIgZGVidWdJc0FjdGl2ZSA9IGZhbHNlO1xudmFyIF9hLCBfYjtcbnRyeSB7XG4gIGlmICgoKF9hID0gcHJvY2Vzcy5lbnYuREVCVUcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhcImJsb2JcIikpIHx8ICgoX2IgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19ERUJVRykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwiYmxvYlwiKSkpIHtcbiAgICBkZWJ1Z0lzQWN0aXZlID0gdHJ1ZTtcbiAgfVxufSBjYXRjaCB7XG59XG5mdW5jdGlvbiBkZWJ1ZyhtZXNzYWdlLCAuLi5hcmdzKSB7XG4gIGlmIChkZWJ1Z0lzQWN0aXZlKSB7XG4gICAgY29uc29sZS5kZWJ1ZyhgdmVyY2VsLWJsb2I6ICR7bWVzc2FnZX1gLCAuLi5hcmdzKTtcbiAgfVxufVxuXG4vLyBzcmMvZG9tLWV4Y2VwdGlvbi50c1xudmFyIF9hMjtcbnZhciBET01FeGNlcHRpb24yID0gKF9hMiA9IGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uKSAhPSBudWxsID8gX2EyIDogKCgpID0+IHtcbiAgdHJ5IHtcbiAgICBhdG9iKFwiflwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihlcnIpLmNvbnN0cnVjdG9yO1xuICB9XG59KSgpO1xuXG4vLyBzcmMvaXMtbmV0d29yay1lcnJvci50c1xudmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0Vycm9yID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IEVycm9yXVwiO1xudmFyIGVycm9yTWVzc2FnZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwibmV0d29yayBlcnJvclwiLFxuICAvLyBDaHJvbWVcbiAgXCJGYWlsZWQgdG8gZmV0Y2hcIixcbiAgLy8gQ2hyb21lXG4gIFwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS5cIixcbiAgLy8gRmlyZWZveFxuICBcIlRoZSBJbnRlcm5ldCBjb25uZWN0aW9uIGFwcGVhcnMgdG8gYmUgb2ZmbGluZS5cIixcbiAgLy8gU2FmYXJpIDE2XG4gIFwiTG9hZCBmYWlsZWRcIixcbiAgLy8gU2FmYXJpIDE3K1xuICBcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWRcIixcbiAgLy8gYGNyb3NzLWZldGNoYFxuICBcImZldGNoIGZhaWxlZFwiLFxuICAvLyBVbmRpY2kgKE5vZGUuanMpXG4gIFwidGVybWluYXRlZFwiXG4gIC8vIFVuZGljaSAoTm9kZS5qcylcbl0pO1xuZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IoZXJyb3IpIHtcbiAgY29uc3QgaXNWYWxpZCA9IGVycm9yICYmIGlzRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09IFwiVHlwZUVycm9yXCIgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09IFwic3RyaW5nXCI7XG4gIGlmICghaXNWYWxpZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gXCJMb2FkIGZhaWxlZFwiKSB7XG4gICAgcmV0dXJuIGVycm9yLnN0YWNrID09PSB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGVycm9yTWVzc2FnZXMuaGFzKGVycm9yLm1lc3NhZ2UpO1xufVxuXG4vLyBzcmMvZmV0Y2gudHNcbmltcG9ydCB7IGZldGNoIH0gZnJvbSBcInVuZGljaVwiO1xudmFyIGhhc0ZldGNoID0gdHlwZW9mIGZldGNoID09PSBcImZ1bmN0aW9uXCI7XG52YXIgaGFzRmV0Y2hXaXRoVXBsb2FkUHJvZ3Jlc3MgPSBoYXNGZXRjaCAmJiBzdXBwb3J0c1JlcXVlc3RTdHJlYW1zO1xudmFyIENIVU5LX1NJWkUgPSA2NCAqIDEwMjQ7XG52YXIgYmxvYkZldGNoID0gYXN5bmMgKHtcbiAgaW5wdXQsXG4gIGluaXQsXG4gIG9uVXBsb2FkUHJvZ3Jlc3Ncbn0pID0+IHtcbiAgZGVidWcoXCJ1c2luZyBmZXRjaFwiKTtcbiAgbGV0IGJvZHk7XG4gIGlmIChpbml0LmJvZHkpIHtcbiAgICBpZiAob25VcGxvYWRQcm9ncmVzcykge1xuICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdG9SZWFkYWJsZVN0cmVhbShpbml0LmJvZHkpO1xuICAgICAgbGV0IGxvYWRlZCA9IDA7XG4gICAgICBjb25zdCBjaHVua1RyYW5zZm9ybVN0cmVhbSA9IGNyZWF0ZUNodW5rVHJhbnNmb3JtU3RyZWFtKFxuICAgICAgICBDSFVOS19TSVpFLFxuICAgICAgICAobmV3TG9hZGVkKSA9PiB7XG4gICAgICAgICAgbG9hZGVkICs9IG5ld0xvYWRlZDtcbiAgICAgICAgICBvblVwbG9hZFByb2dyZXNzKGxvYWRlZCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBib2R5ID0gc3RyZWFtLnBpcGVUaHJvdWdoKGNodW5rVHJhbnNmb3JtU3RyZWFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keSA9IGluaXQuYm9keTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZHVwbGV4ID0gc3VwcG9ydHNSZXF1ZXN0U3RyZWFtcyAmJiBib2R5ICYmIGlzU3RyZWFtKGJvZHkpID8gXCJoYWxmXCIgOiB2b2lkIDA7XG4gIHJldHVybiBmZXRjaChcbiAgICBpbnB1dCxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIEJsb2IgYW5kIE5vZGVqcyBCbG9iIGFyZSB0cmlnZ2VyaW5nIHR5cGUgZXJyb3JzLCBmaW5lIHdpdGggaXRcbiAgICB7XG4gICAgICAuLi5pbml0LFxuICAgICAgLi4uaW5pdC5ib2R5ID8geyBib2R5IH0gOiB7fSxcbiAgICAgIGR1cGxleFxuICAgIH1cbiAgKTtcbn07XG5cbi8vIHNyYy94aHIudHNcbnZhciBoYXNYaHIgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgYmxvYlhociA9IGFzeW5jICh7XG4gIGlucHV0LFxuICBpbml0LFxuICBvblVwbG9hZFByb2dyZXNzXG59KSA9PiB7XG4gIGRlYnVnKFwidXNpbmcgeGhyXCIpO1xuICBsZXQgYm9keSA9IG51bGw7XG4gIGlmIChpbml0LmJvZHkpIHtcbiAgICBpZiAoaXNSZWFkYWJsZVN0cmVhbShpbml0LmJvZHkpKSB7XG4gICAgICBib2R5ID0gYXdhaXQgbmV3IFJlc3BvbnNlKGluaXQuYm9keSkuYmxvYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0gaW5pdC5ib2R5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKGluaXQubWV0aG9kIHx8IFwiR0VUXCIsIGlucHV0LnRvU3RyaW5nKCksIHRydWUpO1xuICAgIGlmIChvblVwbG9hZFByb2dyZXNzKSB7XG4gICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICBvblVwbG9hZFByb2dyZXNzKGV2ZW50LmxvYWRlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgICAgdmFyIF9hMztcbiAgICAgIGlmICgoX2EzID0gaW5pdC5zaWduYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuYWJvcnRlZCkge1xuICAgICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbihcIlRoZSB1c2VyIGFib3J0ZWQgdGhlIHJlcXVlc3QuXCIsIFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgY29uc3QgcmF3SGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS50cmltKCkuc3BsaXQoL1tcXHJcXG5dKy8pO1xuICAgICAgcmF3SGVhZGVycy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdChcIjogXCIpO1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnRzLmpvaW4oXCI6IFwiKTtcbiAgICAgICAgaWYgKGtleSkgaGVhZGVycy5zZXQoa2V5LnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoeGhyLnJlc3BvbnNlLCB7XG4gICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKFwiTmV0d29yayByZXF1ZXN0IGZhaWxlZFwiKSk7XG4gICAgfTtcbiAgICB4aHIub250aW1lb3V0ID0gKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJOZXR3b3JrIHJlcXVlc3QgdGltZWQgb3V0XCIpKTtcbiAgICB9O1xuICAgIHhoci5vbmFib3J0ID0gKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBET01FeGNlcHRpb24oXCJUaGUgdXNlciBhYm9ydGVkIGEgcmVxdWVzdC5cIiwgXCJBYm9ydEVycm9yXCIpKTtcbiAgICB9O1xuICAgIGlmIChpbml0LmhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMpO1xuICAgICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbml0LnNpZ25hbCkge1xuICAgICAgaW5pdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbml0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHhoci5zZW5kKGJvZHkpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9yZXF1ZXN0LnRzXG52YXIgYmxvYlJlcXVlc3QgPSBhc3luYyAoe1xuICBpbnB1dCxcbiAgaW5pdCxcbiAgb25VcGxvYWRQcm9ncmVzc1xufSkgPT4ge1xuICBpZiAob25VcGxvYWRQcm9ncmVzcykge1xuICAgIGlmIChoYXNGZXRjaFdpdGhVcGxvYWRQcm9ncmVzcykge1xuICAgICAgcmV0dXJuIGJsb2JGZXRjaCh7IGlucHV0LCBpbml0LCBvblVwbG9hZFByb2dyZXNzIH0pO1xuICAgIH1cbiAgICBpZiAoaGFzWGhyKSB7XG4gICAgICByZXR1cm4gYmxvYlhocih7IGlucHV0LCBpbml0LCBvblVwbG9hZFByb2dyZXNzIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzRmV0Y2gpIHtcbiAgICByZXR1cm4gYmxvYkZldGNoKHsgaW5wdXQsIGluaXQgfSk7XG4gIH1cbiAgaWYgKGhhc1hocikge1xuICAgIHJldHVybiBibG9iWGhyKHsgaW5wdXQsIGluaXQgfSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVxdWVzdCBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGVcIik7XG59O1xuXG4vLyBzcmMvYXBpLnRzXG52YXIgTUFYSU1VTV9QQVRITkFNRV9MRU5HVEggPSA5NTA7XG52YXIgQmxvYkFjY2Vzc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkFjY2VzcyBkZW5pZWQsIHBsZWFzZSBwcm92aWRlIGEgdmFsaWQgdG9rZW4gZm9yIHRoaXMgcmVzb3VyY2UuXCIpO1xuICB9XG59O1xudmFyIEJsb2JDb250ZW50VHlwZU5vdEFsbG93ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKGBDb250ZW50IHR5cGUgbWlzbWF0Y2gsICR7bWVzc2FnZX0uYCk7XG4gIH1cbn07XG52YXIgQmxvYlBhdGhuYW1lTWlzbWF0Y2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKFxuICAgICAgYFBhdGhuYW1lIG1pc21hdGNoLCAke21lc3NhZ2V9LiBDaGVjayB0aGUgcGF0aG5hbWUgdXNlZCBpbiB1cGxvYWQoKSBvciBwdXQoKSBtYXRjaGVzIHRoZSBvbmUgZnJvbSB0aGUgY2xpZW50IHRva2VuLmBcbiAgICApO1xuICB9XG59O1xudmFyIEJsb2JDbGllbnRUb2tlbkV4cGlyZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJDbGllbnQgdG9rZW4gaGFzIGV4cGlyZWQuXCIpO1xuICB9XG59O1xudmFyIEJsb2JGaWxlVG9vTGFyZ2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKGBGaWxlIGlzIHRvbyBsYXJnZSwgJHttZXNzYWdlfS5gKTtcbiAgfVxufTtcbnZhciBCbG9iU3RvcmVOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoaXMgc3RvcmUgZG9lcyBub3QgZXhpc3QuXCIpO1xuICB9XG59O1xudmFyIEJsb2JTdG9yZVN1c3BlbmRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoaXMgc3RvcmUgaGFzIGJlZW4gc3VzcGVuZGVkLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iVW5rbm93bkVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlVua25vd24gZXJyb3IsIHBsZWFzZSB2aXNpdCBodHRwczovL3ZlcmNlbC5jb20vaGVscC5cIik7XG4gIH1cbn07XG52YXIgQmxvYk5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhlIHJlcXVlc3RlZCBibG9iIGRvZXMgbm90IGV4aXN0XCIpO1xuICB9XG59O1xudmFyIEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoZSBibG9iIHNlcnZpY2UgaXMgY3VycmVudGx5IG5vdCBhdmFpbGFibGUuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICB9XG59O1xudmFyIEJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNlY29uZHMpIHtcbiAgICBzdXBlcihcbiAgICAgIGBUb28gbWFueSByZXF1ZXN0cyBwbGVhc2UgbG93ZXIgdGhlIG51bWJlciBvZiBjb25jdXJyZW50IHJlcXVlc3RzICR7c2Vjb25kcyA/IGAgLSB0cnkgYWdhaW4gaW4gJHtzZWNvbmRzfSBzZWNvbmRzYCA6IFwiXCJ9LmBcbiAgICApO1xuICAgIHRoaXMucmV0cnlBZnRlciA9IHNlY29uZHMgIT0gbnVsbCA/IHNlY29uZHMgOiAwO1xuICB9XG59O1xudmFyIEJsb2JSZXF1ZXN0QWJvcnRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkLlwiKTtcbiAgfVxufTtcbnZhciBCTE9CX0FQSV9WRVJTSU9OID0gMTE7XG5mdW5jdGlvbiBnZXRBcGlWZXJzaW9uKCkge1xuICBsZXQgdmVyc2lvbk92ZXJyaWRlID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2ZXJzaW9uT3ZlcnJpZGUgPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9BUElfVkVSU0lPTl9PVkVSUklERSB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVkVSU0lPTl9PVkVSUklERTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGAke3ZlcnNpb25PdmVycmlkZSAhPSBudWxsID8gdmVyc2lvbk92ZXJyaWRlIDogQkxPQl9BUElfVkVSU0lPTn1gO1xufVxuZnVuY3Rpb24gZ2V0UmV0cmllcygpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXRyaWVzID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfUkVUUklFUyB8fCBcIjEwXCI7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJldHJpZXMsIDEwKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIDEwO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9iU2VydmljZVJhdGVMaW1pdGVkKHJlc3BvbnNlKSB7XG4gIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcInJldHJ5LWFmdGVyXCIpO1xuICByZXR1cm4gbmV3IEJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQoXG4gICAgcmV0cnlBZnRlciA/IHBhcnNlSW50KHJldHJ5QWZ0ZXIsIDEwKSA6IHZvaWQgMFxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QmxvYkVycm9yKHJlc3BvbnNlKSB7XG4gIHZhciBfYTMsIF9iMiwgX2M7XG4gIGxldCBjb2RlO1xuICBsZXQgbWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvZGUgPSAoX2IyID0gKF9hMyA9IGRhdGEuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY29kZSkgIT0gbnVsbCA/IF9iMiA6IFwidW5rbm93bl9lcnJvclwiO1xuICAgIG1lc3NhZ2UgPSAoX2MgPSBkYXRhLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MubWVzc2FnZTtcbiAgfSBjYXRjaCB7XG4gICAgY29kZSA9IFwidW5rbm93bl9lcnJvclwiO1xuICB9XG4gIGlmICgobWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbWVzc2FnZS5pbmNsdWRlcyhcImNvbnRlbnRUeXBlXCIpKSAmJiBtZXNzYWdlLmluY2x1ZGVzKFwiaXMgbm90IGFsbG93ZWRcIikpIHtcbiAgICBjb2RlID0gXCJjb250ZW50X3R5cGVfbm90X2FsbG93ZWRcIjtcbiAgfVxuICBpZiAoKG1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2UuaW5jbHVkZXMoJ1wicGF0aG5hbWVcIicpKSAmJiBtZXNzYWdlLmluY2x1ZGVzKFwiZG9lcyBub3QgbWF0Y2ggdGhlIHRva2VuIHBheWxvYWRcIikpIHtcbiAgICBjb2RlID0gXCJjbGllbnRfdG9rZW5fcGF0aG5hbWVfbWlzbWF0Y2hcIjtcbiAgfVxuICBpZiAobWVzc2FnZSA9PT0gXCJUb2tlbiBleHBpcmVkXCIpIHtcbiAgICBjb2RlID0gXCJjbGllbnRfdG9rZW5fZXhwaXJlZFwiO1xuICB9XG4gIGlmIChtZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlLmluY2x1ZGVzKFwidGhlIGZpbGUgbGVuZ3RoIGNhbm5vdCBiZSBncmVhdGVyIHRoYW5cIikpIHtcbiAgICBjb2RlID0gXCJmaWxlX3Rvb19sYXJnZVwiO1xuICB9XG4gIGxldCBlcnJvcjtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSBcInN0b3JlX3N1c3BlbmRlZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmb3JiaWRkZW5cIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JBY2Nlc3NFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvbnRlbnRfdHlwZV9ub3RfYWxsb3dlZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkNvbnRlbnRUeXBlTm90QWxsb3dlZEVycm9yKG1lc3NhZ2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNsaWVudF90b2tlbl9wYXRobmFtZV9taXNtYXRjaFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlBhdGhuYW1lTWlzbWF0Y2hFcnJvcihtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjbGllbnRfdG9rZW5fZXhwaXJlZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkNsaWVudFRva2VuRXhwaXJlZEVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZmlsZV90b29fbGFyZ2VcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JGaWxlVG9vTGFyZ2VFcnJvcihtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub3RfZm91bmRcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JOb3RGb3VuZEVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic3RvcmVfbm90X2ZvdW5kXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iU3RvcmVOb3RGb3VuZEVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYmFkX3JlcXVlc3RcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JFcnJvcihtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlIDogXCJCYWQgcmVxdWVzdFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzZXJ2aWNlX3VuYXZhaWxhYmxlXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJhdGVfbGltaXRlZFwiOlxuICAgICAgZXJyb3IgPSBjcmVhdGVCbG9iU2VydmljZVJhdGVMaW1pdGVkKHJlc3BvbnNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ1bmtub3duX2Vycm9yXCI6XG4gICAgY2FzZSBcIm5vdF9hbGxvd2VkXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JVbmtub3duRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7IGNvZGUsIGVycm9yIH07XG59XG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0QXBpKHBhdGhuYW1lLCBpbml0LCBjb21tYW5kT3B0aW9ucykge1xuICBjb25zdCBhcGlWZXJzaW9uID0gZ2V0QXBpVmVyc2lvbigpO1xuICBjb25zdCB0b2tlbiA9IGdldFRva2VuRnJvbU9wdGlvbnNPckVudihjb21tYW5kT3B0aW9ucyk7XG4gIGNvbnN0IGV4dHJhSGVhZGVycyA9IGdldFByb3h5VGhyb3VnaEFsdGVybmF0aXZlQXBpSGVhZGVyRnJvbUVudigpO1xuICBjb25zdCBbLCAsICwgc3RvcmVJZCA9IFwiXCJdID0gdG9rZW4uc3BsaXQoXCJfXCIpO1xuICBjb25zdCByZXF1ZXN0SWQgPSBgJHtzdG9yZUlkfToke0RhdGUubm93KCl9OiR7TWF0aC5yYW5kb20oKS50b1N0cmluZygxNikuc2xpY2UoMil9YDtcbiAgbGV0IHJldHJ5Q291bnQgPSAwO1xuICBsZXQgYm9keUxlbmd0aCA9IDA7XG4gIGxldCB0b3RhbExvYWRlZCA9IDA7XG4gIGNvbnN0IHNlbmRCb2R5TGVuZ3RoID0gKGNvbW1hbmRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSB8fCBzaG91bGRVc2VYQ29udGVudExlbmd0aCgpO1xuICBpZiAoaW5pdC5ib2R5ICYmIC8vIDEuIEZvciB1cGxvYWQgcHJvZ3Jlc3Mgd2UgYWx3YXlzIG5lZWQgdG8ga25vdyB0aGUgdG90YWwgc2l6ZSBvZiB0aGUgYm9keVxuICAvLyAyLiBJbiBkZXZlbG9wbWVudCB3ZSBuZWVkIHRoZSBoZWFkZXIgZm9yIHB1dCgpIHRvIHdvcmsgY29ycmVjdGx5IHdoZW4gcGFzc2luZyBhIHN0cmVhbVxuICBzZW5kQm9keUxlbmd0aCkge1xuICAgIGJvZHlMZW5ndGggPSBjb21wdXRlQm9keUxlbmd0aChpbml0LmJvZHkpO1xuICB9XG4gIGlmIChjb21tYW5kT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykge1xuICAgIGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3Moe1xuICAgICAgbG9hZGVkOiAwLFxuICAgICAgdG90YWw6IGJvZHlMZW5ndGgsXG4gICAgICBwZXJjZW50YWdlOiAwXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYXBpUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICBhc3luYyAoYmFpbCkgPT4ge1xuICAgICAgbGV0IHJlcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IGJsb2JSZXF1ZXN0KHtcbiAgICAgICAgICBpbnB1dDogZ2V0QXBpVXJsKHBhdGhuYW1lKSxcbiAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIngtYXBpLWJsb2ItcmVxdWVzdC1pZFwiOiByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIFwieC1hcGktYmxvYi1yZXF1ZXN0LWF0dGVtcHRcIjogU3RyaW5nKHJldHJ5Q291bnQpLFxuICAgICAgICAgICAgICBcIngtYXBpLXZlcnNpb25cIjogYXBpVmVyc2lvbixcbiAgICAgICAgICAgICAgLi4uc2VuZEJvZHlMZW5ndGggPyB7IFwieC1jb250ZW50LWxlbmd0aFwiOiBTdHJpbmcoYm9keUxlbmd0aCkgfSA6IHt9LFxuICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICAgLi4uZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAuLi5pbml0LmhlYWRlcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IChjb21tYW5kT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykgPyAobG9hZGVkKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSBib2R5TGVuZ3RoICE9PSAwID8gYm9keUxlbmd0aCA6IGxvYWRlZDtcbiAgICAgICAgICAgIHRvdGFsTG9hZGVkID0gbG9hZGVkO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGJvZHlMZW5ndGggPiAwID8gTnVtYmVyKChsb2FkZWQgLyB0b3RhbCAqIDEwMCkudG9GaXhlZCgyKSkgOiAwO1xuICAgICAgICAgICAgaWYgKHBlcmNlbnRhZ2UgPT09IDEwMCAmJiBib2R5TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2EzID0gY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKGNvbW1hbmRPcHRpb25zLCB7XG4gICAgICAgICAgICAgIGxvYWRlZCxcbiAgICAgICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGEgc3RyZWFtIHRvIHB1dCgpLCB3ZSBoYXZlIG5vIHdheSB0byBrbm93IHRoZSB0b3RhbCBzaXplIG9mIHRoZSBib2R5LlxuICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGRlZmluaW5nIHRvdGFsIGFzIHRvdGFsPzogbnVtYmVyIHdlIGRlY2lkZWQgdG8gc2V0IHRoZSB0b3RhbCB0byB0aGUgY3VycmVudGx5XG4gICAgICAgICAgICAgIC8vIGxvYWRlZCBudW1iZXIuIFRoaXMgaXMgbm90IGluYWNjdXJhdGUgYW5kIHdheSBtb3JlIHByYWN0aWNhbCBmb3IgRFguXG4gICAgICAgICAgICAgIC8vIFBhc3NpbmcgZG93biBhIHN0cmVhbSB0byBwdXQoKSBpcyB2ZXJ5IHJhcmVcbiAgICAgICAgICAgICAgdG90YWwsXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbjIgJiYgZXJyb3IyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgYmFpbChuZXcgQmxvYlJlcXVlc3RBYm9ydGVkRXJyb3IoKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldHdvcmtFcnJvcihlcnJvcjIpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICBiYWlsKGVycm9yMik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29kZSwgZXJyb3IgfSA9IGF3YWl0IGdldEJsb2JFcnJvcihyZXMpO1xuICAgICAgaWYgKGNvZGUgPT09IFwidW5rbm93bl9lcnJvclwiIHx8IGNvZGUgPT09IFwic2VydmljZV91bmF2YWlsYWJsZVwiIHx8IGNvZGUgPT09IFwiaW50ZXJuYWxfc2VydmVyX2Vycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBiYWlsKGVycm9yKTtcbiAgICB9LFxuICAgIHtcbiAgICAgIHJldHJpZXM6IGdldFJldHJpZXMoKSxcbiAgICAgIG9uUmV0cnk6IChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGRlYnVnKGByZXRyeWluZyBBUEkgcmVxdWVzdCB0byAke3BhdGhuYW1lfWAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHJ5Q291bnQgPSByZXRyeUNvdW50ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGlmICghYXBpUmVzcG9uc2UpIHtcbiAgICB0aHJvdyBuZXcgQmxvYlVua25vd25FcnJvcigpO1xuICB9XG4gIGlmIChjb21tYW5kT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykge1xuICAgIGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3Moe1xuICAgICAgbG9hZGVkOiB0b3RhbExvYWRlZCxcbiAgICAgIHRvdGFsOiB0b3RhbExvYWRlZCxcbiAgICAgIHBlcmNlbnRhZ2U6IDEwMFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhd2FpdCBhcGlSZXNwb25zZS5qc29uKCk7XG59XG5mdW5jdGlvbiBnZXRQcm94eVRocm91Z2hBbHRlcm5hdGl2ZUFwaUhlYWRlckZyb21FbnYoKSB7XG4gIGNvbnN0IGV4dHJhSGVhZGVycyA9IHt9O1xuICB0cnkge1xuICAgIGlmIChcIlZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJXCIgaW4gcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfUFJPWFlfVEhST1VHSF9BTFRFUk5BVElWRV9BUEkgIT09IHZvaWQgMCkge1xuICAgICAgZXh0cmFIZWFkZXJzW1wieC1wcm94eS10aHJvdWdoLWFsdGVybmF0aXZlLWFwaVwiXSA9IHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJO1xuICAgIH0gZWxzZSBpZiAoXCJORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSVwiIGluIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJICE9PSB2b2lkIDApIHtcbiAgICAgIGV4dHJhSGVhZGVyc1tcIngtcHJveHktdGhyb3VnaC1hbHRlcm5hdGl2ZS1hcGlcIl0gPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBleHRyYUhlYWRlcnM7XG59XG5mdW5jdGlvbiBzaG91bGRVc2VYQ29udGVudExlbmd0aCgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfVVNFX1hfQ09OVEVOVF9MRU5HVEggPT09IFwiMVwiO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gc3JjL3B1dC1oZWxwZXJzLnRzXG52YXIgcHV0T3B0aW9uSGVhZGVyTWFwID0ge1xuICBjYWNoZUNvbnRyb2xNYXhBZ2U6IFwieC1jYWNoZS1jb250cm9sLW1heC1hZ2VcIixcbiAgYWRkUmFuZG9tU3VmZml4OiBcIngtYWRkLXJhbmRvbS1zdWZmaXhcIixcbiAgYWxsb3dPdmVyd3JpdGU6IFwieC1hbGxvdy1vdmVyd3JpdGVcIixcbiAgY29udGVudFR5cGU6IFwieC1jb250ZW50LXR5cGVcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJjb250ZW50VHlwZVwiKSAmJiBvcHRpb25zLmNvbnRlbnRUeXBlKSB7XG4gICAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuY29udGVudFR5cGVdID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgfVxuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJhZGRSYW5kb21TdWZmaXhcIikgJiYgb3B0aW9ucy5hZGRSYW5kb21TdWZmaXggIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmFkZFJhbmRvbVN1ZmZpeF0gPSBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCA/IFwiMVwiIDogXCIwXCI7XG4gIH1cbiAgaWYgKGFsbG93ZWRPcHRpb25zLmluY2x1ZGVzKFwiYWxsb3dPdmVyd3JpdGVcIikgJiYgb3B0aW9ucy5hbGxvd092ZXJ3cml0ZSAhPT0gdm9pZCAwKSB7XG4gICAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuYWxsb3dPdmVyd3JpdGVdID0gb3B0aW9ucy5hbGxvd092ZXJ3cml0ZSA/IFwiMVwiIDogXCIwXCI7XG4gIH1cbiAgaWYgKGFsbG93ZWRPcHRpb25zLmluY2x1ZGVzKFwiY2FjaGVDb250cm9sTWF4QWdlXCIpICYmIG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5jYWNoZUNvbnRyb2xNYXhBZ2VdID0gb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVB1dE9wdGlvbnMoe1xuICBwYXRobmFtZSxcbiAgb3B0aW9ucyxcbiAgZXh0cmFDaGVja3MsXG4gIGdldFRva2VuXG59KSB7XG4gIGlmICghcGF0aG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwicGF0aG5hbWUgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgaWYgKHBhdGhuYW1lLmxlbmd0aCA+IE1BWElNVU1fUEFUSE5BTUVfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgIGBwYXRobmFtZSBpcyB0b28gbG9uZywgbWF4aW11bSBsZW5ndGggaXMgJHtNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSH1gXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IGludmFsaWRDaGFyYWN0ZXIgb2YgZGlzYWxsb3dlZFBhdGhuYW1lQ2hhcmFjdGVycykge1xuICAgIGlmIChwYXRobmFtZS5pbmNsdWRlcyhpbnZhbGlkQ2hhcmFjdGVyKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgYHBhdGhuYW1lIGNhbm5vdCBjb250YWluIFwiJHtpbnZhbGlkQ2hhcmFjdGVyfVwiLCBwbGVhc2UgZW5jb2RlIGl0IGlmIG5lZWRlZGBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJtaXNzaW5nIG9wdGlvbnMsIHNlZSB1c2FnZVwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5hY2Nlc3MgIT09IFwicHVibGljXCIpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKCdhY2Nlc3MgbXVzdCBiZSBcInB1YmxpY1wiJyk7XG4gIH1cbiAgaWYgKGV4dHJhQ2hlY2tzKSB7XG4gICAgZXh0cmFDaGVja3Mob3B0aW9ucyk7XG4gIH1cbiAgaWYgKGdldFRva2VuKSB7XG4gICAgb3B0aW9ucy50b2tlbiA9IGF3YWl0IGdldFRva2VuKHBhdGhuYW1lLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLy8gc3JjL211bHRpcGFydC9jb21wbGV0ZS50c1xuZnVuY3Rpb24gY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgcGFydHMsIG9wdGlvbnNJbnB1dCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICAgICAgdXBsb2FkSWQ6IG9wdGlvbnMudXBsb2FkSWQsXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHBhcnRzXG4gICAgfSk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gIHVwbG9hZElkLFxuICBrZXksXG4gIHBhdGhuYW1lLFxuICBwYXJ0cyxcbiAgaGVhZGVycyxcbiAgb3B0aW9uc1xufSkge1xuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgcGF0aG5hbWUgfSk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgICAgYC9tcHU/JHtwYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICBcIngtbXB1LWFjdGlvblwiOiBcImNvbXBsZXRlXCIsXG4gICAgICAgICAgXCJ4LW1wdS11cGxvYWQtaWRcIjogdXBsb2FkSWQsXG4gICAgICAgICAgLy8ga2V5IGNhbiBiZSBhbnkgdXRmOCBjaGFyYWN0ZXIgc28gd2UgbmVlZCB0byBlbmNvZGUgaXQgYXMgSFRUUCBoZWFkZXJzIGNhbiBvbmx5IGJlIHVzLWFzY2lpXG4gICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzAjc3dlY3Rpb24tMy4yLjRcbiAgICAgICAgICBcIngtbXB1LWtleVwiOiBlbmNvZGVVUklDb21wb25lbnQoa2V5KVxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJ0cyksXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGRlYnVnKFwibXB1OiBjb21wbGV0ZVwiLCByZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyb3IubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L2NyZWF0ZS50c1xuZnVuY3Rpb24gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kKHsgYWxsb3dlZE9wdGlvbnMsIGdldFRva2VuLCBleHRyYUNoZWNrcyB9KSB7XG4gIHJldHVybiBhc3luYyAocGF0aG5hbWUsIG9wdGlvbnNJbnB1dCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZU11bHRpcGFydFVwbG9hZChcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZFxuICAgIH07XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVNdWx0aXBhcnRVcGxvYWQocGF0aG5hbWUsIGhlYWRlcnMsIG9wdGlvbnMpIHtcbiAgZGVidWcoXCJtcHU6IGNyZWF0ZVwiLCBcInBhdGhuYW1lOlwiLCBwYXRobmFtZSk7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBwYXRobmFtZSB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgICBgL21wdT8ke3BhcmFtcy50b1N0cmluZygpfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgIFwieC1tcHUtYWN0aW9uXCI6IFwiY3JlYXRlXCJcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgZGVidWcoXCJtcHU6IGNyZWF0ZVwiLCByZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyb3IubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIHNyYy9tdWx0aXBhcnQvdXBsb2FkLnRzXG5pbXBvcnQgdGhyb3R0bGUgZnJvbSBcInRocm90dGxlaXRcIjtcbmZ1bmN0aW9uIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgYm9keSwgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBcIkJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbS4gWW91IHNlbnQgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCwgZG91YmxlIGNoZWNrIHdoYXQgeW91J3JlIHRyeWluZyB0byB1cGxvYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwbG9hZFBhcnQoe1xuICAgICAgdXBsb2FkSWQ6IG9wdGlvbnMudXBsb2FkSWQsXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBwYXJ0OiB7IGJsb2I6IGJvZHksIHBhcnROdW1iZXI6IG9wdGlvbnMucGFydE51bWJlciB9LFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZXRhZzogcmVzdWx0LmV0YWcsXG4gICAgICBwYXJ0TnVtYmVyOiBvcHRpb25zLnBhcnROdW1iZXJcbiAgICB9O1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkUGFydCh7XG4gIHVwbG9hZElkLFxuICBrZXksXG4gIHBhdGhuYW1lLFxuICBoZWFkZXJzLFxuICBvcHRpb25zLFxuICBpbnRlcm5hbEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSxcbiAgcGFydFxufSkge1xuICB2YXIgX2EzLCBfYjIsIF9jO1xuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgcGF0aG5hbWUgfSk7XG4gIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHJlcXVlc3RBcGkoXG4gICAgYC9tcHU/JHtwYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgIHtcbiAgICAgIHNpZ25hbDogaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgXCJ4LW1wdS1hY3Rpb25cIjogXCJ1cGxvYWRcIixcbiAgICAgICAgXCJ4LW1wdS1rZXlcIjogZW5jb2RlVVJJQ29tcG9uZW50KGtleSksXG4gICAgICAgIFwieC1tcHUtdXBsb2FkLWlkXCI6IHVwbG9hZElkLFxuICAgICAgICBcIngtbXB1LXBhcnQtbnVtYmVyXCI6IHBhcnQucGFydE51bWJlci50b1N0cmluZygpXG4gICAgICB9LFxuICAgICAgLy8gd2VpcmQgdGhpbmdzIGJldHdlZW4gdW5kaWNpIHR5cGVzIGFuZCBuYXRpdmUgZmV0Y2ggdHlwZXNcbiAgICAgIGJvZHk6IHBhcnQuYmxvYlxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApO1xuICBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICBpbnRlcm5hbEFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG4gIGlmICgoX2EzID0gb3B0aW9ucy5hYm9ydFNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5hYm9ydGVkKSB7XG4gICAgaGFuZGxlQWJvcnQoKTtcbiAgfSBlbHNlIHtcbiAgICAoX2IyID0gb3B0aW9ucy5hYm9ydFNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgaGFuZGxlQWJvcnQpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2VQcm9taXNlO1xuICAoX2MgPSBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGhhbmRsZUFib3J0KTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxudmFyIG1heENvbmN1cnJlbnRVcGxvYWRzID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IDYgOiA4O1xudmFyIHBhcnRTaXplSW5CeXRlcyA9IDggKiAxMDI0ICogMTAyNDtcbnZhciBtYXhCeXRlc0luTWVtb3J5ID0gbWF4Q29uY3VycmVudFVwbG9hZHMgKiBwYXJ0U2l6ZUluQnl0ZXMgKiAyO1xuZnVuY3Rpb24gdXBsb2FkQWxsUGFydHMoe1xuICB1cGxvYWRJZCxcbiAga2V5LFxuICBwYXRobmFtZSxcbiAgc3RyZWFtLFxuICBoZWFkZXJzLFxuICBvcHRpb25zLFxuICB0b3RhbFRvTG9hZFxufSkge1xuICBkZWJ1ZyhcIm1wdTogdXBsb2FkIGluaXRcIiwgXCJrZXk6XCIsIGtleSk7XG4gIGNvbnN0IGludGVybmFsQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHBhcnRzVG9VcGxvYWQgPSBbXTtcbiAgICBjb25zdCBjb21wbGV0ZWRQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgYWN0aXZlVXBsb2FkcyA9IDA7XG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgY3VycmVudFBhcnROdW1iZXIgPSAxO1xuICAgIGxldCByZWplY3RlZCA9IGZhbHNlO1xuICAgIGxldCBjdXJyZW50Qnl0ZXNJbk1lbW9yeSA9IDA7XG4gICAgbGV0IGRvbmVSZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IGJ5dGVzU2VudCA9IDA7XG4gICAgbGV0IGFycmF5QnVmZmVycyA9IFtdO1xuICAgIGxldCBjdXJyZW50UGFydEJ5dGVzUmVhZCA9IDA7XG4gICAgbGV0IG9uVXBsb2FkUHJvZ3Jlc3M7XG4gICAgY29uc3QgdG90YWxMb2FkZWRQZXJQYXJ0TnVtYmVyID0ge307XG4gICAgaWYgKG9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykge1xuICAgICAgb25VcGxvYWRQcm9ncmVzcyA9IHRocm90dGxlKCgpID0+IHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgY29uc3QgbG9hZGVkID0gT2JqZWN0LnZhbHVlcyh0b3RhbExvYWRlZFBlclBhcnROdW1iZXIpLnJlZHVjZShcbiAgICAgICAgICAoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhY2MgKyBjdXI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gdG90YWxUb0xvYWQgfHwgbG9hZGVkO1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gdG90YWxUb0xvYWQgPiAwID8gTnVtYmVyKCgobG9hZGVkIC8gdG90YWxUb0xvYWQgfHwgbG9hZGVkKSAqIDEwMCkudG9GaXhlZCgyKSkgOiAwO1xuICAgICAgICAoX2EzID0gb3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwob3B0aW9ucywgeyBsb2FkZWQsIHRvdGFsLCBwZXJjZW50YWdlIH0pO1xuICAgICAgfSwgMTUwKTtcbiAgICB9XG4gICAgcmVhZCgpLmNhdGNoKGNhbmNlbCk7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgIGRlYnVnKFxuICAgICAgICBcIm1wdTogdXBsb2FkIHJlYWQgc3RhcnRcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzOlwiLFxuICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICBcImN1cnJlbnRCeXRlc0luTWVtb3J5OlwiLFxuICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgIGJ5dGVzKGJ5dGVzU2VudClcbiAgICAgICk7XG4gICAgICByZWFkaW5nID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChjdXJyZW50Qnl0ZXNJbk1lbW9yeSA8IG1heEJ5dGVzSW5NZW1vcnkgJiYgIXJlamVjdGVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgZG9uZVJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgZGVidWcoXCJtcHU6IHVwbG9hZCByZWFkIGNvbnN1bWVkIHRoZSB3aG9sZSBzdHJlYW1cIik7XG4gICAgICAgICAgICBpZiAoYXJyYXlCdWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcGFydHNUb1VwbG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBjdXJyZW50UGFydE51bWJlcisrLFxuICAgICAgICAgICAgICAgIGJsb2I6IG5ldyBCbG9iKGFycmF5QnVmZmVycywge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZW5kUGFydHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudEJ5dGVzSW5NZW1vcnkgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBsZXQgdmFsdWVPZmZzZXQgPSAwO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZU9mZnNldCA8IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1BhcnRTaXplID0gcGFydFNpemVJbkJ5dGVzIC0gY3VycmVudFBhcnRCeXRlc1JlYWQ7XG4gICAgICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgdmFsdWVPZmZzZXQgKyByZW1haW5pbmdQYXJ0U2l6ZSxcbiAgICAgICAgICAgICAgdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdmFsdWUuc2xpY2UodmFsdWVPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICBhcnJheUJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICBjdXJyZW50UGFydEJ5dGVzUmVhZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVPZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcnRCeXRlc1JlYWQgPT09IHBhcnRTaXplSW5CeXRlcykge1xuICAgICAgICAgICAgICBwYXJ0c1RvVXBsb2FkLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhcnROdW1iZXI6IGN1cnJlbnRQYXJ0TnVtYmVyKyssXG4gICAgICAgICAgICAgICAgYmxvYjogbmV3IEJsb2IoYXJyYXlCdWZmZXJzLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFycmF5QnVmZmVycyA9IFtdO1xuICAgICAgICAgICAgICBjdXJyZW50UGFydEJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICAgIHNlbmRQYXJ0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYW5jZWwoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJtcHU6IHVwbG9hZCByZWFkIGVuZFwiLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2VuZFBhcnQocGFydCkge1xuICAgICAgYWN0aXZlVXBsb2FkcysrO1xuICAgICAgZGVidWcoXG4gICAgICAgIFwibXB1OiB1cGxvYWQgc2VuZCBwYXJ0IHN0YXJ0XCIsXG4gICAgICAgIFwicGFydE51bWJlcjpcIixcbiAgICAgICAgcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICBcInNpemU6XCIsXG4gICAgICAgIHBhcnQuYmxvYi5zaXplLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVwbG9hZFByb2dyZXNzRm9yUGFydCA9IG9wdGlvbnMub25VcGxvYWRQcm9ncmVzcyA/IChldmVudCkgPT4ge1xuICAgICAgICAgIHRvdGFsTG9hZGVkUGVyUGFydE51bWJlcltwYXJ0LnBhcnROdW1iZXJdID0gZXZlbnQubG9hZGVkO1xuICAgICAgICAgIGlmIChvblVwbG9hZFByb2dyZXNzKSB7XG4gICAgICAgICAgICBvblVwbG9hZFByb2dyZXNzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IDogdm9pZCAwO1xuICAgICAgICBjb25zdCBjb21wbGV0ZWRQYXJ0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICAgICAgdXBsb2FkSWQsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IHVwbG9hZFByb2dyZXNzRm9yUGFydFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIsXG4gICAgICAgICAgcGFydFxuICAgICAgICB9KTtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgXCJtcHU6IHVwbG9hZCBzZW5kIHBhcnQgZW5kXCIsXG4gICAgICAgICAgXCJwYXJ0TnVtYmVyOlwiLFxuICAgICAgICAgIHBhcnQucGFydE51bWJlcixcbiAgICAgICAgICBcImFjdGl2ZVVwbG9hZHNcIixcbiAgICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgICAgYCR7Ynl0ZXMoY3VycmVudEJ5dGVzSW5NZW1vcnkpfS8ke2J5dGVzKG1heEJ5dGVzSW5NZW1vcnkpfWAsXG4gICAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgICApO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29tcGxldGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgcGFydE51bWJlcjogcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICAgIGV0YWc6IGNvbXBsZXRlZFBhcnQuZXRhZ1xuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudEJ5dGVzSW5NZW1vcnkgLT0gcGFydC5ibG9iLnNpemU7XG4gICAgICAgIGFjdGl2ZVVwbG9hZHMtLTtcbiAgICAgICAgYnl0ZXNTZW50ICs9IHBhcnQuYmxvYi5zaXplO1xuICAgICAgICBpZiAocGFydHNUb1VwbG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2VuZFBhcnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbmVSZWFkaW5nKSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZVVwbG9hZHMgPT09IDApIHtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgcmVzb2x2ZShjb21wbGV0ZWRQYXJ0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlYWRpbmcpIHtcbiAgICAgICAgICByZWFkKCkuY2F0Y2goY2FuY2VsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FuY2VsKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2VuZFBhcnRzKCkge1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlYnVnKFxuICAgICAgICBcInNlbmQgcGFydHNcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzXCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwicGFydHNUb1VwbG9hZFwiLFxuICAgICAgICBwYXJ0c1RvVXBsb2FkLmxlbmd0aFxuICAgICAgKTtcbiAgICAgIHdoaWxlIChhY3RpdmVVcGxvYWRzIDwgbWF4Q29uY3VycmVudFVwbG9hZHMgJiYgcGFydHNUb1VwbG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcnRUb1NlbmQgPSBwYXJ0c1RvVXBsb2FkLnNoaWZ0KCk7XG4gICAgICAgIGlmIChwYXJ0VG9TZW5kKSB7XG4gICAgICAgICAgdm9pZCBzZW5kUGFydChwYXJ0VG9TZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoZXJyb3IpIHtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICBpbnRlcm5hbEFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgKGVycm9yLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL211bHRpcGFydC9jcmVhdGUtdXBsb2FkZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZGVyTWV0aG9kKHsgYWxsb3dlZE9wdGlvbnMsIGdldFRva2VuLCBleHRyYUNoZWNrcyB9KSB7XG4gIHJldHVybiBhc3luYyAocGF0aG5hbWUsIG9wdGlvbnNJbnB1dCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZU11bHRpcGFydFVwbG9hZChcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICAgIGFzeW5jIHVwbG9hZFBhcnQocGFydE51bWJlciwgYm9keSkge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChib2R5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgICAgICBcIkJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbS4gWW91IHNlbnQgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCwgZG91YmxlIGNoZWNrIHdoYXQgeW91J3JlIHRyeWluZyB0byB1cGxvYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwbG9hZFBhcnQoe1xuICAgICAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICAgICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBwYXJ0OiB7IHBhcnROdW1iZXIsIGJsb2I6IGJvZHkgfSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXRhZzogcmVzdWx0LmV0YWcsXG4gICAgICAgICAgcGFydE51bWJlclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGNvbXBsZXRlKHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gICAgICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgICAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuXG4vLyBzcmMvcHV0LnRzXG5pbXBvcnQgdGhyb3R0bGUyIGZyb20gXCJ0aHJvdHRsZWl0XCI7XG5cbi8vIHNyYy9tdWx0aXBhcnQvdW5jb250cm9sbGVkLnRzXG5hc3luYyBmdW5jdGlvbiB1bmNvbnRyb2xsZWRNdWx0aXBhcnRVcGxvYWQocGF0aG5hbWUsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpIHtcbiAgZGVidWcoXCJtcHU6IGluaXRcIiwgXCJwYXRobmFtZTpcIiwgcGF0aG5hbWUsIFwiaGVhZGVyczpcIiwgaGVhZGVycyk7XG4gIGNvbnN0IG9wdGlvbnNXaXRob3V0T25VcGxvYWRQcm9ncmVzcyA9IHtcbiAgICAuLi5vcHRpb25zLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IHZvaWQgMFxuICB9O1xuICBjb25zdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZU11bHRpcGFydFVwbG9hZChcbiAgICBwYXRobmFtZSxcbiAgICBoZWFkZXJzLFxuICAgIG9wdGlvbnNXaXRob3V0T25VcGxvYWRQcm9ncmVzc1xuICApO1xuICBjb25zdCB0b3RhbFRvTG9hZCA9IGNvbXB1dGVCb2R5TGVuZ3RoKGJvZHkpO1xuICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0b1JlYWRhYmxlU3RyZWFtKGJvZHkpO1xuICBjb25zdCBwYXJ0cyA9IGF3YWl0IHVwbG9hZEFsbFBhcnRzKHtcbiAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWQsXG4gICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgcGF0aG5hbWUsXG4gICAgc3RyZWFtLFxuICAgIGhlYWRlcnMsXG4gICAgb3B0aW9ucyxcbiAgICB0b3RhbFRvTG9hZFxuICB9KTtcbiAgY29uc3QgYmxvYiA9IGF3YWl0IGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKHtcbiAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWQsXG4gICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgcGF0aG5hbWUsXG4gICAgcGFydHMsXG4gICAgaGVhZGVycyxcbiAgICBvcHRpb25zOiBvcHRpb25zV2l0aG91dE9uVXBsb2FkUHJvZ3Jlc3NcbiAgfSk7XG4gIHJldHVybiBibG9iO1xufVxuXG4vLyBzcmMvcHV0LnRzXG5mdW5jdGlvbiBjcmVhdGVQdXRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9ucyxcbiAgZ2V0VG9rZW4sXG4gIGV4dHJhQ2hlY2tzXG59KSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBwdXQocGF0aG5hbWUsIGJvZHksIG9wdGlvbnNJbnB1dCkge1xuICAgIGlmICghYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcImJvZHkgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBcIkJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbS4gWW91IHNlbnQgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCwgZG91YmxlIGNoZWNrIHdoYXQgeW91J3JlIHRyeWluZyB0byB1cGxvYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5tdWx0aXBhcnQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB1bmNvbnRyb2xsZWRNdWx0aXBhcnRVcGxvYWQocGF0aG5hbWUsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBvblVwbG9hZFByb2dyZXNzID0gb3B0aW9ucy5vblVwbG9hZFByb2dyZXNzID8gdGhyb3R0bGUyKG9wdGlvbnMub25VcGxvYWRQcm9ncmVzcywgMTAwKSA6IHZvaWQgMDtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgcGF0aG5hbWUgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgICAgYC8/JHtwYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgb25VcGxvYWRQcm9ncmVzc1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgZG93bmxvYWRVcmw6IHJlc3BvbnNlLmRvd25sb2FkVXJsLFxuICAgICAgcGF0aG5hbWU6IHJlc3BvbnNlLnBhdGhuYW1lLFxuICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uOiByZXNwb25zZS5jb250ZW50RGlzcG9zaXRpb25cbiAgICB9O1xuICB9O1xufVxuXG4vLyBzcmMvY3JlYXRlLWZvbGRlci50c1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRm9sZGVyKHBhdGhuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZm9sZGVyUGF0aG5hbWUgPSBwYXRobmFtZS5lbmRzV2l0aChcIi9cIikgPyBwYXRobmFtZSA6IGAke3BhdGhuYW1lfS9gO1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmFkZFJhbmRvbVN1ZmZpeF0gPSBcIjBcIjtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHBhdGhuYW1lOiBmb2xkZXJQYXRobmFtZSB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgIGAvPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCxcbiAgICB7XG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIHJldHVybiB7XG4gICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgcGF0aG5hbWU6IHJlc3BvbnNlLnBhdGhuYW1lXG4gIH07XG59XG5cbmV4cG9ydCB7XG4gIGdldFRva2VuRnJvbU9wdGlvbnNPckVudixcbiAgQmxvYkVycm9yLFxuICBnZXREb3dubG9hZFVybCxcbiAgZGlzYWxsb3dlZFBhdGhuYW1lQ2hhcmFjdGVycyxcbiAgTUFYSU1VTV9QQVRITkFNRV9MRU5HVEgsXG4gIEJsb2JBY2Nlc3NFcnJvcixcbiAgQmxvYkNvbnRlbnRUeXBlTm90QWxsb3dlZEVycm9yLFxuICBCbG9iUGF0aG5hbWVNaXNtYXRjaEVycm9yLFxuICBCbG9iQ2xpZW50VG9rZW5FeHBpcmVkRXJyb3IsXG4gIEJsb2JGaWxlVG9vTGFyZ2VFcnJvcixcbiAgQmxvYlN0b3JlTm90Rm91bmRFcnJvcixcbiAgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IsXG4gIEJsb2JVbmtub3duRXJyb3IsXG4gIEJsb2JOb3RGb3VuZEVycm9yLFxuICBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSxcbiAgQmxvYlNlcnZpY2VSYXRlTGltaXRlZCxcbiAgQmxvYlJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gIHJlcXVlc3RBcGksXG4gIGNyZWF0ZUNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kLFxuICBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZGVyTWV0aG9kLFxuICBjcmVhdGVQdXRNZXRob2QsXG4gIGNyZWF0ZUZvbGRlclxufTtcbi8qIVxuICogYnl0ZXNcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgVEogSG9sb3dheWNodWtcbiAqIENvcHlyaWdodChjKSAyMDE1IEplZCBXYXRzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1GTjZYRkg2Ui5qcy5tYXAiXSwibmFtZXMiOlsiaXNOb2RlUHJvY2VzcyIsImlzQnVmZmVyIiwiUmVhZGFibGUiLCJzdXBwb3J0c05ld0Jsb2JGcm9tQXJyYXlCdWZmZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsImhlbGxvQXNBcnJheUJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJibG9iIiwiQmxvYiIsInRleHQiLCJ0aGVuIiwiY2F0Y2giLCJ0b1JlYWRhYmxlU3RyZWFtIiwidmFsdWUiLCJSZWFkYWJsZVN0cmVhbSIsInN0cmVhbSIsImlzTm9kZUpzUmVhZGFibGVTdHJlYW0iLCJ0b1dlYiIsInN0cmVhbVZhbHVlIiwiQXJyYXlCdWZmZXIiLCJpc05vZGVKc0J1ZmZlciIsInN0cmluZ1RvVWludDhBcnJheSIsInN0YXJ0IiwiY29udHJvbGxlciIsImVucXVldWUiLCJjbG9zZSIsInBpcGUiLCJyZWFkYWJsZSIsIl9yZWFkIiwiX3JlYWRhYmxlU3RhdGUiLCJzIiwiZW5jIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJwYXJzZVJlZ0V4cCIsIm1hcCIsImIiLCJrYiIsIm1iIiwiZ2IiLCJ0YiIsInBiIiwiYnl0ZXMiLCJ2YWwiLCJOdW1iZXIiLCJpc05hTiIsInJlc3VsdHMiLCJleGVjIiwiZmxvYXRWYWx1ZSIsInVuaXQiLCJwYXJzZUludCIsInJlcyIsInVuaXRNYXRjaCIsInBhcnNlRmxvYXQiLCJ0b0xvd2VyQ2FzZSIsIk1hdGgiLCJmbG9vciIsImRlZmF1bHRWZXJjZWxCbG9iQXBpVXJsIiwiZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52Iiwib3B0aW9ucyIsInRva2VuIiwicHJvY2VzcyIsImVudiIsIkJMT0JfUkVBRF9XUklURV9UT0tFTiIsIkJsb2JFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiZ2V0RG93bmxvYWRVcmwiLCJibG9iVXJsIiwidXJsIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwidG9TdHJpbmciLCJpc1BsYWluT2JqZWN0IiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIml0ZXJhdG9yIiwiZGlzYWxsb3dlZFBhdGhuYW1lQ2hhcmFjdGVycyIsInN1cHBvcnRzUmVxdWVzdFN0cmVhbXMiLCJhcGlVcmwiLCJnZXRBcGlVcmwiLCJzdGFydHNXaXRoIiwiZHVwbGV4QWNjZXNzZWQiLCJoYXNDb250ZW50VHlwZSIsIlJlcXVlc3QiLCJib2R5IiwibWV0aG9kIiwiZHVwbGV4IiwiaGVhZGVycyIsImhhcyIsInBhdGhuYW1lIiwiYmFzZVVybCIsIlZFUkNFTF9CTE9CX0FQSV9VUkwiLCJORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVVJMIiwiVEVYVF9FTkNPREVSIiwiY29tcHV0ZUJvZHlMZW5ndGgiLCJieXRlTGVuZ3RoIiwic2l6ZSIsImNyZWF0ZUNodW5rVHJhbnNmb3JtU3RyZWFtIiwiY2h1bmtTaXplIiwib25Qcm9ncmVzcyIsImJ1ZmZlciIsIlRyYW5zZm9ybVN0cmVhbSIsInRyYW5zZm9ybSIsImNodW5rIiwicXVldWVNaWNyb3Rhc2siLCJuZXdCdWZmZXIiLCJsZW5ndGgiLCJuZXdDaHVuayIsInNsaWNlIiwiZmx1c2giLCJpc1JlYWRhYmxlU3RyZWFtIiwiZ2xvYmFsVGhpcyIsImlzU3RyZWFtIiwicmV0cnkiLCJkZWJ1Z0lzQWN0aXZlIiwiX2EiLCJfYiIsIkRFQlVHIiwiaW5jbHVkZXMiLCJORVhUX1BVQkxJQ19ERUJVRyIsImRlYnVnIiwiYXJncyIsImNvbnNvbGUiLCJfYTIiLCJET01FeGNlcHRpb24yIiwiRE9NRXhjZXB0aW9uIiwiYXRvYiIsImVyciIsIm9iamVjdFRvU3RyaW5nIiwiaXNFcnJvciIsImNhbGwiLCJlcnJvck1lc3NhZ2VzIiwiU2V0IiwiaXNOZXR3b3JrRXJyb3IiLCJlcnJvciIsImlzVmFsaWQiLCJuYW1lIiwic3RhY2siLCJmZXRjaCIsImhhc0ZldGNoIiwiaGFzRmV0Y2hXaXRoVXBsb2FkUHJvZ3Jlc3MiLCJDSFVOS19TSVpFIiwiYmxvYkZldGNoIiwiaW5wdXQiLCJpbml0Iiwib25VcGxvYWRQcm9ncmVzcyIsImxvYWRlZCIsImNodW5rVHJhbnNmb3JtU3RyZWFtIiwibmV3TG9hZGVkIiwicGlwZVRocm91Z2giLCJoYXNYaHIiLCJYTUxIdHRwUmVxdWVzdCIsImJsb2JYaHIiLCJSZXNwb25zZSIsInJlamVjdCIsInhociIsIm9wZW4iLCJ1cGxvYWQiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJsZW5ndGhDb21wdXRhYmxlIiwib25sb2FkIiwiX2EzIiwic2lnbmFsIiwiYWJvcnRlZCIsIkhlYWRlcnMiLCJyYXdIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwidHJpbSIsInNwbGl0IiwiZm9yRWFjaCIsImxpbmUiLCJwYXJ0cyIsImtleSIsInNoaWZ0Iiwiam9pbiIsInJlc3BvbnNlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIm9uZXJyb3IiLCJUeXBlRXJyb3IiLCJvbnRpbWVvdXQiLCJvbmFib3J0Iiwic2V0UmVxdWVzdEhlYWRlciIsImFib3J0Iiwic2VuZCIsImJsb2JSZXF1ZXN0IiwiTUFYSU1VTV9QQVRITkFNRV9MRU5HVEgiLCJCbG9iQWNjZXNzRXJyb3IiLCJCbG9iQ29udGVudFR5cGVOb3RBbGxvd2VkRXJyb3IiLCJCbG9iUGF0aG5hbWVNaXNtYXRjaEVycm9yIiwiQmxvYkNsaWVudFRva2VuRXhwaXJlZEVycm9yIiwiQmxvYkZpbGVUb29MYXJnZUVycm9yIiwiQmxvYlN0b3JlTm90Rm91bmRFcnJvciIsIkJsb2JTdG9yZVN1c3BlbmRlZEVycm9yIiwiQmxvYlVua25vd25FcnJvciIsIkJsb2JOb3RGb3VuZEVycm9yIiwiQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUiLCJCbG9iU2VydmljZVJhdGVMaW1pdGVkIiwic2Vjb25kcyIsInJldHJ5QWZ0ZXIiLCJCbG9iUmVxdWVzdEFib3J0ZWRFcnJvciIsIkJMT0JfQVBJX1ZFUlNJT04iLCJnZXRBcGlWZXJzaW9uIiwidmVyc2lvbk92ZXJyaWRlIiwiVkVSQ0VMX0JMT0JfQVBJX1ZFUlNJT05fT1ZFUlJJREUiLCJORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVkVSU0lPTl9PVkVSUklERSIsImdldFJldHJpZXMiLCJyZXRyaWVzIiwiVkVSQ0VMX0JMT0JfUkVUUklFUyIsImNyZWF0ZUJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQiLCJnZXQiLCJnZXRCbG9iRXJyb3IiLCJfYjIiLCJfYyIsImNvZGUiLCJkYXRhIiwianNvbiIsInJlcXVlc3RBcGkiLCJjb21tYW5kT3B0aW9ucyIsImFwaVZlcnNpb24iLCJleHRyYUhlYWRlcnMiLCJnZXRQcm94eVRocm91Z2hBbHRlcm5hdGl2ZUFwaUhlYWRlckZyb21FbnYiLCJzdG9yZUlkIiwicmVxdWVzdElkIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInJldHJ5Q291bnQiLCJib2R5TGVuZ3RoIiwidG90YWxMb2FkZWQiLCJzZW5kQm9keUxlbmd0aCIsInNob3VsZFVzZVhDb250ZW50TGVuZ3RoIiwidG90YWwiLCJwZXJjZW50YWdlIiwiYXBpUmVzcG9uc2UiLCJiYWlsIiwiU3RyaW5nIiwiYXV0aG9yaXphdGlvbiIsInRvRml4ZWQiLCJlcnJvcjIiLCJvayIsIm9uUmV0cnkiLCJWRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSSIsIk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJIiwiVkVSQ0VMX0JMT0JfVVNFX1hfQ09OVEVOVF9MRU5HVEgiLCJwdXRPcHRpb25IZWFkZXJNYXAiLCJjYWNoZUNvbnRyb2xNYXhBZ2UiLCJhZGRSYW5kb21TdWZmaXgiLCJhbGxvd092ZXJ3cml0ZSIsImNvbnRlbnRUeXBlIiwiY3JlYXRlUHV0SGVhZGVycyIsImFsbG93ZWRPcHRpb25zIiwiY3JlYXRlUHV0T3B0aW9ucyIsImV4dHJhQ2hlY2tzIiwiZ2V0VG9rZW4iLCJpbnZhbGlkQ2hhcmFjdGVyIiwiYWNjZXNzIiwiY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QiLCJvcHRpb25zSW5wdXQiLCJjb21wbGV0ZU11bHRpcGFydFVwbG9hZCIsInVwbG9hZElkIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsImFib3J0U2lnbmFsIiwiY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kIiwiY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UiLCJjcmVhdGVNdWx0aXBhcnRVcGxvYWQiLCJ0aHJvdHRsZSIsImNyZWF0ZVVwbG9hZFBhcnRNZXRob2QiLCJyZXN1bHQiLCJ1cGxvYWRQYXJ0IiwicGFydCIsInBhcnROdW1iZXIiLCJldGFnIiwiaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJyZXNwb25zZVByb21pc2UiLCJoYW5kbGVBYm9ydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJtYXhDb25jdXJyZW50VXBsb2FkcyIsInBhcnRTaXplSW5CeXRlcyIsIm1heEJ5dGVzSW5NZW1vcnkiLCJ1cGxvYWRBbGxQYXJ0cyIsInRvdGFsVG9Mb2FkIiwicGFydHNUb1VwbG9hZCIsImNvbXBsZXRlZFBhcnRzIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiYWN0aXZlVXBsb2FkcyIsInJlYWRpbmciLCJjdXJyZW50UGFydE51bWJlciIsInJlamVjdGVkIiwiY3VycmVudEJ5dGVzSW5NZW1vcnkiLCJkb25lUmVhZGluZyIsImJ5dGVzU2VudCIsImFycmF5QnVmZmVycyIsImN1cnJlbnRQYXJ0Qnl0ZXNSZWFkIiwidG90YWxMb2FkZWRQZXJQYXJ0TnVtYmVyIiwidmFsdWVzIiwicmVkdWNlIiwiYWNjIiwiY3VyIiwicmVhZCIsImNhbmNlbCIsImRvbmUiLCJwdXNoIiwidHlwZSIsInNlbmRQYXJ0cyIsInZhbHVlT2Zmc2V0IiwicmVtYWluaW5nUGFydFNpemUiLCJlbmRPZmZzZXQiLCJtaW4iLCJzZW5kUGFydCIsInVwbG9hZFByb2dyZXNzRm9yUGFydCIsImNvbXBsZXRlZFBhcnQiLCJyZWxlYXNlTG9jayIsInBhcnRUb1NlbmQiLCJjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCIsImNvbXBsZXRlIiwidGhyb3R0bGUyIiwidW5jb250cm9sbGVkTXVsdGlwYXJ0VXBsb2FkIiwib3B0aW9uc1dpdGhvdXRPblVwbG9hZFByb2dyZXNzIiwiY3JlYXRlUHV0TWV0aG9kIiwicHV0IiwibXVsdGlwYXJ0IiwiZG93bmxvYWRVcmwiLCJjb250ZW50RGlzcG9zaXRpb24iLCJjcmVhdGVGb2xkZXIiLCJmb2xkZXJQYXRobmFtZSIsImVuZHNXaXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@vercel/blob/dist/client.js":
/*!**************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/client.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   completeMultipartUpload: () => (/* binding */ completeMultipartUpload),\n/* harmony export */   createFolder: () => (/* reexport safe */ _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.createFolder),\n/* harmony export */   createMultipartUpload: () => (/* binding */ createMultipartUpload),\n/* harmony export */   createMultipartUploader: () => (/* binding */ createMultipartUploader),\n/* harmony export */   generateClientTokenFromReadWriteToken: () => (/* binding */ generateClientTokenFromReadWriteToken),\n/* harmony export */   getPayloadFromClientToken: () => (/* binding */ getPayloadFromClientToken),\n/* harmony export */   handleUpload: () => (/* binding */ handleUpload),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   upload: () => (/* binding */ upload),\n/* harmony export */   uploadPart: () => (/* binding */ uploadPart)\n/* harmony export */ });\n/* harmony import */ var _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-FN6XFH6R.js */ \"(rsc)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! undici */ \"(rsc)/./node_modules/@vercel/blob/dist/undici-browser.js\");\n\n// src/client.ts\n\n\nfunction createPutExtraChecks(methodName) {\n    return function extraChecks(options) {\n        if (!options.token.startsWith(\"vercel_blob_client_\")) {\n            throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.BlobError(`${methodName} must be called with a client token`);\n        }\n        if (// @ts-expect-error -- Runtime check for DX.\n        options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n        options.allowOverwrite !== void 0 || // @ts-expect-error -- Runtime check for DX.\n        options.cacheControlMaxAge !== void 0) {\n            throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.BlobError(`${methodName} doesn't allow \\`addRandomSuffix\\`, \\`cacheControlMaxAge\\` or \\`allowOverwrite\\`. Configure these options at the server side when generating client tokens.`);\n        }\n    };\n}\nvar put = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.createPutMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks: createPutExtraChecks(\"client/`put`\")\n});\nvar createMultipartUpload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.createCreateMultipartUploadMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n});\nvar createMultipartUploader = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.createCreateMultipartUploaderMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n});\nvar uploadPart = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.createUploadPartMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks: createPutExtraChecks(\"client/`multipartUpload`\")\n});\nvar completeMultipartUpload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.createCompleteMultipartUploadMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks: createPutExtraChecks(\"client/`completeMultipartUpload`\")\n});\nvar upload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.createPutMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks (options) {\n        if (options.handleUploadUrl === void 0) {\n            throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.BlobError(\"client/`upload` requires the 'handleUploadUrl' parameter\");\n        }\n        if (// @ts-expect-error -- Runtime check for DX.\n        options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n        options.createPutExtraChecks !== void 0 || // @ts-expect-error -- Runtime check for DX.\n        options.cacheControlMaxAge !== void 0) {\n            throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.BlobError(\"client/`upload` doesn't allow `addRandomSuffix`, `cacheControlMaxAge` or `allowOverwrite`. Configure these options at the server side when generating client tokens.\");\n        }\n    },\n    async getToken (pathname, options) {\n        var _a, _b;\n        return retrieveClientToken({\n            handleUploadUrl: options.handleUploadUrl,\n            pathname,\n            clientPayload: (_a = options.clientPayload) != null ? _a : null,\n            multipart: (_b = options.multipart) != null ? _b : false,\n            headers: options.headers\n        });\n    }\n});\nasync function importKey(token) {\n    return globalThis.crypto.subtle.importKey(\"raw\", new TextEncoder().encode(token), {\n        name: \"HMAC\",\n        hash: \"SHA-256\"\n    }, false, [\n        \"sign\",\n        \"verify\"\n    ]);\n}\nasync function signPayload(payload, token) {\n    if (!globalThis.crypto) {\n        return crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac(\"sha256\", token).update(payload).digest(\"hex\");\n    }\n    const signature = await globalThis.crypto.subtle.sign(\"HMAC\", await importKey(token), new TextEncoder().encode(payload));\n    return Buffer.from(new Uint8Array(signature)).toString(\"hex\");\n}\nasync function verifyCallbackSignature({ token, signature, body }) {\n    const secret = token;\n    if (!globalThis.crypto) {\n        const digest = crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac(\"sha256\", secret).update(body).digest(\"hex\");\n        const digestBuffer = Buffer.from(digest);\n        const signatureBuffer = Buffer.from(signature);\n        return digestBuffer.length === signatureBuffer.length && crypto__WEBPACK_IMPORTED_MODULE_0__.timingSafeEqual(digestBuffer, signatureBuffer);\n    }\n    const verified = await globalThis.crypto.subtle.verify(\"HMAC\", await importKey(token), hexToArrayByte(signature), new TextEncoder().encode(body));\n    return verified;\n}\nfunction hexToArrayByte(input) {\n    if (input.length % 2 !== 0) {\n        throw new RangeError(\"Expected string to be an even number of characters\");\n    }\n    const view = new Uint8Array(input.length / 2);\n    for(let i = 0; i < input.length; i += 2){\n        view[i / 2] = Number.parseInt(input.substring(i, i + 2), 16);\n    }\n    return Buffer.from(view);\n}\nfunction getPayloadFromClientToken(clientToken) {\n    const [, , , , encodedToken] = clientToken.split(\"_\");\n    const encodedPayload = Buffer.from(encodedToken != null ? encodedToken : \"\", \"base64\").toString().split(\".\")[1];\n    const decodedPayload = Buffer.from(encodedPayload != null ? encodedPayload : \"\", \"base64\").toString();\n    return JSON.parse(decodedPayload);\n}\nvar EventTypes = {\n    generateClientToken: \"blob.generate-client-token\",\n    uploadCompleted: \"blob.upload-completed\"\n};\nasync function handleUpload({ token, request, body, onBeforeGenerateToken, onUploadCompleted }) {\n    var _a, _b, _c, _d;\n    const resolvedToken = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.getTokenFromOptionsOrEnv)({\n        token\n    });\n    const type = body.type;\n    switch(type){\n        case \"blob.generate-client-token\":\n            {\n                const { pathname, clientPayload, multipart } = body.payload;\n                const payload = await onBeforeGenerateToken(pathname, clientPayload, multipart);\n                const tokenPayload = (_a = payload.tokenPayload) != null ? _a : clientPayload;\n                const { callbackUrl: providedCallbackUrl, ...tokenOptions } = payload;\n                let callbackUrl = providedCallbackUrl;\n                if (onUploadCompleted && !callbackUrl) {\n                    callbackUrl = getCallbackUrl(request);\n                }\n                if (!onUploadCompleted && callbackUrl) {\n                    console.warn(\"callbackUrl was provided but onUploadCompleted is not defined. The callback will not be handled.\");\n                }\n                const oneHourInSeconds = 60 * 60;\n                const now = /* @__PURE__ */ new Date();\n                const validUntil = (_b = payload.validUntil) != null ? _b : now.setSeconds(now.getSeconds() + oneHourInSeconds);\n                return {\n                    type,\n                    clientToken: await generateClientTokenFromReadWriteToken({\n                        ...tokenOptions,\n                        token: resolvedToken,\n                        pathname,\n                        onUploadCompleted: callbackUrl ? {\n                            callbackUrl,\n                            tokenPayload\n                        } : void 0,\n                        validUntil\n                    })\n                };\n            }\n        case \"blob.upload-completed\":\n            {\n                const signatureHeader = \"x-vercel-signature\";\n                const signature = \"credentials\" in request ? (_c = request.headers.get(signatureHeader)) != null ? _c : \"\" : (_d = request.headers[signatureHeader]) != null ? _d : \"\";\n                if (!signature) {\n                    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.BlobError(\"Missing callback signature\");\n                }\n                const isVerified = await verifyCallbackSignature({\n                    token: resolvedToken,\n                    signature,\n                    body: JSON.stringify(body)\n                });\n                if (!isVerified) {\n                    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.BlobError(\"Invalid callback signature\");\n                }\n                if (onUploadCompleted) {\n                    await onUploadCompleted(body.payload);\n                }\n                return {\n                    type,\n                    response: \"ok\"\n                };\n            }\n        default:\n            throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.BlobError(\"Invalid event type\");\n    }\n}\nasync function retrieveClientToken(options) {\n    const { handleUploadUrl, pathname } = options;\n    const url = isAbsoluteUrl(handleUploadUrl) ? handleUploadUrl : toAbsoluteUrl(handleUploadUrl);\n    const event = {\n        type: EventTypes.generateClientToken,\n        payload: {\n            pathname,\n            clientPayload: options.clientPayload,\n            multipart: options.multipart\n        }\n    };\n    const res = await (0,undici__WEBPACK_IMPORTED_MODULE_2__.fetch)(url, {\n        method: \"POST\",\n        body: JSON.stringify(event),\n        headers: {\n            \"content-type\": \"application/json\",\n            ...options.headers\n        },\n        signal: options.abortSignal\n    });\n    if (!res.ok) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.BlobError(\"Failed to  retrieve the client token\");\n    }\n    try {\n        const { clientToken } = await res.json();\n        return clientToken;\n    } catch  {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.BlobError(\"Failed to retrieve the client token\");\n    }\n}\nfunction toAbsoluteUrl(url) {\n    return new URL(url, location.href).href;\n}\nfunction isAbsoluteUrl(url) {\n    try {\n        return Boolean(new URL(url));\n    } catch  {\n        return false;\n    }\n}\nasync function generateClientTokenFromReadWriteToken({ token, ...argsWithoutToken }) {\n    var _a;\n    if (false) {}\n    const timestamp = /* @__PURE__ */ new Date();\n    timestamp.setSeconds(timestamp.getSeconds() + 30);\n    const readWriteToken = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.getTokenFromOptionsOrEnv)({\n        token\n    });\n    const [, , , storeId = null] = readWriteToken.split(\"_\");\n    if (!storeId) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.BlobError(token ? \"Invalid `token` parameter\" : \"Invalid `BLOB_READ_WRITE_TOKEN`\");\n    }\n    const payload = Buffer.from(JSON.stringify({\n        ...argsWithoutToken,\n        validUntil: (_a = argsWithoutToken.validUntil) != null ? _a : timestamp.getTime()\n    })).toString(\"base64\");\n    const securedKey = await signPayload(payload, readWriteToken);\n    if (!securedKey) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_1__.BlobError(\"Unable to sign client token\");\n    }\n    return `vercel_blob_client_${storeId}_${Buffer.from(`${securedKey}.${payload}`).toString(\"base64\")}`;\n}\nfunction getCallbackUrl(request) {\n    const reqPath = getPathFromRequestUrl(request.url);\n    if (!reqPath) {\n        console.warn(\"onUploadCompleted provided but no callbackUrl could be determined. Please provide a callbackUrl in onBeforeGenerateToken or set the VERCEL_BLOB_CALLBACK_URL environment variable.\");\n        return void 0;\n    }\n    if (process.env.VERCEL_BLOB_CALLBACK_URL) {\n        return `${process.env.VERCEL_BLOB_CALLBACK_URL}${reqPath}`;\n    }\n    if (process.env.VERCEL !== \"1\") {\n        console.warn(\"onUploadCompleted provided but no callbackUrl could be determined. Please provide a callbackUrl in onBeforeGenerateToken or set the VERCEL_BLOB_CALLBACK_URL environment variable.\");\n        return void 0;\n    }\n    if (process.env.VERCEL_ENV === \"preview\") {\n        if (process.env.VERCEL_BRANCH_URL) {\n            return `https://${process.env.VERCEL_BRANCH_URL}${reqPath}`;\n        }\n        if (process.env.VERCEL_URL) {\n            return `https://${process.env.VERCEL_URL}${reqPath}`;\n        }\n    }\n    if (process.env.VERCEL_ENV === \"production\" && process.env.VERCEL_PROJECT_PRODUCTION_URL) {\n        return `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}${reqPath}`;\n    }\n    return void 0;\n}\nfunction getPathFromRequestUrl(url) {\n    try {\n        const parsedUrl = new URL(url, \"https://dummy.com\");\n        return parsedUrl.pathname + parsedUrl.search;\n    } catch  {\n        return null;\n    }\n}\n //# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTNkI7QUFFN0IsZ0JBQWdCO0FBQ2lCO0FBQ0Y7QUFDL0IsU0FBU1UscUJBQXFCQyxVQUFVO0lBQ3RDLE9BQU8sU0FBU0MsWUFBWUMsT0FBTztRQUNqQyxJQUFJLENBQUNBLFFBQVFDLEtBQUssQ0FBQ0MsVUFBVSxDQUFDLHdCQUF3QjtZQUNwRCxNQUFNLElBQUlmLHlEQUFTQSxDQUFDLENBQUMsRUFBRVcsV0FBVyxtQ0FBbUMsQ0FBQztRQUN4RTtRQUNBLElBQ0UsNENBQTRDO1FBQzVDRSxRQUFRRyxlQUFlLEtBQUssS0FBSyxLQUFLLDRDQUE0QztRQUNsRkgsUUFBUUksY0FBYyxLQUFLLEtBQUssS0FBSyw0Q0FBNEM7UUFDakZKLFFBQVFLLGtCQUFrQixLQUFLLEtBQUssR0FDcEM7WUFDQSxNQUFNLElBQUlsQix5REFBU0EsQ0FDakIsQ0FBQyxFQUFFVyxXQUFXLDJKQUEySixDQUFDO1FBRTlLO0lBQ0Y7QUFDRjtBQUNBLElBQUlRLE1BQU1kLG1FQUFlQSxDQUFDO0lBQ3hCZSxnQkFBZ0I7UUFBQztLQUFjO0lBQy9CUixhQUFhRixxQkFBcUI7QUFDcEM7QUFDQSxJQUFJVyx3QkFBd0JuQixxRkFBaUNBLENBQUM7SUFDNURrQixnQkFBZ0I7UUFBQztLQUFjO0lBQy9CUixhQUFhRixxQkFBcUI7QUFDcEM7QUFDQSxJQUFJWSwwQkFBMEJuQix1RkFBbUNBLENBQy9EO0lBQ0VpQixnQkFBZ0I7UUFBQztLQUFjO0lBQy9CUixhQUFhRixxQkFBcUI7QUFDcEM7QUFFRixJQUFJYSxhQUFhakIsMEVBQXNCQSxDQUFDO0lBQ3RDYyxnQkFBZ0I7UUFBQztLQUFjO0lBQy9CUixhQUFhRixxQkFBcUI7QUFDcEM7QUFDQSxJQUFJYywwQkFBMEJ2Qix1RkFBbUNBLENBQy9EO0lBQ0VtQixnQkFBZ0I7UUFBQztLQUFjO0lBQy9CUixhQUFh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Q0Msd0JBQXdCLENBQUMsRUFBRUosUUFBUSxDQUFDO0lBQzVEO0lBQ0EsSUFBSUUsUUFBUUMsR0FBRyxDQUFDRSxNQUFNLEtBQUssS0FBSztRQUM5QnZDLFFBQVFDLElBQUksQ0FDVjtRQUVGLE9BQU8sS0FBSztJQUNkO0lBQ0EsSUFBSW1DLFFBQVFDLEdBQUcsQ0FBQ0csVUFBVSxLQUFLLFdBQVc7UUFDeEMsSUFBSUosUUFBUUMsR0FBRyxDQUFDSSxpQkFBaUIsRUFBRTtZQUNqQyxPQUFPLENBQUMsUUFBUSxFQUFFTCxRQUFRQyxHQUFHLENBQUNJLGlCQUFpQixDQUFDLEVBQUVQLFFBQVEsQ0FBQztRQUM3RDtRQUNBLElBQUlFLFFBQVFDLEdBQUcsQ0FBQ0ssVUFBVSxFQUFFO1lBQzFCLE9BQU8sQ0FBQyxRQUFRLEVBQUVOLFFBQVFDLEdBQUcsQ0FBQ0ssVUFBVSxDQUFDLEVBQUVSLFFBQVEsQ0FBQztRQUN0RDtJQUNGO0lBQ0EsSUFBSUUsUUFBUUMsR0FBRyxDQUFDRyxVQUFVLEtBQUssZ0JBQWdCSixRQUFRQyxHQUFHLENBQUNNLDZCQUE2QixFQUFFO1FBQ3hGLE9BQU8sQ0FBQyxRQUFRLEVBQUVQLFFBQVFDLEdBQUcsQ0FBQ00sNkJBQTZCLENBQUMsRUFBRVQsUUFBUSxDQUFDO0lBQ3pFO0lBQ0EsT0FBTyxLQUFLO0FBQ2Q7QUFDQSxTQUFTQyxzQkFBc0JyQixHQUFHO0lBQ2hDLElBQUk7UUFDRixNQUFNOEIsWUFBWSxJQUFJcEIsSUFBSVYsS0FBSztRQUMvQixPQUFPOEIsVUFBVTlHLFFBQVEsR0FBRzhHLFVBQVVDLE1BQU07SUFDOUMsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFZRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ryb3Bjb2RlLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvYmxvYi9kaXN0L2NsaWVudC5qcz85NmIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJsb2JFcnJvcixcbiAgY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QsXG4gIGNyZWF0ZUZvbGRlcixcbiAgY3JlYXRlUHV0TWV0aG9kLFxuICBjcmVhdGVVcGxvYWRQYXJ0TWV0aG9kLFxuICBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnZcbn0gZnJvbSBcIi4vY2h1bmstRk42WEZINlIuanNcIjtcblxuLy8gc3JjL2NsaWVudC50c1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gXCJjcnlwdG9cIjtcbmltcG9ydCB7IGZldGNoIH0gZnJvbSBcInVuZGljaVwiO1xuZnVuY3Rpb24gY3JlYXRlUHV0RXh0cmFDaGVja3MobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZXh0cmFDaGVja3Mob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy50b2tlbi5zdGFydHNXaXRoKFwidmVyY2VsX2Jsb2JfY2xpZW50X1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihgJHttZXRob2ROYW1lfSBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgY2xpZW50IHRva2VuYCk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCAhPT0gdm9pZCAwIHx8IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmFsbG93T3ZlcndyaXRlICE9PSB2b2lkIDAgfHwgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlICE9PSB2b2lkIDBcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIGAke21ldGhvZE5hbWV9IGRvZXNuJ3QgYWxsb3cgXFxgYWRkUmFuZG9tU3VmZml4XFxgLCBcXGBjYWNoZUNvbnRyb2xNYXhBZ2VcXGAgb3IgXFxgYWxsb3dPdmVyd3JpdGVcXGAuIENvbmZpZ3VyZSB0aGVzZSBvcHRpb25zIGF0IHRoZSBzZXJ2ZXIgc2lkZSB3aGVuIGdlbmVyYXRpbmcgY2xpZW50IHRva2Vucy5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbnZhciBwdXQgPSBjcmVhdGVQdXRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gIGV4dHJhQ2hlY2tzOiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhcImNsaWVudC9gcHV0YFwiKVxufSk7XG52YXIgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkID0gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kKHtcbiAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICBleHRyYUNoZWNrczogY3JlYXRlUHV0RXh0cmFDaGVja3MoXCJjbGllbnQvYGNyZWF0ZU11bHRpcGFydFVwbG9hZGBcIilcbn0pO1xudmFyIGNyZWF0ZU11bHRpcGFydFVwbG9hZGVyID0gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QoXG4gIHtcbiAgICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gICAgZXh0cmFDaGVja3M6IGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKFwiY2xpZW50L2BjcmVhdGVNdWx0aXBhcnRVcGxvYWRgXCIpXG4gIH1cbik7XG52YXIgdXBsb2FkUGFydCA9IGNyZWF0ZVVwbG9hZFBhcnRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gIGV4dHJhQ2hlY2tzOiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhcImNsaWVudC9gbXVsdGlwYXJ0VXBsb2FkYFwiKVxufSk7XG52YXIgY29tcGxldGVNdWx0aXBhcnRVcGxvYWQgPSBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZChcbiAge1xuICAgIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgICBleHRyYUNoZWNrczogY3JlYXRlUHV0RXh0cmFDaGVja3MoXCJjbGllbnQvYGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkYFwiKVxuICB9XG4pO1xudmFyIHVwbG9hZCA9IGNyZWF0ZVB1dE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgZXh0cmFDaGVja3Mob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhbmRsZVVwbG9hZFVybCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBcImNsaWVudC9gdXBsb2FkYCByZXF1aXJlcyB0aGUgJ2hhbmRsZVVwbG9hZFVybCcgcGFyYW1ldGVyXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCAhPT0gdm9pZCAwIHx8IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmNyZWF0ZVB1dEV4dHJhQ2hlY2tzICE9PSB2b2lkIDAgfHwgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlICE9PSB2b2lkIDBcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIFwiY2xpZW50L2B1cGxvYWRgIGRvZXNuJ3QgYWxsb3cgYGFkZFJhbmRvbVN1ZmZpeGAsIGBjYWNoZUNvbnRyb2xNYXhBZ2VgIG9yIGBhbGxvd092ZXJ3cml0ZWAuIENvbmZpZ3VyZSB0aGVzZSBvcHRpb25zIGF0IHRoZSBzZXJ2ZXIgc2lkZSB3aGVuIGdlbmVyYXRpbmcgY2xpZW50IHRva2Vucy5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGFzeW5jIGdldFRva2VuKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gcmV0cmlldmVDbGllbnRUb2tlbih7XG4gICAgICBoYW5kbGVVcGxvYWRVcmw6IG9wdGlvbnMuaGFuZGxlVXBsb2FkVXJsLFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBjbGllbnRQYXlsb2FkOiAoX2EgPSBvcHRpb25zLmNsaWVudFBheWxvYWQpICE9IG51bGwgPyBfYSA6IG51bGwsXG4gICAgICBtdWx0aXBhcnQ6IChfYiA9IG9wdGlvbnMubXVsdGlwYXJ0KSAhPSBudWxsID8gX2IgOiBmYWxzZSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICB9XG59KTtcbmFzeW5jIGZ1bmN0aW9uIGltcG9ydEtleSh0b2tlbikge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICBcInJhd1wiLFxuICAgIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0b2tlbiksXG4gICAgeyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogXCJTSEEtMjU2XCIgfSxcbiAgICBmYWxzZSxcbiAgICBbXCJzaWduXCIsIFwidmVyaWZ5XCJdXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBzaWduUGF5bG9hZChwYXlsb2FkLCB0b2tlbikge1xuICBpZiAoIWdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKFwic2hhMjU2XCIsIHRva2VuKS51cGRhdGUocGF5bG9hZCkuZGlnZXN0KFwiaGV4XCIpO1xuICB9XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS5zaWduKFxuICAgIFwiSE1BQ1wiLFxuICAgIGF3YWl0IGltcG9ydEtleSh0b2tlbiksXG4gICAgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHBheWxvYWQpXG4gICk7XG4gIHJldHVybiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShzaWduYXR1cmUpKS50b1N0cmluZyhcImhleFwiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUNhbGxiYWNrU2lnbmF0dXJlKHtcbiAgdG9rZW4sXG4gIHNpZ25hdHVyZSxcbiAgYm9keVxufSkge1xuICBjb25zdCBzZWNyZXQgPSB0b2tlbjtcbiAgaWYgKCFnbG9iYWxUaGlzLmNyeXB0bykge1xuICAgIGNvbnN0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIbWFjKFwic2hhMjU2XCIsIHNlY3JldCkudXBkYXRlKGJvZHkpLmRpZ2VzdChcImhleFwiKTtcbiAgICBjb25zdCBkaWdlc3RCdWZmZXIgPSBCdWZmZXIuZnJvbShkaWdlc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIGRpZ2VzdEJ1ZmZlci5sZW5ndGggPT09IHNpZ25hdHVyZUJ1ZmZlci5sZW5ndGggJiYgY3J5cHRvLnRpbWluZ1NhZmVFcXVhbChkaWdlc3RCdWZmZXIsIHNpZ25hdHVyZUJ1ZmZlcik7XG4gIH1cbiAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUudmVyaWZ5KFxuICAgIFwiSE1BQ1wiLFxuICAgIGF3YWl0IGltcG9ydEtleSh0b2tlbiksXG4gICAgaGV4VG9BcnJheUJ5dGUoc2lnbmF0dXJlKSxcbiAgICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoYm9keSlcbiAgKTtcbiAgcmV0dXJuIHZlcmlmaWVkO1xufVxuZnVuY3Rpb24gaGV4VG9BcnJheUJ5dGUoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV4cGVjdGVkIHN0cmluZyB0byBiZSBhbiBldmVuIG51bWJlciBvZiBjaGFyYWN0ZXJzXCIpO1xuICB9XG4gIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggLyAyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZpZXdbaSAvIDJdID0gTnVtYmVyLnBhcnNlSW50KGlucHV0LnN1YnN0cmluZyhpLCBpICsgMiksIDE2KTtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20odmlldyk7XG59XG5mdW5jdGlvbiBnZXRQYXlsb2FkRnJvbUNsaWVudFRva2VuKGNsaWVudFRva2VuKSB7XG4gIGNvbnN0IFssICwgLCAsIGVuY29kZWRUb2tlbl0gPSBjbGllbnRUb2tlbi5zcGxpdChcIl9cIik7XG4gIGNvbnN0IGVuY29kZWRQYXlsb2FkID0gQnVmZmVyLmZyb20oZW5jb2RlZFRva2VuICE9IG51bGwgPyBlbmNvZGVkVG9rZW4gOiBcIlwiLCBcImJhc2U2NFwiKS50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXTtcbiAgY29uc3QgZGVjb2RlZFBheWxvYWQgPSBCdWZmZXIuZnJvbShlbmNvZGVkUGF5bG9hZCAhPSBudWxsID8gZW5jb2RlZFBheWxvYWQgOiBcIlwiLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVkUGF5bG9hZCk7XG59XG52YXIgRXZlbnRUeXBlcyA9IHtcbiAgZ2VuZXJhdGVDbGllbnRUb2tlbjogXCJibG9iLmdlbmVyYXRlLWNsaWVudC10b2tlblwiLFxuICB1cGxvYWRDb21wbGV0ZWQ6IFwiYmxvYi51cGxvYWQtY29tcGxldGVkXCJcbn07XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVVcGxvYWQoe1xuICB0b2tlbixcbiAgcmVxdWVzdCxcbiAgYm9keSxcbiAgb25CZWZvcmVHZW5lcmF0ZVRva2VuLFxuICBvblVwbG9hZENvbXBsZXRlZFxufSkge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IHJlc29sdmVkVG9rZW4gPSBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYoeyB0b2tlbiB9KTtcbiAgY29uc3QgdHlwZSA9IGJvZHkudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImJsb2IuZ2VuZXJhdGUtY2xpZW50LXRva2VuXCI6IHtcbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIGNsaWVudFBheWxvYWQsIG11bHRpcGFydCB9ID0gYm9keS5wYXlsb2FkO1xuICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IG9uQmVmb3JlR2VuZXJhdGVUb2tlbihcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIGNsaWVudFBheWxvYWQsXG4gICAgICAgIG11bHRpcGFydFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRva2VuUGF5bG9hZCA9IChfYSA9IHBheWxvYWQudG9rZW5QYXlsb2FkKSAhPSBudWxsID8gX2EgOiBjbGllbnRQYXlsb2FkO1xuICAgICAgY29uc3QgeyBjYWxsYmFja1VybDogcHJvdmlkZWRDYWxsYmFja1VybCwgLi4udG9rZW5PcHRpb25zIH0gPSBwYXlsb2FkO1xuICAgICAgbGV0IGNhbGxiYWNrVXJsID0gcHJvdmlkZWRDYWxsYmFja1VybDtcbiAgICAgIGlmIChvblVwbG9hZENvbXBsZXRlZCAmJiAhY2FsbGJhY2tVcmwpIHtcbiAgICAgICAgY2FsbGJhY2tVcmwgPSBnZXRDYWxsYmFja1VybChyZXF1ZXN0KTtcbiAgICAgIH1cbiAgICAgIGlmICghb25VcGxvYWRDb21wbGV0ZWQgJiYgY2FsbGJhY2tVcmwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY2FsbGJhY2tVcmwgd2FzIHByb3ZpZGVkIGJ1dCBvblVwbG9hZENvbXBsZXRlZCBpcyBub3QgZGVmaW5lZC4gVGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGhhbmRsZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZUhvdXJJblNlY29uZHMgPSA2MCAqIDYwO1xuICAgICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB2YWxpZFVudGlsID0gKF9iID0gcGF5bG9hZC52YWxpZFVudGlsKSAhPSBudWxsID8gX2IgOiBub3cuc2V0U2Vjb25kcyhub3cuZ2V0U2Vjb25kcygpICsgb25lSG91ckluU2Vjb25kcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBjbGllbnRUb2tlbjogYXdhaXQgZ2VuZXJhdGVDbGllbnRUb2tlbkZyb21SZWFkV3JpdGVUb2tlbih7XG4gICAgICAgICAgLi4udG9rZW5PcHRpb25zLFxuICAgICAgICAgIHRva2VuOiByZXNvbHZlZFRva2VuLFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIG9uVXBsb2FkQ29tcGxldGVkOiBjYWxsYmFja1VybCA/IHtcbiAgICAgICAgICAgIGNhbGxiYWNrVXJsLFxuICAgICAgICAgICAgdG9rZW5QYXlsb2FkXG4gICAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgICB2YWxpZFVudGlsXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiYmxvYi51cGxvYWQtY29tcGxldGVkXCI6IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUhlYWRlciA9IFwieC12ZXJjZWwtc2lnbmF0dXJlXCI7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBcImNyZWRlbnRpYWxzXCIgaW4gcmVxdWVzdCA/IChfYyA9IHJlcXVlc3QuaGVhZGVycy5nZXQoc2lnbmF0dXJlSGVhZGVyKSkgIT0gbnVsbCA/IF9jIDogXCJcIiA6IChfZCA9IHJlcXVlc3QuaGVhZGVyc1tzaWduYXR1cmVIZWFkZXJdKSAhPSBudWxsID8gX2QgOiBcIlwiO1xuICAgICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIk1pc3NpbmcgY2FsbGJhY2sgc2lnbmF0dXJlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IHZlcmlmeUNhbGxiYWNrU2lnbmF0dXJlKHtcbiAgICAgICAgdG9rZW46IHJlc29sdmVkVG9rZW4sXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc1ZlcmlmaWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJJbnZhbGlkIGNhbGxiYWNrIHNpZ25hdHVyZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvblVwbG9hZENvbXBsZXRlZCkge1xuICAgICAgICBhd2FpdCBvblVwbG9hZENvbXBsZXRlZChib2R5LnBheWxvYWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZSwgcmVzcG9uc2U6IFwib2tcIiB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkludmFsaWQgZXZlbnQgdHlwZVwiKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmV0cmlldmVDbGllbnRUb2tlbihvcHRpb25zKSB7XG4gIGNvbnN0IHsgaGFuZGxlVXBsb2FkVXJsLCBwYXRobmFtZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgdXJsID0gaXNBYnNvbHV0ZVVybChoYW5kbGVVcGxvYWRVcmwpID8gaGFuZGxlVXBsb2FkVXJsIDogdG9BYnNvbHV0ZVVybChoYW5kbGVVcGxvYWRVcmwpO1xuICBjb25zdCBldmVudCA9IHtcbiAgICB0eXBlOiBFdmVudFR5cGVzLmdlbmVyYXRlQ2xpZW50VG9rZW4sXG4gICAgcGF5bG9hZDoge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBjbGllbnRQYXlsb2FkOiBvcHRpb25zLmNsaWVudFBheWxvYWQsXG4gICAgICBtdWx0aXBhcnQ6IG9wdGlvbnMubXVsdGlwYXJ0XG4gICAgfVxuICB9O1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGV2ZW50KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgIH0sXG4gICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gIH0pO1xuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJGYWlsZWQgdG8gIHJldHJpZXZlIHRoZSBjbGllbnQgdG9rZW5cIik7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGNsaWVudFRva2VuIH0gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiBjbGllbnRUb2tlbjtcbiAgfSBjYXRjaCB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkZhaWxlZCB0byByZXRyaWV2ZSB0aGUgY2xpZW50IHRva2VuXCIpO1xuICB9XG59XG5mdW5jdGlvbiB0b0Fic29sdXRlVXJsKHVybCkge1xuICByZXR1cm4gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpLmhyZWY7XG59XG5mdW5jdGlvbiBpc0Fic29sdXRlVXJsKHVybCkge1xuICB0cnkge1xuICAgIHJldHVybiBCb29sZWFuKG5ldyBVUkwodXJsKSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVDbGllbnRUb2tlbkZyb21SZWFkV3JpdGVUb2tlbih7XG4gIHRva2VuLFxuICAuLi5hcmdzV2l0aG91dFRva2VuXG59KSB7XG4gIHZhciBfYTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgJ1wiZ2VuZXJhdGVDbGllbnRUb2tlbkZyb21SZWFkV3JpdGVUb2tlblwiIG11c3QgYmUgY2FsbGVkIGZyb20gYSBzZXJ2ZXIgZW52aXJvbm1lbnQnXG4gICAgKTtcbiAgfVxuICBjb25zdCB0aW1lc3RhbXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgdGltZXN0YW1wLnNldFNlY29uZHModGltZXN0YW1wLmdldFNlY29uZHMoKSArIDMwKTtcbiAgY29uc3QgcmVhZFdyaXRlVG9rZW4gPSBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYoeyB0b2tlbiB9KTtcbiAgY29uc3QgWywgLCAsIHN0b3JlSWQgPSBudWxsXSA9IHJlYWRXcml0ZVRva2VuLnNwbGl0KFwiX1wiKTtcbiAgaWYgKCFzdG9yZUlkKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgIHRva2VuID8gXCJJbnZhbGlkIGB0b2tlbmAgcGFyYW1ldGVyXCIgOiBcIkludmFsaWQgYEJMT0JfUkVBRF9XUklURV9UT0tFTmBcIlxuICAgICk7XG4gIH1cbiAgY29uc3QgcGF5bG9hZCA9IEJ1ZmZlci5mcm9tKFxuICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIC4uLmFyZ3NXaXRob3V0VG9rZW4sXG4gICAgICB2YWxpZFVudGlsOiAoX2EgPSBhcmdzV2l0aG91dFRva2VuLnZhbGlkVW50aWwpICE9IG51bGwgPyBfYSA6IHRpbWVzdGFtcC5nZXRUaW1lKClcbiAgICB9KVxuICApLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICBjb25zdCBzZWN1cmVkS2V5ID0gYXdhaXQgc2lnblBheWxvYWQocGF5bG9hZCwgcmVhZFdyaXRlVG9rZW4pO1xuICBpZiAoIXNlY3VyZWRLZXkpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiVW5hYmxlIHRvIHNpZ24gY2xpZW50IHRva2VuXCIpO1xuICB9XG4gIHJldHVybiBgdmVyY2VsX2Jsb2JfY2xpZW50XyR7c3RvcmVJZH1fJHtCdWZmZXIuZnJvbShcbiAgICBgJHtzZWN1cmVkS2V5fS4ke3BheWxvYWR9YFxuICApLnRvU3RyaW5nKFwiYmFzZTY0XCIpfWA7XG59XG5mdW5jdGlvbiBnZXRDYWxsYmFja1VybChyZXF1ZXN0KSB7XG4gIGNvbnN0IHJlcVBhdGggPSBnZXRQYXRoRnJvbVJlcXVlc3RVcmwocmVxdWVzdC51cmwpO1xuICBpZiAoIXJlcVBhdGgpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIm9uVXBsb2FkQ29tcGxldGVkIHByb3ZpZGVkIGJ1dCBubyBjYWxsYmFja1VybCBjb3VsZCBiZSBkZXRlcm1pbmVkLiBQbGVhc2UgcHJvdmlkZSBhIGNhbGxiYWNrVXJsIGluIG9uQmVmb3JlR2VuZXJhdGVUb2tlbiBvciBzZXQgdGhlIFZFUkNFTF9CTE9CX0NBTExCQUNLX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZS5cIlxuICAgICk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfQ0FMTEJBQ0tfVVJMKSB7XG4gICAgcmV0dXJuIGAke3Byb2Nlc3MuZW52LlZFUkNFTF9CTE9CX0NBTExCQUNLX1VSTH0ke3JlcVBhdGh9YDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuVkVSQ0VMICE9PSBcIjFcIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwib25VcGxvYWRDb21wbGV0ZWQgcHJvdmlkZWQgYnV0IG5vIGNhbGxiYWNrVXJsIGNvdWxkIGJlIGRldGVybWluZWQuIFBsZWFzZSBwcm92aWRlIGEgY2FsbGJhY2tVcmwgaW4gb25CZWZvcmVHZW5lcmF0ZVRva2VuIG9yIHNldCB0aGUgVkVSQ0VMX0JMT0JfQ0FMTEJBQ0tfVVJMIGVudmlyb25tZW50IHZhcmlhYmxlLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5WRVJDRUxfRU5WID09PSBcInByZXZpZXdcIikge1xuICAgIGlmIChwcm9jZXNzLmVudi5WRVJDRUxfQlJBTkNIX1VSTCkge1xuICAgICAgcmV0dXJuIGBodHRwczovLyR7cHJvY2Vzcy5lbnYuVkVSQ0VMX0JSQU5DSF9VUkx9JHtyZXFQYXRofWA7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5WRVJDRUxfVVJMKSB7XG4gICAgICByZXR1cm4gYGh0dHBzOi8vJHtwcm9jZXNzLmVudi5WRVJDRUxfVVJMfSR7cmVxUGF0aH1gO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuVkVSQ0VMX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgJiYgcHJvY2Vzcy5lbnYuVkVSQ0VMX1BST0pFQ1RfUFJPRFVDVElPTl9VUkwpIHtcbiAgICByZXR1cm4gYGh0dHBzOi8vJHtwcm9jZXNzLmVudi5WRVJDRUxfUFJPSkVDVF9QUk9EVUNUSU9OX1VSTH0ke3JlcVBhdGh9YDtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0UGF0aEZyb21SZXF1ZXN0VXJsKHVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsLCBcImh0dHBzOi8vZHVtbXkuY29tXCIpO1xuICAgIHJldHVybiBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZXhwb3J0IHtcbiAgY29tcGxldGVNdWx0aXBhcnRVcGxvYWQsXG4gIGNyZWF0ZUZvbGRlcixcbiAgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkLFxuICBjcmVhdGVNdWx0aXBhcnRVcGxvYWRlcixcbiAgZ2VuZXJhdGVDbGllbnRUb2tlbkZyb21SZWFkV3JpdGVUb2tlbixcbiAgZ2V0UGF5bG9hZEZyb21DbGllbnRUb2tlbixcbiAgaGFuZGxlVXBsb2FkLFxuICBwdXQsXG4gIHVwbG9hZCxcbiAgdXBsb2FkUGFydFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiQmxvYkVycm9yIiwiY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QiLCJjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2QiLCJjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCIsImNyZWF0ZUZvbGRlciIsImNyZWF0ZVB1dE1ldGhvZCIsImNyZWF0ZVVwbG9hZFBhcnRNZXRob2QiLCJnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYiLCJjcnlwdG8iLCJmZXRjaCIsImNyZWF0ZVB1dEV4dHJhQ2hlY2tzIiwibWV0aG9kTmFtZSIsImV4dHJhQ2hlY2tzIiwib3B0aW9ucyIsInRva2VuIiwic3RhcnRzV2l0aCIsImFkZFJhbmRvbVN1ZmZpeCIsImFsbG93T3ZlcndyaXRlIiwiY2FjaGVDb250cm9sTWF4QWdlIiwicHV0IiwiYWxsb3dlZE9wdGlvbnMiLCJjcmVhdGVNdWx0aXBhcnRVcGxvYWQiLCJjcmVhdGVNdWx0aXBhcnRVcGxvYWRlciIsInVwbG9hZFBhcnQiLCJjb21wbGV0ZU11bHRpcGFydFVwbG9hZCIsInVwbG9hZCIsImhhbmRsZVVwbG9hZFVybCIsImdldFRva2VuIiwicGF0aG5hbWUiLCJfYSIsIl9iIiwicmV0cmlldmVDbGllbnRUb2tlbiIsImNsaWVudFBheWxvYWQiLCJtdWx0aXBhcnQiLCJoZWFkZXJzIiwiaW1wb3J0S2V5IiwiZ2xvYmFsVGhpcyIsInN1YnRsZSIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwibmFtZSIsImhhc2giLCJzaWduUGF5bG9hZCIsInBheWxvYWQiLCJjcmVhdGVIbWFjIiwidXBkYXRlIiwiZGlnZXN0Iiwic2lnbmF0dXJlIiwic2lnbiIsIkJ1ZmZlciIsImZyb20iLCJVaW50OEFycmF5IiwidG9TdHJpbmciLCJ2ZXJpZnlDYWxsYmFja1NpZ25hdHVyZSIsImJvZHkiLCJzZWNyZXQiLCJkaWdlc3RCdWZmZXIiLCJzaWduYXR1cmVCdWZmZXIiLCJsZW5ndGgiLCJ0aW1pbmdTYWZlRXF1YWwiLCJ2ZXJpZmllZCIsInZlcmlmeSIsImhleFRvQXJyYXlCeXRlIiwiaW5wdXQiLCJSYW5nZUVycm9yIiwidmlldyIsImkiLCJOdW1iZXIiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImdldFBheWxvYWRGcm9tQ2xpZW50VG9rZW4iLCJjbGllbnRUb2tlbiIsImVuY29kZWRUb2tlbiIsInNwbGl0IiwiZW5jb2RlZFBheWxvYWQiLCJkZWNvZGVkUGF5bG9hZCIsIkpTT04iLCJwYXJzZSIsIkV2ZW50VHlwZXMiLCJnZW5lcmF0ZUNsaWVudFRva2VuIiwidXBsb2FkQ29tcGxldGVkIiwiaGFuZGxlVXBsb2FkIiwicmVxdWVzdCIsIm9uQmVmb3JlR2VuZXJhdGVUb2tlbiIsIm9uVXBsb2FkQ29tcGxldGVkIiwiX2MiLCJfZCIsInJlc29sdmVkVG9rZW4iLCJ0eXBlIiwidG9rZW5QYXlsb2FkIiwiY2FsbGJhY2tVcmwiLCJwcm92aWRlZENhbGxiYWNrVXJsIiwidG9rZW5PcHRpb25zIiwiZ2V0Q2FsbGJhY2tVcmwiLCJjb25zb2xlIiwid2FybiIsIm9uZUhvdXJJblNlY29uZHMiLCJub3ciLCJEYXRlIiwidmFsaWRVbnRpbCIsInNldFNlY29uZHMiLCJnZXRTZWNvbmRzIiwiZ2VuZXJhdGVDbGllbnRUb2tlbkZyb21SZWFkV3JpdGVUb2tlbiIsInNpZ25hdHVyZUhlYWRlciIsImdldCIsImlzVmVyaWZpZWQiLCJzdHJpbmdpZnkiLCJyZXNwb25zZSIsInVybCIsImlzQWJzb2x1dGVVcmwiLCJ0b0Fic29sdXRlVXJsIiwiZXZlbnQiLCJyZXMiLCJtZXRob2QiLCJzaWduYWwiLCJhYm9ydFNpZ25hbCIsIm9rIiwianNvbiIsIlVSTCIsImxvY2F0aW9uIiwiaHJlZiIsIkJvb2xlYW4iLCJhcmdzV2l0aG91dFRva2VuIiwidGltZXN0YW1wIiwicmVhZFdyaXRlVG9rZW4iLCJzdG9yZUlkIiwiZ2V0VGltZSIsInNlY3VyZWRLZXkiLCJyZXFQYXRoIiwiZ2V0UGF0aEZyb21SZXF1ZXN0VXJsIiwicHJvY2VzcyIsImVudiIsIlZFUkNFTF9CTE9CX0NBTExCQUNLX1VSTCIsIlZFUkNFTCIsIlZFUkNFTF9FTlYiLCJWRVJDRUxfQlJBTkNIX1VSTCIsIlZFUkNFTF9VUkwiLCJWRVJDRUxfUFJPSkVDVF9QUk9EVUNUSU9OX1VSTCIsInBhcnNlZFVybCIsInNlYXJjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/blob/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@vercel/blob/dist/undici-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/undici-browser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetch: () => (/* binding */ fetch)\n/* harmony export */ });\n// this file gets copied to the dist folder\n// it makes undici work in the browser by reusing the global fetch\n// it's the simplest way I've found to make http requests work in Node.js, Serverles Functions, Edge Functions, and the browser\n// this should work as long as this module is used via Next.js/Webpack\n// moving forward we will have to solve this problem in a more robust way\n// reusing https://github.com/inrupt/universal-fetch\n// or seeing how/if cross-fetch solves https://github.com/lquixada/cross-fetch/issues/69\nconst fetch = globalThis.fetch.bind(globalThis);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvdW5kaWNpLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDJDQUEyQztBQUMzQyxrRUFBa0U7QUFDbEUsK0hBQStIO0FBQy9ILHNFQUFzRTtBQUN0RSx5RUFBeUU7QUFDekUsb0RBQW9EO0FBQ3BELHdGQUF3RjtBQUNqRixNQUFNQSxRQUFRQyxXQUFXRCxLQUFLLENBQUNFLElBQUksQ0FBQ0QsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ryb3Bjb2RlLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvYmxvYi9kaXN0L3VuZGljaS1icm93c2VyLmpzPzRjNjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGhpcyBmaWxlIGdldHMgY29waWVkIHRvIHRoZSBkaXN0IGZvbGRlclxuLy8gaXQgbWFrZXMgdW5kaWNpIHdvcmsgaW4gdGhlIGJyb3dzZXIgYnkgcmV1c2luZyB0aGUgZ2xvYmFsIGZldGNoXG4vLyBpdCdzIHRoZSBzaW1wbGVzdCB3YXkgSSd2ZSBmb3VuZCB0byBtYWtlIGh0dHAgcmVxdWVzdHMgd29yayBpbiBOb2RlLmpzLCBTZXJ2ZXJsZXMgRnVuY3Rpb25zLCBFZGdlIEZ1bmN0aW9ucywgYW5kIHRoZSBicm93c2VyXG4vLyB0aGlzIHNob3VsZCB3b3JrIGFzIGxvbmcgYXMgdGhpcyBtb2R1bGUgaXMgdXNlZCB2aWEgTmV4dC5qcy9XZWJwYWNrXG4vLyBtb3ZpbmcgZm9yd2FyZCB3ZSB3aWxsIGhhdmUgdG8gc29sdmUgdGhpcyBwcm9ibGVtIGluIGEgbW9yZSByb2J1c3Qgd2F5XG4vLyByZXVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9pbnJ1cHQvdW5pdmVyc2FsLWZldGNoXG4vLyBvciBzZWVpbmcgaG93L2lmIGNyb3NzLWZldGNoIHNvbHZlcyBodHRwczovL2dpdGh1Yi5jb20vbHF1aXhhZGEvY3Jvc3MtZmV0Y2gvaXNzdWVzLzY5XG5leHBvcnQgY29uc3QgZmV0Y2ggPSBnbG9iYWxUaGlzLmZldGNoLmJpbmQoZ2xvYmFsVGhpcyk7XG4iXSwibmFtZXMiOlsiZmV0Y2giLCJnbG9iYWxUaGlzIiwiYmluZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/blob/dist/undici-browser.js\n");

/***/ })

};
;