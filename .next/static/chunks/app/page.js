/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=X%3A%5Cprojects%5CDropCode%5Ccomponents%5CMainApp.tsx&modules=X%3A%5Cprojects%5CDropCode%5Ccomponents%5Cproviders%5CAppProvider.tsx&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=X%3A%5Cprojects%5CDropCode%5Ccomponents%5CMainApp.tsx&modules=X%3A%5Cprojects%5CDropCode%5Ccomponents%5Cproviders%5CAppProvider.tsx&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/MainApp.tsx */ \"(app-pages-browser)/./components/MainApp.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/providers/AppProvider.tsx */ \"(app-pages-browser)/./components/providers/AppProvider.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1YJTNBJTVDcHJvamVjdHMlNUNEcm9wQ29kZSU1Q2NvbXBvbmVudHMlNUNNYWluQXBwLnRzeCZtb2R1bGVzPVglM0ElNUNwcm9qZWN0cyU1Q0Ryb3BDb2RlJTVDY29tcG9uZW50cyU1Q3Byb3ZpZGVycyU1Q0FwcFByb3ZpZGVyLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDBLQUFvRjtBQUNwRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzU5MGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJYOlxcXFxwcm9qZWN0c1xcXFxEcm9wQ29kZVxcXFxjb21wb25lbnRzXFxcXE1haW5BcHAudHN4XCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJYOlxcXFxwcm9qZWN0c1xcXFxEcm9wQ29kZVxcXFxjb21wb25lbnRzXFxcXHByb3ZpZGVyc1xcXFxBcHBQcm92aWRlci50c3hcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=X%3A%5Cprojects%5CDropCode%5Ccomponents%5CMainApp.tsx&modules=X%3A%5Cprojects%5CDropCode%5Ccomponents%5Cproviders%5CAppProvider.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/async-retry/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/async-retry/lib/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Packages\n\nvar retrier = __webpack_require__(/*! retry */ \"(app-pages-browser)/./node_modules/retry/index.js\");\nfunction retry(fn, opts) {\n    function run(resolve, reject) {\n        var options = opts || {};\n        var op;\n        // Default `randomize` to true\n        if (!(\"randomize\" in options)) {\n            options.randomize = true;\n        }\n        op = retrier.operation(options);\n        // We allow the user to abort retrying\n        // this makes sense in the cases where\n        // knowledge is obtained that retrying\n        // would be futile (e.g.: auth errors)\n        function bail(err) {\n            reject(err || new Error(\"Aborted\"));\n        }\n        function onError(err, num) {\n            if (err.bail) {\n                bail(err);\n                return;\n            }\n            if (!op.retry(err)) {\n                reject(op.mainError());\n            } else if (options.onRetry) {\n                options.onRetry(err, num);\n            }\n        }\n        function runAttempt(num) {\n            var val;\n            try {\n                val = fn(bail, num);\n            } catch (err) {\n                onError(err, num);\n                return;\n            }\n            Promise.resolve(val).then(resolve).catch(function catchIt(err) {\n                onError(err, num);\n            });\n        }\n        op.attempt(runAttempt);\n    }\n    return new Promise(run);\n}\nmodule.exports = retry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hc3luYy1yZXRyeS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsV0FBVzs7QUFDWCxJQUFJQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUV0QixTQUFTQyxNQUFNQyxFQUFFLEVBQUVDLElBQUk7SUFDckIsU0FBU0MsSUFBSUMsT0FBTyxFQUFFQyxNQUFNO1FBQzFCLElBQUlDLFVBQVVKLFFBQVEsQ0FBQztRQUN2QixJQUFJSztRQUVKLDhCQUE4QjtRQUM5QixJQUFJLENBQUUsZ0JBQWVELE9BQU0sR0FBSTtZQUM3QkEsUUFBUUUsU0FBUyxHQUFHO1FBQ3RCO1FBRUFELEtBQUtULFFBQVFXLFNBQVMsQ0FBQ0g7UUFFdkIsc0NBQXNDO1FBQ3RDLHNDQUFzQztRQUN0QyxzQ0FBc0M7UUFDdEMsc0NBQXNDO1FBRXRDLFNBQVNJLEtBQUtDLEdBQUc7WUFDZk4sT0FBT00sT0FBTyxJQUFJQyxNQUFNO1FBQzFCO1FBRUEsU0FBU0MsUUFBUUYsR0FBRyxFQUFFRyxHQUFHO1lBQ3ZCLElBQUlILElBQUlELElBQUksRUFBRTtnQkFDWkEsS0FBS0M7Z0JBQ0w7WUFDRjtZQUVBLElBQUksQ0FBQ0osR0FBR1AsS0FBSyxDQUFDVyxNQUFNO2dCQUNsQk4sT0FBT0UsR0FBR1EsU0FBUztZQUNyQixPQUFPLElBQUlULFFBQVFVLE9BQU8sRUFBRTtnQkFDMUJWLFFBQVFVLE9BQU8sQ0FBQ0wsS0FBS0c7WUFDdkI7UUFDRjtRQUVBLFNBQVNHLFdBQVdILEdBQUc7WUFDckIsSUFBSUk7WUFFSixJQUFJO2dCQUNGQSxNQUFNakIsR0FBR1MsTUFBTUk7WUFDakIsRUFBRSxPQUFPSCxLQUFLO2dCQUNaRSxRQUFRRixLQUFLRztnQkFDYjtZQUNGO1lBRUFLLFFBQVFmLE9BQU8sQ0FBQ2MsS0FDYkUsSUFBSSxDQUFDaEIsU0FDTGlCLEtBQUssQ0FBQyxTQUFTQyxRQUFRWCxHQUFHO2dCQUN6QkUsUUFBUUYsS0FBS0c7WUFDZjtRQUNKO1FBRUFQLEdBQUdnQixPQUFPLENBQUNOO0lBQ2I7SUFFQSxPQUFPLElBQUlFLFFBQVFoQjtBQUNyQjtBQUVBcUIsT0FBT0MsT0FBTyxHQUFHekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FzeW5jLXJldHJ5L2xpYi9pbmRleC5qcz9mMzdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBhY2thZ2VzXG52YXIgcmV0cmllciA9IHJlcXVpcmUoJ3JldHJ5Jyk7XG5cbmZ1bmN0aW9uIHJldHJ5KGZuLCBvcHRzKSB7XG4gIGZ1bmN0aW9uIHJ1bihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgdmFyIG9wO1xuXG4gICAgLy8gRGVmYXVsdCBgcmFuZG9taXplYCB0byB0cnVlXG4gICAgaWYgKCEoJ3JhbmRvbWl6ZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMucmFuZG9taXplID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBvcCA9IHJldHJpZXIub3BlcmF0aW9uKG9wdGlvbnMpO1xuXG4gICAgLy8gV2UgYWxsb3cgdGhlIHVzZXIgdG8gYWJvcnQgcmV0cnlpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNlbnNlIGluIHRoZSBjYXNlcyB3aGVyZVxuICAgIC8vIGtub3dsZWRnZSBpcyBvYnRhaW5lZCB0aGF0IHJldHJ5aW5nXG4gICAgLy8gd291bGQgYmUgZnV0aWxlIChlLmcuOiBhdXRoIGVycm9ycylcblxuICAgIGZ1bmN0aW9uIGJhaWwoZXJyKSB7XG4gICAgICByZWplY3QoZXJyIHx8IG5ldyBFcnJvcignQWJvcnRlZCcpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkVycm9yKGVyciwgbnVtKSB7XG4gICAgICBpZiAoZXJyLmJhaWwpIHtcbiAgICAgICAgYmFpbChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghb3AucmV0cnkoZXJyKSkge1xuICAgICAgICByZWplY3Qob3AubWFpbkVycm9yKCkpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9uUmV0cnkpIHtcbiAgICAgICAgb3B0aW9ucy5vblJldHJ5KGVyciwgbnVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5BdHRlbXB0KG51bSkge1xuICAgICAgdmFyIHZhbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsID0gZm4oYmFpbCwgbnVtKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBvbkVycm9yKGVyciwgbnVtKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBQcm9taXNlLnJlc29sdmUodmFsKVxuICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gY2F0Y2hJdChlcnIpIHtcbiAgICAgICAgICBvbkVycm9yKGVyciwgbnVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb3AuYXR0ZW1wdChydW5BdHRlbXB0KTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShydW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJldHJ5O1xuIl0sIm5hbWVzIjpbInJldHJpZXIiLCJyZXF1aXJlIiwicmV0cnkiLCJmbiIsIm9wdHMiLCJydW4iLCJyZXNvbHZlIiwicmVqZWN0Iiwib3B0aW9ucyIsIm9wIiwicmFuZG9taXplIiwib3BlcmF0aW9uIiwiYmFpbCIsImVyciIsIkVycm9yIiwib25FcnJvciIsIm51bSIsIm1haW5FcnJvciIsIm9uUmV0cnkiLCJydW5BdHRlbXB0IiwidmFsIiwiUHJvbWlzZSIsInRoZW4iLCJjYXRjaCIsImNhdGNoSXQiLCJhdHRlbXB0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/async-retry/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor(var i = 0, len = code.length; i < len; ++i){\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n}\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup[\"-\".charCodeAt(0)] = 62;\nrevLookup[\"_\".charCodeAt(0)] = 63;\nfunction getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n    var validLen = b64.indexOf(\"=\");\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [\n        validLen,\n        placeHoldersLen\n    ];\n}\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength(b64) {\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction toByteArray(b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    // if there are placeholders, only get up to the last complete 4 chars\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for(i = 0; i < len; i += 4){\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 0xFF;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\nfunction encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}\nfunction fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n    ;\n    var parts = [];\n    var maxChunkLength = 16383 // must be multiple of 3\n    ;\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + \"==\");\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + \"=\");\n    }\n    return parts.join(\"\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsa0JBQWtCLEdBQUdDO0FBQ3JCRCxtQkFBbUIsR0FBR0U7QUFDdEJGLHFCQUFxQixHQUFHRztBQUV4QixJQUFJQyxTQUFTLEVBQUU7QUFDZixJQUFJQyxZQUFZLEVBQUU7QUFDbEIsSUFBSUMsTUFBTSxPQUFPQyxlQUFlLGNBQWNBLGFBQWFDO0FBRTNELElBQUlDLE9BQU87QUFDWCxJQUFLLElBQUlDLElBQUksR0FBR0MsTUFBTUYsS0FBS0csTUFBTSxFQUFFRixJQUFJQyxLQUFLLEVBQUVELEVBQUc7SUFDL0NOLE1BQU0sQ0FBQ00sRUFBRSxHQUFHRCxJQUFJLENBQUNDLEVBQUU7SUFDbkJMLFNBQVMsQ0FBQ0ksS0FBS0ksVUFBVSxDQUFDSCxHQUFHLEdBQUdBO0FBQ2xDO0FBRUEsNkRBQTZEO0FBQzdELDZEQUE2RDtBQUM3REwsU0FBUyxDQUFDLElBQUlRLFVBQVUsQ0FBQyxHQUFHLEdBQUc7QUFDL0JSLFNBQVMsQ0FBQyxJQUFJUSxVQUFVLENBQUMsR0FBRyxHQUFHO0FBRS9CLFNBQVNDLFFBQVNDLEdBQUc7SUFDbkIsSUFBSUosTUFBTUksSUFBSUgsTUFBTTtJQUVwQixJQUFJRCxNQUFNLElBQUksR0FBRztRQUNmLE1BQU0sSUFBSUssTUFBTTtJQUNsQjtJQUVBLHlEQUF5RDtJQUN6RCx5REFBeUQ7SUFDekQsSUFBSUMsV0FBV0YsSUFBSUcsT0FBTyxDQUFDO0lBQzNCLElBQUlELGFBQWEsQ0FBQyxHQUFHQSxXQUFXTjtJQUVoQyxJQUFJUSxrQkFBa0JGLGFBQWFOLE1BQy9CLElBQ0EsSUFBS00sV0FBVztJQUVwQixPQUFPO1FBQUNBO1FBQVVFO0tBQWdCO0FBQ3BDO0FBRUEsNERBQTREO0FBQzVELFNBQVNsQixXQUFZYyxHQUFHO0lBQ3RCLElBQUlLLE9BQU9OLFFBQVFDO0lBQ25CLElBQUlFLFdBQVdHLElBQUksQ0FB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QUFNO0lBQ3RCLElBQUlzQixhQUFhdkIsTUFBTSxFQUFFLHNDQUFzQzs7SUFDL0QsSUFBSXdCLFFBQVEsRUFBRTtJQUNkLElBQUlDLGlCQUFpQixNQUFNLHdCQUF3Qjs7SUFFbkQsK0VBQStFO0lBQy9FLElBQUssSUFBSTFCLElBQUksR0FBRzJCLE9BQU8xQixNQUFNdUIsWUFBWXhCLElBQUkyQixNQUFNM0IsS0FBSzBCLGVBQWdCO1FBQ3RFRCxNQUFNSCxJQUFJLENBQUNMLFlBQVlDLE9BQU9sQixHQUFHLElBQUswQixpQkFBa0JDLE9BQU9BLE9BQVEzQixJQUFJMEI7SUFDN0U7SUFFQSxzRUFBc0U7SUFDdEUsSUFBSUYsZUFBZSxHQUFHO1FBQ3BCWixNQUFNTSxLQUFLLENBQUNqQixNQUFNLEVBQUU7UUFDcEJ3QixNQUFNSCxJQUFJLENBQ1I1QixNQUFNLENBQUNrQixPQUFPLEVBQUUsR0FDaEJsQixNQUFNLENBQUMsT0FBUSxJQUFLLEtBQUssR0FDekI7SUFFSixPQUFPLElBQUk4QixlQUFlLEdBQUc7UUFDM0JaLE1BQU0sQ0FBQ00sS0FBSyxDQUFDakIsTUFBTSxFQUFFLElBQUksS0FBS2lCLEtBQUssQ0FBQ2pCLE1BQU0sRUFBRTtRQUM1Q3dCLE1BQU1ILElBQUksQ0FDUjVCLE1BQU0sQ0FBQ2tCLE9BQU8sR0FBRyxHQUNqQmxCLE1BQU0sQ0FBQyxPQUFRLElBQUssS0FBSyxHQUN6QkEsTUFBTSxDQUFDLE9BQVEsSUFBSyxLQUFLLEdBQ3pCO0lBRUo7SUFFQSxPQUFPK0IsTUFBTUYsSUFBSSxDQUFDO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanM/Mzc3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiYnl0ZUxlbmd0aCIsInRvQnl0ZUFycmF5IiwiZnJvbUJ5dGVBcnJheSIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsIlVpbnQ4QXJyYXkiLCJBcnJheSIsImNvZGUiLCJpIiwibGVuIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImdldExlbnMiLCJiNjQiLCJFcnJvciIsInZhbGlkTGVuIiwiaW5kZXhPZiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsInRtcCIsImFyciIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwic3RhcnQiLCJlbmQiLCJvdXRwdXQiLCJwdXNoIiwiam9pbiIsImV4dHJhQnl0ZXMiLCJwYXJ0cyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ /* eslint-disable no-proto */ \nconst base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/./node_modules/base64-js/index.js\");\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/./node_modules/ieee754/index.js\");\nconst customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" // eslint-disable-line dot-notation\n ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") // eslint-disable-line dot-notation\n : null;\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\nconst K_MAX_LENGTH = 0x7fffffff;\nexports.kMaxLength = K_MAX_LENGTH;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(\"This browser lacks typed array (Uint8Array) support which is required by \" + \"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n}\nfunction typedArraySupport() {\n    // Can typed array instances can be augmented?\n    try {\n        const arr = new Uint8Array(1);\n        const proto = {\n            foo: function() {\n                return 42;\n            }\n        };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty(Buffer.prototype, \"parent\", {\n    enumerable: true,\n    get: function() {\n        if (!Buffer.isBuffer(this)) return undefined;\n        return this.buffer;\n    }\n});\nObject.defineProperty(Buffer.prototype, \"offset\", {\n    enumerable: true,\n    get: function() {\n        if (!Buffer.isBuffer(this)) return undefined;\n        return this.byteOffset;\n    }\n});\nfunction createBuffer(length) {\n    if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n    }\n    // Return an augmented `Uint8Array` instance\n    const buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, Buffer.prototype);\n    return buf;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function Buffer(arg, encodingOrOffset, length) {\n    // Common case.\n    if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError('The \"string\" argument must be of type string. Received type number');\n        }\n        return allocUnsafe(arg);\n    }\n    return from(arg, encodingOrOffset, length);\n}\n_c = Buffer;\nBuffer.poolSize = 8192 // not used by this implementation\n;\nfunction from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") {\n        return fromString(value, encodingOrOffset);\n    }\n    if (ArrayBuffer.isView(value)) {\n        return fromArrayView(value);\n    }\n    if (value == null) {\n        throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof value);\n    }\n    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    if (typeof value === \"number\") {\n        throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    }\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value) {\n        return Buffer.from(valueOf, encodingOrOffset, length);\n    }\n    const b = fromObject(value);\n    if (b) return b;\n    if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n        return Buffer.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n    }\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ Buffer.from = function(value, encodingOrOffset, length) {\n    return from(value, encodingOrOffset, length);\n};\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf(Buffer, Uint8Array);\nfunction assertSize(size) {\n    if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be of type number');\n    } else if (size < 0) {\n        throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n    }\n}\nfunction alloc(size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(size);\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpreted as a start offset.\n        return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n    }\n    return createBuffer(size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ Buffer.alloc = function(size, fill, encoding) {\n    return alloc(size, fill, encoding);\n};\nfunction allocUnsafe(size) {\n    assertSize(size);\n    return createBuffer(size < 0 ? 0 : checked(size) | 0);\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ Buffer.allocUnsafe = function(size) {\n    return allocUnsafe(size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ Buffer.allocUnsafeSlow = function(size) {\n    return allocUnsafe(size);\n};\nfunction fromString(string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n    }\n    const length = byteLength(string, encoding) | 0;\n    let buf = createBuffer(length);\n    const actual = buf.write(string, encoding);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        buf = buf.slice(0, actual);\n    }\n    return buf;\n}\nfunction fromArrayLike(array) {\n    const length = array.length < 0 ? 0 : checked(array.length) | 0;\n    const buf = createBuffer(length);\n    for(let i = 0; i < length; i += 1){\n        buf[i] = array[i] & 255;\n    }\n    return buf;\n}\nfunction fromArrayView(arrayView) {\n    if (isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n    }\n    return fromArrayLike(arrayView);\n}\nfunction fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n    }\n    let buf;\n    if (byteOffset === undefined && length === undefined) {\n        buf = new Uint8Array(array);\n    } else if (length === undefined) {\n        buf = new Uint8Array(array, byteOffset);\n    } else {\n        buf = new Uint8Array(array, byteOffset, length);\n    }\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(buf, Buffer.prototype);\n    return buf;\n}\nfunction fromObject(obj) {\n    if (Buffer.isBuffer(obj)) {\n        const len = checked(obj.length) | 0;\n        const buf = createBuffer(len);\n        if (buf.length === 0) {\n            return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n    }\n    if (obj.length !== undefined) {\n        if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n        }\n        return fromArrayLike(obj);\n    }\n    if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data);\n    }\n}\nfunction checked(length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= K_MAX_LENGTH) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n    }\n    return length | 0;\n}\nfunction SlowBuffer(length) {\n    if (+length != length) {\n        length = 0;\n    }\n    return Buffer.alloc(+length);\n}\n_c1 = SlowBuffer;\nBuffer.isBuffer = function isBuffer(b) {\n    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n    ;\n};\nBuffer.compare = function compare(a, b) {\n    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n        throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    }\n    if (a === b) return 0;\n    let x = a.length;\n    let y = b.length;\n    for(let i = 0, len = Math.min(x, y); i < len; ++i){\n        if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\nBuffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return true;\n        default:\n            return false;\n    }\n};\nBuffer.concat = function concat(list, length) {\n    if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return Buffer.alloc(0);\n    }\n    let i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i){\n            length += list[i].length;\n        }\n    }\n    const buffer = Buffer.allocUnsafe(length);\n    let pos = 0;\n    for(i = 0; i < list.length; ++i){\n        let buf = list[i];\n        if (isInstance(buf, Uint8Array)) {\n            if (pos + buf.length > buffer.length) {\n                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);\n                buf.copy(buffer, pos);\n            } else {\n                Uint8Array.prototype.set.call(buffer, buf, pos);\n            }\n        } else if (!Buffer.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        } else {\n            buf.copy(buffer, pos);\n        }\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction byteLength(string, encoding) {\n    if (Buffer.isBuffer(string)) {\n        return string.length;\n    }\n    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n        throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + \"Received type \" + typeof string);\n    }\n    const len = string.length;\n    const mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0) return 0;\n    // Use a for loop to avoid recursion\n    let loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n                return len;\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return len * 2;\n            case \"hex\":\n                return len >>> 1;\n            case \"base64\":\n                return base64ToBytes(string).length;\n            default:\n                if (loweredCase) {\n                    return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n                    ;\n                }\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\nBuffer.byteLength = byteLength;\nfunction slowToString(encoding, start, end) {\n    let loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while(true){\n        switch(encoding){\n            case \"hex\":\n                return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Slice(this, start, end);\n            case \"ascii\":\n                return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Slice(this, start, end);\n            case \"base64\":\n                return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return utf16leSlice(this, start, end);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (encoding + \"\").toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true;\nfunction swap(b, n, m) {\n    const i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\nBuffer.prototype.swap16 = function swap16() {\n    const len = this.length;\n    if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    }\n    for(let i = 0; i < len; i += 2){\n        swap(this, i, i + 1);\n    }\n    return this;\n};\nBuffer.prototype.swap32 = function swap32() {\n    const len = this.length;\n    if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    }\n    for(let i = 0; i < len; i += 4){\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n    }\n    return this;\n};\nBuffer.prototype.swap64 = function swap64() {\n    const len = this.length;\n    if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    }\n    for(let i = 0; i < len; i += 8){\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n    }\n    return this;\n};\nBuffer.prototype.toString = function toString() {\n    const length = this.length;\n    if (length === 0) return \"\";\n    if (arguments.length === 0) return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n};\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\nBuffer.prototype.equals = function equals(b) {\n    if (!Buffer.isBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b) return true;\n    return Buffer.compare(this, b) === 0;\n};\nBuffer.prototype.inspect = function inspect() {\n    let str = \"\";\n    const max = exports.INSPECT_MAX_BYTES;\n    str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n    if (this.length > max) str += \" ... \";\n    return \"<Buffer \" + str + \">\";\n};\nif (customInspectSymbol) {\n    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n}\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (isInstance(target, Uint8Array)) {\n        target = Buffer.from(target, target.offset, target.byteLength);\n    }\n    if (!Buffer.isBuffer(target)) {\n        throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + \"Received type \" + typeof target);\n    }\n    if (start === undefined) {\n        start = 0;\n    }\n    if (end === undefined) {\n        end = target ? target.length : 0;\n    }\n    if (thisStart === undefined) {\n        thisStart = 0;\n    }\n    if (thisEnd === undefined) {\n        thisEnd = this.length;\n    }\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n    }\n    if (thisStart >= thisEnd && start >= end) {\n        return 0;\n    }\n    if (thisStart >= thisEnd) {\n        return -1;\n    }\n    if (start >= end) {\n        return 1;\n    }\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    let x = thisEnd - thisStart;\n    let y = end - start;\n    const len = Math.min(x, y);\n    const thisCopy = this.slice(thisStart, thisEnd);\n    const targetCopy = target.slice(start, end);\n    for(let i = 0; i < len; ++i){\n        if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff;\n    } else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000;\n    }\n    byteOffset = +byteOffset // Coerce to Number.\n    ;\n    if (numberIsNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (Buffer.isBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 0xFF // Search for a byte value [0-255]\n        ;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    let indexSize = 1;\n    let arrLength = arr.length;\n    let valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    let i;\n    if (dir) {\n        let foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++){\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            let found = true;\n            for(let j = 0; j < valLength; j++){\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    const remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    const strLen = string.length;\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    let i;\n    for(i = 0; i < length; ++i){\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === undefined) encoding = \"utf8\";\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    } else {\n        throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    }\n    const remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n    }\n    if (!encoding) encoding = \"utf8\";\n    let loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"hex\":\n                return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n                return asciiWrite(this, string, offset, length);\n            case \"base64\":\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return ucs2Write(this, string, offset, length);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n};\nBuffer.prototype.toJSON = function toJSON() {\n    return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n    } else {\n        return base64.fromByteArray(buf.slice(start, end));\n    }\n}\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    const res = [];\n    let i = start;\n    while(i < end){\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte;\n                    }\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction decodeCodePointsArray(codePoints) {\n    const len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n        ;\n    }\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    let res = \"\";\n    let i = 0;\n    while(i < len){\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}\nfunction asciiSlice(buf, start, end) {\n    let ret = \"\";\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i] & 0x7F);\n    }\n    return ret;\n}\nfunction latin1Slice(buf, start, end) {\n    let ret = \"\";\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}\nfunction hexSlice(buf, start, end) {\n    const len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    let out = \"\";\n    for(let i = start; i < end; ++i){\n        out += hexSliceLookupTable[buf[i]];\n    }\n    return out;\n}\nfunction utf16leSlice(buf, start, end) {\n    const bytes = buf.slice(start, end);\n    let res = \"\";\n    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n    for(let i = 0; i < bytes.length - 1; i += 2){\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}\nBuffer.prototype.slice = function slice(start, end) {\n    const len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) {\n        end = len;\n    }\n    if (end < start) end = start;\n    const newBuf = this.subarray(start, end);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(newBuf, Buffer.prototype);\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n}\nBuffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        checkOffset(offset, byteLength, this.length);\n    }\n    let val = this[offset + --byteLength];\n    let mul = 1;\n    while(byteLength > 0 && (mul *= 0x100)){\n        val += this[offset + --byteLength] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    return this[offset];\n};\nBuffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\nBuffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\nBuffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\nBuffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n    offset = offset >>> 0;\n    validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) {\n        boundsError(offset, this.length - 8);\n    }\n    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n    return BigInt(lo) + (BigInt(hi) << BigInt(32));\n});\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n    offset = offset >>> 0;\n    validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) {\n        boundsError(offset, this.length - 8);\n    }\n    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n    return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n});\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    let i = byteLength;\n    let mul = 1;\n    let val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100)){\n        val += this[offset + --i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    const val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    const val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n    offset = offset >>> 0;\n    validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) {\n        boundsError(offset, this.length - 8);\n    }\n    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow\n    );\n    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n});\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n    offset = offset >>> 0;\n    validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) {\n        boundsError(offset, this.length - 8);\n    }\n    const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n});\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, true, 23, 4);\n};\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, false, 23, 4);\n};\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, true, 52, 8);\n};\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, false, 52, 8);\n};\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n}\nBuffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let mul = 1;\n    let i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nBuffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\nBuffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\nBuffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n    return offset + 4;\n};\nBuffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\nfunction wrtBigUInt64LE(buf, value, offset, min, max) {\n    checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    return offset;\n}\nfunction wrtBigUInt64BE(buf, value, offset, min, max) {\n    checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset + 7] = lo;\n    lo = lo >> 8;\n    buf[offset + 6] = lo;\n    lo = lo >> 8;\n    buf[offset + 5] = lo;\n    lo = lo >> 8;\n    buf[offset + 4] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset + 3] = hi;\n    hi = hi >> 8;\n    buf[offset + 2] = hi;\n    hi = hi >> 8;\n    buf[offset + 1] = hi;\n    hi = hi >> 8;\n    buf[offset] = hi;\n    return offset + 8;\n}\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {\n    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n});\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {\n    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n});\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = 0;\n    let mul = 1;\n    let sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    let sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n    return offset + 4;\n};\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (value < 0) value = 0xffffffff + value + 1;\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {\n    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n});\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {\n    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n});\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    if (offset < 0) throw new RangeError(\"Index out of range\");\n}\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n};\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!Buffer.isBuffer(target)) throw new TypeError(\"argument should be a Buffer\");\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n    }\n    if (start < 0 || start >= this.length) throw new RangeError(\"Index out of range\");\n    if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    const len = end - start;\n    if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n        // Use built-in when available, missing from IE11\n        this.copyWithin(targetStart, start, end);\n    } else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n    }\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n        }\n        if (encoding !== undefined && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n                // Fast path: If `val` fits into a single byte, use that numeric value.\n                val = code;\n            }\n        }\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n    } else if (typeof val === \"boolean\") {\n        val = Number(val);\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    let i;\n    if (typeof val === \"number\") {\n        for(i = start; i < end; ++i){\n            this[i] = val;\n        }\n    } else {\n        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        }\n        for(i = 0; i < end - start; ++i){\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\n// CUSTOM ERRORS\n// =============\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {};\nfunction E(sym, getMessage, Base) {\n    errors[sym] = class NodeError extends Base {\n        get code() {\n            return sym;\n        }\n        set code(value) {\n            Object.defineProperty(this, \"code\", {\n                configurable: true,\n                enumerable: true,\n                value,\n                writable: true\n            });\n        }\n        toString() {\n            return \"\".concat(this.name, \" [\").concat(sym, \"]: \").concat(this.message);\n        }\n        constructor(){\n            super();\n            Object.defineProperty(this, \"message\", {\n                value: getMessage.apply(this, arguments),\n                writable: true,\n                configurable: true\n            });\n            // Add the error code to the name to include it in the stack trace.\n            this.name = \"\".concat(this.name, \" [\").concat(sym, \"]\");\n            // Access the stack to generate the error message including the error code\n            // from the name.\n            this.stack // eslint-disable-line no-unused-expressions\n            ;\n            // Reset the name to the actual name.\n            delete this.name;\n        }\n    };\n}\n_c2 = E;\nE(\"ERR_BUFFER_OUT_OF_BOUNDS\", function(name) {\n    if (name) {\n        return \"\".concat(name, \" is outside of buffer bounds\");\n    }\n    return \"Attempt to access memory outside buffer bounds\";\n}, RangeError);\nE(\"ERR_INVALID_ARG_TYPE\", function(name, actual) {\n    return 'The \"'.concat(name, '\" argument must be of type number. Received type ').concat(typeof actual);\n}, TypeError);\nE(\"ERR_OUT_OF_RANGE\", function(str, range, input) {\n    let msg = 'The value of \"'.concat(str, '\" is out of range.');\n    let received = input;\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n        received = addNumericalSeparator(String(input));\n    } else if (typeof input === \"bigint\") {\n        received = String(input);\n        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n            received = addNumericalSeparator(received);\n        }\n        received += \"n\";\n    }\n    msg += \" It must be \".concat(range, \". Received \").concat(received);\n    return msg;\n}, RangeError);\nfunction addNumericalSeparator(val) {\n    let res = \"\";\n    let i = val.length;\n    const start = val[0] === \"-\" ? 1 : 0;\n    for(; i >= start + 4; i -= 3){\n        res = \"_\".concat(val.slice(i - 3, i)).concat(res);\n    }\n    return \"\".concat(val.slice(0, i)).concat(res);\n}\n// CHECK FUNCTIONS\n// ===============\nfunction checkBounds(buf, offset, byteLength) {\n    validateNumber(offset, \"offset\");\n    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n        boundsError(offset, buf.length - (byteLength + 1));\n    }\n}\nfunction checkIntBI(value, min, max, buf, offset, byteLength) {\n    if (value > max || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        if (byteLength > 3) {\n            if (min === 0 || min === BigInt(0)) {\n                range = \">= 0\".concat(n, \" and < 2\").concat(n, \" ** \").concat((byteLength + 1) * 8).concat(n);\n            } else {\n                range = \">= -(2\".concat(n, \" ** \").concat((byteLength + 1) * 8 - 1).concat(n, \") and < 2 ** \") + \"\".concat((byteLength + 1) * 8 - 1).concat(n);\n            }\n        } else {\n            range = \">= \".concat(min).concat(n, \" and <= \").concat(max).concat(n);\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n    }\n    checkBounds(buf, offset, byteLength);\n}\nfunction validateNumber(value, name) {\n    if (typeof value !== \"number\") {\n        throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    }\n}\nfunction boundsError(value, length, type) {\n    if (Math.floor(value) !== value) {\n        validateNumber(value, type);\n        throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n    }\n    if (length < 0) {\n        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n    throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \">= \".concat(type ? 1 : 0, \" and <= \").concat(length), value);\n}\n// HELPER FUNCTIONS\n// ================\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\nfunction base64clean(str) {\n    // Node takes equal signs as end of the Base64 encoding\n    str = str.split(\"=\")[0];\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = str.trim().replace(INVALID_BASE64_RE, \"\");\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return \"\";\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0){\n        str = str + \"=\";\n    }\n    return str;\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    let codePoint;\n    const length = string.length;\n    let leadSurrogate = null;\n    const bytes = [];\n    for(let i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}\nfunction asciiToBytes(str) {\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i){\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xFF);\n    }\n    return byteArray;\n}\nfunction utf16leToBytes(str, units) {\n    let c, hi, lo;\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction base64ToBytes(str) {\n    return base64.toByteArray(base64clean(str));\n}\nfunction blitBuffer(src, dst, offset, length) {\n    let i;\n    for(i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance(obj, type) {\n    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n}\nfunction numberIsNaN(obj) {\n    // For IE11 support\n    return obj !== obj // eslint-disable-line no-self-compare\n    ;\n}\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = function() {\n    const alphabet = \"0123456789abcdef\";\n    const table = new Array(256);\n    for(let i = 0; i < 16; ++i){\n        const i16 = i * 16;\n        for(let j = 0; j < 16; ++j){\n            table[i16 + j] = alphabet[i] + alphabet[j];\n        }\n    }\n    return table;\n}();\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod(fn) {\n    return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n}\nfunction BufferBigIntNotDefined() {\n    throw new Error(\"BigInt not supported\");\n}\n_c3 = BufferBigIntNotDefined;\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"Buffer\");\n$RefreshReg$(_c1, \"SlowBuffer\");\n$RefreshReg$(_c2, \"E\");\n$RefreshReg$(_c3, \"BufferBigIntNotDefined\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0MsR0FDRCwyQkFBMkIsR0FFM0I7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxzQkFDSixPQUFRQyxXQUFXLGNBQWMsT0FBT0EsTUFBTSxDQUFDLE1BQU0sS0FBSyxXQUFZLG1DQUFtQztHQUNyR0EsTUFBTSxDQUFDLE1BQU0sQ0FBQyw4QkFBOEIsbUNBQW1DO0dBQy9FO0FBRU5DLGNBQWMsR0FBR0M7QUFDakJELGtCQUFrQixHQUFHRTtBQUNyQkYseUJBQXlCLEdBQUc7QUFFNUIsTUFBTUksZUFBZTtBQUNyQkosa0JBQWtCLEdBQUdJO0FBRXJCOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDREgsT0FBT0ssbUJBQW1CLEdBQUdDO0FBRTdCLElBQUksQ0FBQ04sT0FBT0ssbUJBQW1CLElBQUksT0FBT0UsWUFBWSxlQUNsRCxPQUFPQSxRQUFRQyxLQUFLLEtBQUssWUFBWTtJQUN2Q0QsUUFBUUMsS0FBSyxDQUNYLDhFQUNBO0FBRUo7QUFFQSxTQUFTRjtJQUNQLDhDQUE4QztJQUM5QyxJQUFJO1FBQ0YsTUFBTUcsTUFBTSxJQUFJQyxXQUFXO1FBQzNCLE1BQU1DLFFBQVE7WUFBRUMsS0FBSztnQkFBYyxPQUFPO1lBQUc7UUFBRTtRQUMvQ0MsT0FBT0MsY0FBYyxDQUFDSCxPQUFPRCxXQUFXSyxTQUFTO1FBQ2pERixPQUFPQyxjQUFjLENBQUNMLEtBQUtFO1FBQzNCLE9BQU9GLElBQUlHLEdBQUcsT0FBTztJQUN2QixFQUFFLE9BQU9JLEdBQUc7UUFDVixPQUFPO0lBQ1Q7QUFDRjtBQUVBSCxPQUFPSSxjQUFjLENBQUNqQixPQUFPZSxTQUFTLEVBQUUsVUFBVTtJQUNoREcsWUFBWTtJQUNaQyxLQUFLO1FBQ0gsSUFBSSxDQUFDbkIsT0FBT29CLFFBQVEsQ0FB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QUFJO0FBQ3hDO0FBQ0EsU0FBU3hNLFlBQWFGLEdBQUc7SUFDdkIsbUJBQW1CO0lBQ25CLE9BQU9BLFFBQVFBLElBQUksc0NBQXNDOztBQUMzRDtBQUVBLDRDQUE0QztBQUM1QyxtREFBbUQ7QUFDbkQsTUFBTXlHLHNCQUFzQjtJQUMxQixNQUFNNEgsV0FBVztJQUNqQixNQUFNQyxRQUFRLElBQUlsTyxNQUFNO0lBQ3hCLElBQUssSUFBSVAsSUFBSSxHQUFHQSxJQUFJLElBQUksRUFBRUEsRUFBRztRQUMzQixNQUFNME8sTUFBTTFPLElBQUk7UUFDaEIsSUFBSyxJQUFJd0UsSUFBSSxHQUFHQSxJQUFJLElBQUksRUFBRUEsRUFBRztZQUMzQmlLLEtBQUssQ0FBQ0MsTUFBTWxLLEVBQUUsR0FBR2dLLFFBQVEsQ0FBQ3hPLEVBQUUsR0FBR3dPLFFBQVEsQ0FBQ2hLLEVBQUU7UUFDNUM7SUFDRjtJQUNBLE9BQU9pSztBQUNUO0FBRUEseURBQXlEO0FBQ3pELFNBQVN2RyxtQkFBb0J5RyxFQUFFO0lBQzdCLE9BQU8sT0FBT2xHLFdBQVcsY0FBY21HLHlCQUF5QkQ7QUFDbEU7QUFFQSxTQUFTQztJQUNQLE1BQU0sSUFBSW5KLE1BQU07QUFDbEI7TUFGU21KIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanM/OTAxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiJdLCJuYW1lcyI6WyJiYXNlNjQiLCJyZXF1aXJlIiwiaWVlZTc1NCIsImN1c3RvbUluc3BlY3RTeW1ib2wiLCJTeW1ib2wiLCJleHBvcnRzIiwiQnVmZmVyIiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiS19NQVhfTEVOR1RIIiwia01heExlbmd0aCIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJ0eXBlZEFycmF5U3VwcG9ydCIsImNvbnNvbGUiLCJlcnJvciIsImFyciIsIlVpbnQ4QXJyYXkiLCJwcm90byIsImZvbyIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsImlzQnVmZmVyIiwidW5kZWZpbmVkIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImNyZWF0ZUJ1ZmZlciIsImxlbmd0aCIsIlJhbmdlRXJyb3IiLCJidWYiLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiVHlwZUVycm9yIiwiYWxsb2NVbnNhZmUiLCJmcm9tIiwicG9vbFNpemUiLCJ2YWx1ZSIsImZyb21TdHJpbmciLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImZyb21BcnJheVZpZXciLCJpc0luc3RhbmNlIiwiZnJvbUFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJ2YWx1ZU9mIiwiYiIsImZyb21PYmplY3QiLCJ0b1ByaW1pdGl2ZSIsImFzc2VydFNpemUiLCJzaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImJ5dGVMZW5ndGgiLCJhY3R1YWwiLCJ3cml0ZSIsInNsaWNlIiwiZnJvbUFycmF5TGlrZSIsImFycmF5IiwiaSIsImFycmF5VmlldyIsImNvcHkiLCJvYmoiLCJsZW4iLCJudW1iZXJJc05hTiIsInR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJkYXRhIiwidG9TdHJpbmciLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwiYSIsIm9mZnNldCIsIngiLCJ5IiwiTWF0aCIsIm1pbiIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwiY29uY2F0IiwibGlzdCIsInBvcyIsInNldCIsImNhbGwiLCJtdXN0TWF0Y2giLCJhcmd1bWVudHMiLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsInN0YXJ0IiwiZW5kIiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJuIiwibSIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImFwcGx5IiwidG9Mb2NhbGVTdHJpbmciLCJlcXVhbHMiLCJpbnNwZWN0Iiwic3RyIiwibWF4IiwicmVwbGFjZSIsInRyaW0iLCJ0YXJnZXQiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJ2YWwiLCJkaXIiLCJhcnJheUluZGV4T2YiLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImZvdW5kIiwiaiIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJOdW1iZXIiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZWQiLCJwYXJzZUludCIsInN1YnN0ciIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwiRXJyb3IiLCJ0b0pTT04iLCJfYXJyIiwiZnJvbUJ5dGVBcnJheSIsInJlcyIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJwdXNoIiwiZGVjb2RlQ29kZVBvaW50c0FycmF5IiwiTUFYX0FSR1VNRU5UU19MRU5HVEgiLCJjb2RlUG9pbnRzIiwiZnJvbUNoYXJDb2RlIiwicmV0Iiwib3V0IiwiaGV4U2xpY2VMb29rdXBUYWJsZSIsImJ5dGVzIiwibmV3QnVmIiwic3ViYXJyYXkiLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVaW50TEUiLCJyZWFkVUludExFIiwibm9Bc3NlcnQiLCJtdWwiLCJyZWFkVWludEJFIiwicmVhZFVJbnRCRSIsInJlYWRVaW50OCIsInJlYWRVSW50OCIsInJlYWRVaW50MTZMRSIsInJlYWRVSW50MTZMRSIsInJlYWRVaW50MTZCRSIsInJlYWRVaW50MzJMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVaW50MzJCRSIsInJlYWRVSW50MzJCRSIsInJlYWRCaWdVSW50NjRMRSIsImRlZmluZUJpZ0ludE1ldGhvZCIsInZhbGlkYXRlTnVtYmVyIiwiZmlyc3QiLCJsYXN0IiwiYm91bmRzRXJyb3IiLCJsbyIsImhpIiwiQmlnSW50IiwicmVhZEJpZ1VJbnQ2NEJFIiwicmVhZEludExFIiwicG93IiwicmVhZEludEJFIiwicmVhZEludDgiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQxNkJFIiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlYWRCaWdJbnQ2NExFIiwicmVhZEJpZ0ludDY0QkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVpbnRMRSIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVpbnRCRSIsIndyaXRlVUludEJFIiwid3JpdGVVaW50OCIsIndyaXRlVUludDgiLCJ3cml0ZVVpbnQxNkxFIiwid3JpdGVVSW50MTZMRSIsIndyaXRlVWludDE2QkUiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVaW50MzJMRSIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVpbnQzMkJFIiwid3JpdGVVSW50MzJCRSIsIndydEJpZ1VJbnQ2NExFIiwiY2hlY2tJbnRCSSIsIndydEJpZ1VJbnQ2NEJFIiwid3JpdGVCaWdVSW50NjRMRSIsIndyaXRlQmlnVUludDY0QkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwid3JpdGVCaWdJbnQ2NExFIiwid3JpdGVCaWdJbnQ2NEJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsImxpdHRsZUVuZGlhbiIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsImNvcHlXaXRoaW4iLCJjb2RlIiwiY2hhckNvZGVBdCIsImVycm9ycyIsIkUiLCJzeW0iLCJnZXRNZXNzYWdlIiwiQmFzZSIsIk5vZGVFcnJvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwibmFtZSIsIm1lc3NhZ2UiLCJjb25zdHJ1Y3RvciIsInN0YWNrIiwicmFuZ2UiLCJpbnB1dCIsIm1zZyIsInJlY2VpdmVkIiwiaXNJbnRlZ2VyIiwiYWJzIiwiYWRkTnVtZXJpY2FsU2VwYXJhdG9yIiwiY2hlY2tCb3VuZHMiLCJFUlJfT1VUX09GX1JBTkdFIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJmbG9vciIsIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzcGxpdCIsInVuaXRzIiwiSW5maW5pdHkiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiYyIsInRvQnl0ZUFycmF5Iiwic3JjIiwiZHN0IiwiYWxwaGFiZXQiLCJ0YWJsZSIsImkxNiIsImZuIiwiQnVmZmVyQmlnSW50Tm90RGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    if (e === 0) {\n        e = 1 - eBias;\n    } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n    } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\nexports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) {\n            value += rt / c;\n        } else {\n            value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}\n    buffer[offset + i - d] |= s * 128;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHVGQUF1RixHQUN2RkEsWUFBWSxHQUFHLFNBQVVFLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsTUFBTTtJQUN6RCxJQUFJQyxHQUFHQztJQUNQLElBQUlDLE9BQU8sU0FBVSxJQUFLSixPQUFPO0lBQ2pDLElBQUlLLE9BQU8sQ0FBQyxLQUFLRCxJQUFHLElBQUs7SUFDekIsSUFBSUUsUUFBUUQsUUFBUTtJQUNwQixJQUFJRSxRQUFRLENBQUM7SUFDYixJQUFJQyxJQUFJVCxPQUFRRSxTQUFTLElBQUs7SUFDOUIsSUFBSVEsSUFBSVYsT0FBTyxDQUFDLElBQUk7SUFDcEIsSUFBSVcsSUFBSWIsTUFBTSxDQUFDQyxTQUFTVSxFQUFFO0lBRTFCQSxLQUFLQztJQUVMUCxJQUFJUSxJQUFLLENBQUMsS0FBTSxDQUFDSCxLQUFLLElBQUs7SUFDM0JHLE1BQU8sQ0FBQ0g7SUFDUkEsU0FBU0g7SUFDVCxNQUFPRyxRQUFRLEdBQUdMLElBQUksSUFBSyxNQUFPTCxNQUFNLENBQUNDLFNBQVNVLEVBQUUsRUFBRUEsS0FBS0MsR0FBR0YsU0FBUyxFQUFHLENBQUM7SUFFM0VKLElBQUlELElBQUssQ0FBQyxLQUFNLENBQUNLLEtBQUssSUFBSztJQUMzQkwsTUFBTyxDQUFDSztJQUNSQSxTQUFTUDtJQUNULE1BQU9PLFFBQVEsR0FBR0osSUFBSSxJQUFLLE1BQU9OLE1BQU0sQ0FBQ0MsU0FBU1UsRUFBRSxFQUFFQSxLQUFLQyxHQUFHRixTQUFTLEVBQUcsQ0FBQztJQUUzRSxJQUFJTCxNQUFNLEdBQUc7UUFDWEEsSUFBSSxJQUFJSTtJQUNWLE9BQU8sSUFBSUosTUFBTUcsTUFBTTtRQUNyQixPQUFPRixJQUFJUSxNQUFPLENBQUNELElBQUksQ0FBQyxJQUFJLEtBQUtFO0lBQ25DLE9BQU87UUFDTFQsSUFBSUEsSUFBSVUsS0FBS0MsR0FBRyxDQUFDLEdBQUdkO1FBQ3BCRSxJQUFJQSxJQUFJSTtJQUNWO0lBQ0EsT0FBTyxDQUFDSSxJQUFJLENBQUMsSUFBSSxLQUFLUCxJQUFJVSxLQUFLQyxHQUFHLENBQUMsR0FBR1osSUFBSUY7QUFDNUM7QUFFQUwsYUFBYSxHQUFHLFNBQVVFLE1BQU0sRUFBRW1CLEtBQUssRUFBRWxCLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLE1BQU07SUFDakUsSUFBSUMsR0FBR0MsR0FBR2M7SUFDVixJQUFJYixPQUFPLFNBQVUsSUFBS0osT0FBTztJQUNqQyxJQUFJSyxPQUFPLENBQUMsS0FBS0QsSUFBRyxJQUFLO0lBQ3pCLElBQUlFLFFBQVFELFFBQVE7SUFDcEIsSUFBSWEsS0FBTWxCLFNBQVMsS0FBS2EsS0FBS0MsR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNRCxLQUFLQyxHQUFHLENBQUMsR0FBRyxDQUFDLE1BQU07SUFDOUQsSUFBSU4sSUFBSVQsT0FBTyxJQUFLRSxTQUFTO0lBQzdCLElBQUlRLElBQUlWLE9BQU8sSUFBSSxDQUFDO0lBQ3BCLElBQUlXLElBQUlNLFFBQVEsS0FBTUEsVUFBVSxLQUFLLElBQUlBLFFBQVEsSUFBSyxJQUFJO0lBRTFEQSxRQUFRSCxLQUFLTSxHQUFHLENBQUNIO0lBRWpCLElBQUlJLE1BQU1KLFVBQVVBLFVBQVVKLFVBQVU7UUFDdENULElBQUlpQixNQUFNSixTQUFTLElBQUk7UUFDdkJkLElBQUlHO0lBQ04sT0FBTztRQUNMSCxJQUFJVyxLQUFLUSxLQUFLLENBQUNSLEtBQUtTLEdBQUcsQ0FBQ04sU0FBU0gsS0FBS1UsR0FBRztRQUN6QyxJQUFJUCxRQUFTQyxDQUFBQSxJQUFJSixLQUFLQyxHQUFHLENBQUMsR0FBRyxDQUFDWixFQUFDLElBQUssR0FBRztZQUNyQ0E7WUFDQWUsS0FBSztRQUNQO1FBQ0EsSUFBSWYsSUFBSUksU0FBUyxHQUFHO1lBQ2xCVSxTQUFTRSxLQUFLRDtRQUNoQixPQUFPO1lBQ0xELFNBQVNFLEtBQUtMLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLElBQUlSO1FBQ2hDO1FBQ0EsSUFBSVUsUUFBUUMsS0FBSyxHQUFHO1lBQ2xCZjtZQUNBZSxLQUFLO1FBQ1A7UUFFQSxJQUFJZixJQUFJSSxTQUFTRCxNQUFNO1lBQ3JCRixJQUFJO1lBQ0pELElBQUlHO1FBQ04sT0FBTyxJQUFJSCxJQUFJSSxTQUFTLEdBQUc7WUFDekJILElBQUksQ0FBQyxRQUFTYyxJQUFLLEtBQUtKLEtBQUtDLEdBQUcsQ0FBQyxHQUFHZDtZQUNwQ0UsSUFBSUEsSUFBSUk7UUFDVixPQUFPO1lBQ0xILElBQUlhLFFBQVFILEtBQUtDLEdBQUcsQ0FBQyxHQUFHUixRQUFRLEtBQUtPLEtBQUtDLEdBQUcsQ0FBQyxHQUFHZDtZQUNqREUsSUFBSTtRQUNOO0lBQ0Y7SUFFQSxNQUFPRixRQUFRLEdBQUdILE1BQU0sQ0FBQ0MsU0FBU1UsRUFBRSxHQUFHTCxJQUFJLE1BQU1LLEtBQUtDLEdBQUdOLEtBQUssS0FBS0gsUUFBUSxFQUFHLENBQUM7SUFFL0VFLElBQUksS0FBTUYsT0FBUUc7SUFDbEJDLFFBQVFKO0lBQ1IsTUFBT0ksT0FBTyxHQUFHUCxNQUFNLENBQUNDLFNBQVNVLEVBQUUsR0FBR04sSUFBSSxNQUFNTSxLQUFLQyxHQUFHUCxLQUFLLEtBQUtFLFFBQVEsRUFBRyxDQUFDO0lBRTlFUCxNQUFNLENBQUNDLFNBQVNVLElBQUlDLEVBQUUsSUFBSUMsSUFBSTtBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz9lYmMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsInJlYWQiLCJidWZmZXIiLCJvZmZzZXQiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImUiLCJtIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwiaSIsImQiLCJzIiwiTmFOIiwiSW5maW5pdHkiLCJNYXRoIiwicG93Iiwid3JpdGUiLCJ2YWx1ZSIsImMiLCJydCIsImFicyIsImlzTmFOIiwiZmxvb3IiLCJsb2ciLCJMTjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ \nmodule.exports = function isBuffer(obj) {\n    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7QUFFREEsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLFNBQVVDLEdBQUc7SUFDckMsT0FBT0EsT0FBTyxRQUFRQSxJQUFJQyxXQUFXLElBQUksUUFDdkMsT0FBT0QsSUFBSUMsV0FBVyxDQUFDRixRQUFRLEtBQUssY0FBY0MsSUFBSUMsV0FBVyxDQUFDRixRQUFRLENBQUNDO0FBQy9FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanM/MTRlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiZcbiAgICB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImlzQnVmZmVyIiwib2JqIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/is-buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// shim for using process in browser\n\nvar process = module.exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar cachedSetTimeout;\nvar cachedClearTimeout;\nfunction defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n    while(len){\n        currentQueue = queue;\n        queue = [];\n        while(++queueIndex < len){\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nprocess.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for(var i = 1; i < arguments.length; i++){\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n_c = Item;\nItem.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\nprocess.title = \"browser\";\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = \"\"; // empty string to avoid regexp issues\nprocess.versions = {};\nfunction noop() {}\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\nprocess.listeners = function(name) {\n    return [];\n};\nprocess.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\nprocess.cwd = function() {\n    return \"/\";\n};\nprocess.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\nprocess.umask = function() {\n    return 0;\n};\nvar _c;\n$RefreshReg$(_c, \"Item\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0NBQW9DOztBQUNwQyxJQUFJQSxVQUFVQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQztBQUVoQywyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLCtFQUErRTtBQUMvRSw4REFBOEQ7QUFFOUQsSUFBSUM7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ0wsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCO0FBQ0EsU0FBU0M7SUFDTCxNQUFNLElBQUlELE1BQU07QUFDcEI7QUFDQztJQUNHLElBQUk7UUFDQSxJQUFJLE9BQU9FLGVBQWUsWUFBWTtZQUNsQ0wsbUJBQW1CSztRQUN2QixPQUFPO1lBQ0hMLG1CQUFtQkU7UUFDdkI7SUFDSixFQUFFLE9BQU9JLEdBQUc7UUFDUk4sbUJBQW1CRTtJQUN2QjtJQUNBLElBQUk7UUFDQSxJQUFJLE9BQU9LLGlCQUFpQixZQUFZO1lBQ3BDTixxQkFBcUJNO1FBQ3pCLE9BQU87WUFDSE4scUJBQXFCRztRQUN6QjtJQUNKLEVBQUUsT0FBT0UsR0FBRztRQUNSTCxxQkFBcUJHO0lBQ3pCO0FBQ0o7QUFDQSxTQUFTSSxXQUFXQyxHQUFHO0lBQ25CLElBQUlULHFCQUFxQkssWUFBWTtRQUNqQyx1Q0FBdUM7UUFDdkMsT0FBT0EsV0FBV0ksS0FBSztJQUMzQjtJQUNBLHdEQUF3RDtJQUN4RCxJQUFJLENBQUNULHFCQUFxQkUsb0JBQW9CLENBQUNGLGdCQUFlLEtBQU1LLFlBQVk7UUFDNUVMLG1CQUFtQks7UUFDbkIsT0FBT0EsV0FBV0ksS0FBSztJQUMzQjtJQUNBLElBQUk7UUFDQSxzRUFBc0U7UUFDdEUsT0FBT1QsaUJBQWlCUyxLQUFLO0lBQ2pDLEVBQUUsT0FBTUgsR0FBRTtRQUNOLElBQUk7WUFDQSxrSEFBa0g7WUFDbEgsT0FBT04saUJBQWlCVSxJQUFJLENBQUMsTUFBTUQsS0FBSztRQUM1QyxFQUFFLE9BQU1ILEdB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QyxRQUFRLEdBQUcsQ0FBQztBQUVwQixTQUFTQyxRQUFRO0FBRWpCM0MsUUFBUTRDLEVBQUUsR0FBR0Q7QUFDYjNDLFFBQVE2QyxXQUFXLEdBQUdGO0FBQ3RCM0MsUUFBUThDLElBQUksR0FBR0g7QUFDZjNDLFFBQVErQyxHQUFHLEdBQUdKO0FBQ2QzQyxRQUFRZ0QsY0FBYyxHQUFHTDtBQUN6QjNDLFFBQVFpRCxrQkFBa0IsR0FBR047QUFDN0IzQyxRQUFRa0QsSUFBSSxHQUFHUDtBQUNmM0MsUUFBUW1ELGVBQWUsR0FBR1I7QUFDMUIzQyxRQUFRb0QsbUJBQW1CLEdBQUdUO0FBRTlCM0MsUUFBUXFELFNBQVMsR0FBRyxTQUFVQyxJQUFJO0lBQUksT0FBTyxFQUFFO0FBQUM7QUFFaER0RCxRQUFRdUQsT0FBTyxHQUFHLFNBQVVELElBQUk7SUFDNUIsTUFBTSxJQUFJaEQsTUFBTTtBQUNwQjtBQUVBTixRQUFRd0QsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFJO0FBQ3ZDeEQsUUFBUXlELEtBQUssR0FBRyxTQUFVQyxHQUFHO0lBQ3pCLE1BQU0sSUFBSXBELE1BQU07QUFDcEI7QUFDQU4sUUFBUTJELEtBQUssR0FBRztJQUFhLE9BQU87QUFBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzVjYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImkiLCJwdXNoIiwiSXRlbSIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsIm5hbWUiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/retry/index.js":
/*!*************************************!*\
  !*** ./node_modules/retry/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! ./lib/retry */ \"(app-pages-browser)/./node_modules/retry/lib/retry.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXRyeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLGdIQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmV0cnkvaW5kZXguanM/NWMzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3JldHJ5Jyk7Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/retry/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/retry/lib/retry.js":
/*!*****************************************!*\
  !*** ./node_modules/retry/lib/retry.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var RetryOperation = __webpack_require__(/*! ./retry_operation */ \"(app-pages-browser)/./node_modules/retry/lib/retry_operation.js\");\nexports.operation = function(options) {\n    var timeouts = exports.timeouts(options);\n    return new RetryOperation(timeouts, {\n        forever: options && (options.forever || options.retries === Infinity),\n        unref: options && options.unref,\n        maxRetryTime: options && options.maxRetryTime\n    });\n};\nexports.timeouts = function(options) {\n    if (options instanceof Array) {\n        return [].concat(options);\n    }\n    var opts = {\n        retries: 10,\n        factor: 2,\n        minTimeout: 1 * 1000,\n        maxTimeout: Infinity,\n        randomize: false\n    };\n    for(var key in options){\n        opts[key] = options[key];\n    }\n    if (opts.minTimeout > opts.maxTimeout) {\n        throw new Error(\"minTimeout is greater than maxTimeout\");\n    }\n    var timeouts = [];\n    for(var i = 0; i < opts.retries; i++){\n        timeouts.push(this.createTimeout(i, opts));\n    }\n    if (options && options.forever && !timeouts.length) {\n        timeouts.push(this.createTimeout(i, opts));\n    }\n    // sort the array numerically ascending\n    timeouts.sort(function(a, b) {\n        return a - b;\n    });\n    return timeouts;\n};\nexports.createTimeout = function(attempt, opts) {\n    var random = opts.randomize ? Math.random() + 1 : 1;\n    var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n    timeout = Math.min(timeout, opts.maxTimeout);\n    return timeout;\n};\nexports.wrap = function(obj, options, methods) {\n    if (options instanceof Array) {\n        methods = options;\n        options = null;\n    }\n    if (!methods) {\n        methods = [];\n        for(var key in obj){\n            if (typeof obj[key] === \"function\") {\n                methods.push(key);\n            }\n        }\n    }\n    for(var i = 0; i < methods.length; i++){\n        var method = methods[i];\n        var original = obj[method];\n        obj[method] = (function retryWrapper(original) {\n            var op = exports.operation(options);\n            var args = Array.prototype.slice.call(arguments, 1);\n            var callback = args.pop();\n            args.push(function(err) {\n                if (op.retry(err)) {\n                    return;\n                }\n                if (err) {\n                    arguments[0] = op.mainError();\n                }\n                callback.apply(this, arguments);\n            });\n            op.attempt(function() {\n                original.apply(obj, args);\n            });\n        }).bind(obj, original);\n        obj[method].options = options;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnkuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsaUJBQWlCQyxtQkFBT0EsQ0FBQztBQUU3QkMsaUJBQWlCLEdBQUcsU0FBU0UsT0FBTztJQUNsQyxJQUFJQyxXQUFXSCxRQUFRRyxRQUFRLENBQUNEO0lBQ2hDLE9BQU8sSUFBSUosZUFBZUssVUFBVTtRQUNoQ0MsU0FBU0YsV0FBWUEsQ0FBQUEsUUFBUUUsT0FBTyxJQUFJRixRQUFRRyxPQUFPLEtBQUtDLFFBQU87UUFDbkVDLE9BQU9MLFdBQVdBLFFBQVFLLEtBQUs7UUFDL0JDLGNBQWNOLFdBQVdBLFFBQVFNLFlBQVk7SUFDakQ7QUFDRjtBQUVBUixnQkFBZ0IsR0FBRyxTQUFTRSxPQUFPO0lBQ2pDLElBQUlBLG1CQUFtQk8sT0FBTztRQUM1QixPQUFPLEVBQUUsQ0FBQ0MsTUFBTSxDQUFDUjtJQUNuQjtJQUVBLElBQUlTLE9BQU87UUFDVE4sU0FBUztRQUNUTyxRQUFRO1FBQ1JDLFlBQVksSUFBSTtRQUNoQkMsWUFBWVI7UUFDWlMsV0FBVztJQUNiO0lBQ0EsSUFBSyxJQUFJQyxPQUFPZCxRQUFTO1FBQ3ZCUyxJQUFJLENBQUNLLElBQUksR0FBR2QsT0FBTyxDQUFDYyxJQUFJO0lBQzFCO0lBRUEsSUFBSUwsS0FBS0UsVUFBVSxHQUFHRixLQUFLRyxVQUFVLEVBQUU7UUFDckMsTUFBTSxJQUFJRyxNQUFNO0lBQ2xCO0lBRUEsSUFBSWQsV0FBVyxFQUFFO0lBQ2pCLElBQUssSUFBSWUsSUFBSSxHQUFHQSxJQUFJUCxLQUFLTixPQUFPLEVBQUVhLElBQUs7UUFDckNmLFNBQVNnQixJQUFJLENBQUMsSUFBSSxDQUFDQyxhQUFhLENBQUNGLEdBQUdQO0lBQ3RDO0lBRUEsSUFBSVQsV0FBV0EsUUFBUUUsT0FBTyxJQUFJLENBQUNELFNBQVNrQixNQUFNLEVBQUU7UUFDbERsQixTQUFTZ0IsSUFBSSxDQUFDLElBQUksQ0FBQ0MsYUFBYSxDQUFDRixHQUFHUDtJQUN0QztJQUVBLHVDQUF1QztJQUN2Q1IsU0FBU21CLElBQUksQ0FBQyxTQUFTQyxDQUFDLEVBQUNDLENBQUM7UUFDeEIsT0FBT0QsSUFBSUM7SUFDYjtJQUVBLE9BQU9yQjtBQUNUO0FBRUFILHFCQUFxQixHQUFHLFNBQVN5QixPQUFPLEVBQUVkLElBQUk7SUFDNUMsSUFBSWUsU0FBUyxLQUFNWCxTQUFTLEdBQ3ZCWSxLQUFLRCxNQUFNLEtBQUssSUFDakI7SUFFSixJQUFJRSxVQUFVRCxLQUFLRSxLQUFLLENBQUNILFNBQVNDLEtBQUtHLEdBQUcsQ0FBQ25CLEtBQUtFLFVBQVUsRUFBRSxLQUFLYyxLQUFLSSxHQUFHLENBQUNwQixLQUFLQyxNQUFNLEVBQUVhO0lBQ3ZGRyxVQUFVRCxLQUFLSyxHQUFHLENBQUNKLFNBQVNqQixLQUFLRyxVQUFVO0lBRTNDLE9BQU9jO0FBQ1Q7QUFFQTVCLFlBQVksR0FBRyxTQUFTa0MsR0FBRyxFQUFFaEMsT0FBTyxFQUFFaUMsT0FBTztJQUMzQyxJQUFJakMsbUJBQW1CTyxPQUFPO1FBQzVCMEIsVUFBVWpDO1FBQ1ZBLFVBQVU7SUFDWjtJQUVBLElBQUksQ0FBQ2lDLFNBQVM7UUFDWkEsVUFBVSxFQUFFO1FBQ1osSUFBSyxJQUFJbkIsT0FBT2tCLElBQUs7WUFDbkIsSUFBSSxPQUFPQSxHQUFHLENBQUNsQixJQUFJLEtBQUssWUFBWTtnQkFDbENtQixRQUFRaEIsSUFBSSxDQUFDSDtZQUNmO1FBQ0Y7SUFDRjtJQUVBLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJaUIsUUFBUWQsTUFBTSxFQUFFSCxJQUFLO1FBQ3ZDLElBQUlrQixTQUFXRCxPQUFPLENBQUNqQixFQUFFO1FBQ3pCLElBQUltQixXQUFXSCxHQUFHLENBQUNFLE9BQU87UUFFMUJGLEdBQUcsQ0FBQ0UsT0FBTyxHQUFHLFVBQVNFLGFBQWFELFFBQVE7WUFDMUMsSUFBSUUsS0FBV3ZDLFFBQVFDLFNBQVMsQ0FBQ0M7WUFDakMsSUFBSXNDLE9BQVcvQixNQUFNZ0MsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ0MsV0FBVztZQUNyRCxJQUFJQyxXQUFXTCxLQUFLTSxHQUFHO1lBRXZCTixLQUFLckIsSUFBSSxDQUFDLFNBQVM0QixHQUFHO2dCQUNwQixJQUFJUixHQUFHUyxLQUFLLENBQUNELE1BQU07b0JBQ2pCO2dCQUNGO2dCQUNBLElBQUlBLEtBQUs7b0JBQ1BILFNBQVMsQ0FBQyxFQUFFLEdBQUdMLEdBQUdVLFNBQVM7Z0JBQzdCO2dCQUNBSixTQUFTSyxLQUFLLENBQUMsSUFBSSxFQUFFTjtZQUN2QjtZQUVBTCxHQUFHZCxPQUFPLENBQUM7Z0JBQ1RZLFNBQVNhLEtBQUssQ0FBQ2hCLEtBQUtNO1lBQ3RCO1FBQ0YsR0FBRVcsSUFBSSxDQUFDakIsS0FBS0c7UUFDWkgsR0FBRyxDQUFDRSxPQUFPLENBQUNsQyxPQUFPLEdBQUdBO0lBQ3hCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JldHJ5L2xpYi9yZXRyeS5qcz84OTkwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBSZXRyeU9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vcmV0cnlfb3BlcmF0aW9uJyk7XG5cbmV4cG9ydHMub3BlcmF0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgdGltZW91dHMgPSBleHBvcnRzLnRpbWVvdXRzKG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IFJldHJ5T3BlcmF0aW9uKHRpbWVvdXRzLCB7XG4gICAgICBmb3JldmVyOiBvcHRpb25zICYmIChvcHRpb25zLmZvcmV2ZXIgfHwgb3B0aW9ucy5yZXRyaWVzID09PSBJbmZpbml0eSksXG4gICAgICB1bnJlZjogb3B0aW9ucyAmJiBvcHRpb25zLnVucmVmLFxuICAgICAgbWF4UmV0cnlUaW1lOiBvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cnlUaW1lXG4gIH0pO1xufTtcblxuZXhwb3J0cy50aW1lb3V0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiBbXS5jb25jYXQob3B0aW9ucyk7XG4gIH1cblxuICB2YXIgb3B0cyA9IHtcbiAgICByZXRyaWVzOiAxMCxcbiAgICBmYWN0b3I6IDIsXG4gICAgbWluVGltZW91dDogMSAqIDEwMDAsXG4gICAgbWF4VGltZW91dDogSW5maW5pdHksXG4gICAgcmFuZG9taXplOiBmYWxzZVxuICB9O1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgIG9wdHNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIGlmIChvcHRzLm1pblRpbWVvdXQgPiBvcHRzLm1heFRpbWVvdXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pblRpbWVvdXQgaXMgZ3JlYXRlciB0aGFuIG1heFRpbWVvdXQnKTtcbiAgfVxuXG4gIHZhciB0aW1lb3V0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdHMucmV0cmllczsgaSsrKSB7XG4gICAgdGltZW91dHMucHVzaCh0aGlzLmNyZWF0ZVRpbWVvdXQoaSwgb3B0cykpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JldmVyICYmICF0aW1lb3V0cy5sZW5ndGgpIHtcbiAgICB0aW1lb3V0cy5wdXNoKHRoaXMuY3JlYXRlVGltZW91dChpLCBvcHRzKSk7XG4gIH1cblxuICAvLyBzb3J0IHRoZSBhcnJheSBudW1lcmljYWxseSBhc2NlbmRpbmdcbiAgdGltZW91dHMuc29ydChmdW5jdGlvbihhLGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuXG4gIHJldHVybiB0aW1lb3V0cztcbn07XG5cbmV4cG9ydHMuY3JlYXRlVGltZW91dCA9IGZ1bmN0aW9uKGF0dGVtcHQsIG9wdHMpIHtcbiAgdmFyIHJhbmRvbSA9IChvcHRzLnJhbmRvbWl6ZSlcbiAgICA/IChNYXRoLnJhbmRvbSgpICsgMSlcbiAgICA6IDE7XG5cbiAgdmFyIHRpbWVvdXQgPSBNYXRoLnJvdW5kKHJhbmRvbSAqIE1hdGgubWF4KG9wdHMubWluVGltZW91dCwgMSkgKiBNYXRoLnBvdyhvcHRzLmZhY3RvciwgYXR0ZW1wdCkpO1xuICB0aW1lb3V0ID0gTWF0aC5taW4odGltZW91dCwgb3B0cy5tYXhUaW1lb3V0KTtcblxuICByZXR1cm4gdGltZW91dDtcbn07XG5cbmV4cG9ydHMud3JhcCA9IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucywgbWV0aG9kcykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgbWV0aG9kcyA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoIW1ldGhvZHMpIHtcbiAgICBtZXRob2RzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtZXRob2RzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWV0aG9kICAgPSBtZXRob2RzW2ldO1xuICAgIHZhciBvcmlnaW5hbCA9IG9ialttZXRob2RdO1xuXG4gICAgb2JqW21ldGhvZF0gPSBmdW5jdGlvbiByZXRyeVdyYXBwZXIob3JpZ2luYWwpIHtcbiAgICAgIHZhciBvcCAgICAgICA9IGV4cG9ydHMub3BlcmF0aW9uKG9wdGlvbnMpO1xuICAgICAgdmFyIGFyZ3MgICAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG5cbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKG9wLnJldHJ5KGVycikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG9wLm1haW5FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgICAgb3AuYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgb3JpZ2luYWwuYXBwbHkob2JqLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0uYmluZChvYmosIG9yaWdpbmFsKTtcbiAgICBvYmpbbWV0aG9kXS5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJSZXRyeU9wZXJhdGlvbiIsInJlcXVpcmUiLCJleHBvcnRzIiwib3BlcmF0aW9uIiwib3B0aW9ucyIsInRpbWVvdXRzIiwiZm9yZXZlciIsInJldHJpZXMiLCJJbmZpbml0eSIsInVucmVmIiwibWF4UmV0cnlUaW1lIiwiQXJyYXkiLCJjb25jYXQiLCJvcHRzIiwiZmFjdG9yIiwibWluVGltZW91dCIsIm1heFRpbWVvdXQiLCJyYW5kb21pemUiLCJrZXkiLCJFcnJvciIsImkiLCJwdXNoIiwiY3JlYXRlVGltZW91dCIsImxlbmd0aCIsInNvcnQiLCJhIiwiYiIsImF0dGVtcHQiLCJyYW5kb20iLCJNYXRoIiwidGltZW91dCIsInJvdW5kIiwibWF4IiwicG93IiwibWluIiwid3JhcCIsIm9iaiIsIm1ldGhvZHMiLCJtZXRob2QiLCJvcmlnaW5hbCIsInJldHJ5V3JhcHBlciIsIm9wIiwiYXJncyIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsImNhbGxiYWNrIiwicG9wIiwiZXJyIiwicmV0cnkiLCJtYWluRXJyb3IiLCJhcHBseSIsImJpbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/retry/lib/retry.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/retry/lib/retry_operation.js":
/*!***************************************************!*\
  !*** ./node_modules/retry/lib/retry_operation.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction RetryOperation(timeouts, options) {\n    // Compatibility for the old (timeouts, retryForever) signature\n    if (typeof options === \"boolean\") {\n        options = {\n            forever: options\n        };\n    }\n    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n    this._timeouts = timeouts;\n    this._options = options || {};\n    this._maxRetryTime = options && options.maxRetryTime || Infinity;\n    this._fn = null;\n    this._errors = [];\n    this._attempts = 1;\n    this._operationTimeout = null;\n    this._operationTimeoutCb = null;\n    this._timeout = null;\n    this._operationStart = null;\n    this._timer = null;\n    if (this._options.forever) {\n        this._cachedTimeouts = this._timeouts.slice(0);\n    }\n}\n_c = RetryOperation;\nmodule.exports = RetryOperation;\nRetryOperation.prototype.reset = function() {\n    this._attempts = 1;\n    this._timeouts = this._originalTimeouts.slice(0);\n};\nRetryOperation.prototype.stop = function() {\n    if (this._timeout) {\n        clearTimeout(this._timeout);\n    }\n    if (this._timer) {\n        clearTimeout(this._timer);\n    }\n    this._timeouts = [];\n    this._cachedTimeouts = null;\n};\nRetryOperation.prototype.retry = function(err) {\n    if (this._timeout) {\n        clearTimeout(this._timeout);\n    }\n    if (!err) {\n        return false;\n    }\n    var currentTime = new Date().getTime();\n    if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n        this._errors.push(err);\n        this._errors.unshift(new Error(\"RetryOperation timeout occurred\"));\n        return false;\n    }\n    this._errors.push(err);\n    var timeout = this._timeouts.shift();\n    if (timeout === undefined) {\n        if (this._cachedTimeouts) {\n            // retry forever, only keep last error\n            this._errors.splice(0, this._errors.length - 1);\n            timeout = this._cachedTimeouts.slice(-1);\n        } else {\n            return false;\n        }\n    }\n    var self = this;\n    this._timer = setTimeout(function() {\n        self._attempts++;\n        if (self._operationTimeoutCb) {\n            self._timeout = setTimeout(function() {\n                self._operationTimeoutCb(self._attempts);\n            }, self._operationTimeout);\n            if (self._options.unref) {\n                self._timeout.unref();\n            }\n        }\n        self._fn(self._attempts);\n    }, timeout);\n    if (this._options.unref) {\n        this._timer.unref();\n    }\n    return true;\n};\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n    this._fn = fn;\n    if (timeoutOps) {\n        if (timeoutOps.timeout) {\n            this._operationTimeout = timeoutOps.timeout;\n        }\n        if (timeoutOps.cb) {\n            this._operationTimeoutCb = timeoutOps.cb;\n        }\n    }\n    var self = this;\n    if (this._operationTimeoutCb) {\n        this._timeout = setTimeout(function() {\n            self._operationTimeoutCb();\n        }, self._operationTimeout);\n    }\n    this._operationStart = new Date().getTime();\n    this._fn(this._attempts);\n};\nRetryOperation.prototype.try = function(fn) {\n    console.log(\"Using RetryOperation.try() is deprecated\");\n    this.attempt(fn);\n};\nRetryOperation.prototype.start = function(fn) {\n    console.log(\"Using RetryOperation.start() is deprecated\");\n    this.attempt(fn);\n};\nRetryOperation.prototype.start = RetryOperation.prototype.try;\nRetryOperation.prototype.errors = function() {\n    return this._errors;\n};\nRetryOperation.prototype.attempts = function() {\n    return this._attempts;\n};\nRetryOperation.prototype.mainError = function() {\n    if (this._errors.length === 0) {\n        return null;\n    }\n    var counts = {};\n    var mainError = null;\n    var mainErrorCount = 0;\n    for(var i = 0; i < this._errors.length; i++){\n        var error = this._errors[i];\n        var message = error.message;\n        var count = (counts[message] || 0) + 1;\n        counts[message] = count;\n        if (count >= mainErrorCount) {\n            mainError = error;\n            mainErrorCount = count;\n        }\n    }\n    return mainError;\n};\nvar _c;\n$RefreshReg$(_c, \"RetryOperation\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnlfb3BlcmF0aW9uLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxTQUFTQSxlQUFlQyxRQUFRLEVBQUVDLE9BQU87SUFDdkMsK0RBQStEO0lBQy9ELElBQUksT0FBT0EsWUFBWSxXQUFXO1FBQ2hDQSxVQUFVO1lBQUVDLFNBQVNEO1FBQVE7SUFDL0I7SUFFQSxJQUFJLENBQUNFLGlCQUFpQixHQUFHQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLFNBQVMsQ0FBQ047SUFDbkQsSUFBSSxDQUFDTyxTQUFTLEdBQUdQO0lBQ2pCLElBQUksQ0FBQ1EsUUFBUSxHQUFHUCxXQUFXLENBQUM7SUFDNUIsSUFBSSxDQUFDUSxhQUFhLEdBQUdSLFdBQVdBLFFBQVFTLFlBQVksSUFBSUM7SUFDeEQsSUFBSSxDQUFDQyxHQUFHLEdBQUc7SUFDWCxJQUFJLENBQUNDLE9BQU8sR0FBRyxFQUFFO0lBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO0lBQ2pCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7SUFDekIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztJQUMzQixJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNoQixJQUFJLENBQUNDLGVBQWUsR0FBRztJQUN2QixJQUFJLENBQUNDLE1BQU0sR0FBRztJQUVkLElBQUksSUFBSSxDQUFDWCxRQUFRLENBQUNOLE9BQU8sRUFBRTtRQUN6QixJQUFJLENBQUNrQixlQUFlLEdBQUcsSUFBSSxDQUFDYixTQUFTLENBQUNjLEtBQUssQ0FBQztJQUM5QztBQUNGO0tBdEJTdEI7QUF1QlR1QixPQUFPQyxPQUFPLEdBQUd4QjtBQUVqQkEsZUFBZXlCLFNBQVMsQ0FBQ0MsS0FBSyxHQUFHO0lBQy9CLElBQUksQ0FBQ1gsU0FBUyxHQUFHO0lBQ2pCLElBQUksQ0FBQ1AsU0FBUyxHQUFHLElBQUksQ0FBQ0osaUJBQWlCLENBQUNrQixLQUFLLENBQUM7QUFDaEQ7QUFFQXRCLGVBQWV5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Olsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmV0cnkvbGliL3JldHJ5X29wZXJhdGlvbi5qcz9iYTIyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFJldHJ5T3BlcmF0aW9uKHRpbWVvdXRzLCBvcHRpb25zKSB7XG4gIC8vIENvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgKHRpbWVvdXRzLCByZXRyeUZvcmV2ZXIpIHNpZ25hdHVyZVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMgPSB7IGZvcmV2ZXI6IG9wdGlvbnMgfTtcbiAgfVxuXG4gIHRoaXMuX29yaWdpbmFsVGltZW91dHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRpbWVvdXRzKSk7XG4gIHRoaXMuX3RpbWVvdXRzID0gdGltZW91dHM7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9tYXhSZXRyeVRpbWUgPSBvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cnlUaW1lIHx8IEluZmluaXR5O1xuICB0aGlzLl9mbiA9IG51bGw7XG4gIHRoaXMuX2Vycm9ycyA9IFtdO1xuICB0aGlzLl9hdHRlbXB0cyA9IDE7XG4gIHRoaXMuX29wZXJhdGlvblRpbWVvdXQgPSBudWxsO1xuICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0Q2IgPSBudWxsO1xuICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgdGhpcy5fb3BlcmF0aW9uU3RhcnQgPSBudWxsO1xuICB0aGlzLl90aW1lciA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZm9yZXZlcikge1xuICAgIHRoaXMuX2NhY2hlZFRpbWVvdXRzID0gdGhpcy5fdGltZW91dHMuc2xpY2UoMCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUmV0cnlPcGVyYXRpb247XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9hdHRlbXB0cyA9IDE7XG4gIHRoaXMuX3RpbWVvdXRzID0gdGhpcy5fb3JpZ2luYWxUaW1lb3V0cy5zbGljZSgwKTtcbn1cblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gIH1cbiAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgfVxuXG4gIHRoaXMuX3RpbWVvdXRzICAgICAgID0gW107XG4gIHRoaXMuX2NhY2hlZFRpbWVvdXRzID0gbnVsbDtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgfVxuXG4gIGlmICghZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBpZiAoZXJyICYmIGN1cnJlbnRUaW1lIC0gdGhpcy5fb3BlcmF0aW9uU3RhcnQgPj0gdGhpcy5fbWF4UmV0cnlUaW1lKSB7XG4gICAgdGhpcy5fZXJyb3JzLnB1c2goZXJyKTtcbiAgICB0aGlzLl9lcnJvcnMudW5zaGlmdChuZXcgRXJyb3IoJ1JldHJ5T3BlcmF0aW9uIHRpbWVvdXQgb2NjdXJyZWQnKSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhpcy5fZXJyb3JzLnB1c2goZXJyKTtcblxuICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRzLnNoaWZ0KCk7XG4gIGlmICh0aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkVGltZW91dHMpIHtcbiAgICAgIC8vIHJldHJ5IGZvcmV2ZXIsIG9ubHkga2VlcCBsYXN0IGVycm9yXG4gICAgICB0aGlzLl9lcnJvcnMuc3BsaWNlKDAsIHRoaXMuX2Vycm9ycy5sZW5ndGggLSAxKTtcbiAgICAgIHRpbWVvdXQgPSB0aGlzLl9jYWNoZWRUaW1lb3V0cy5zbGljZSgtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9hdHRlbXB0cysrO1xuXG4gICAgaWYgKHNlbGYuX29wZXJhdGlvblRpbWVvdXRDYikge1xuICAgICAgc2VsZi5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuX29wZXJhdGlvblRpbWVvdXRDYihzZWxmLl9hdHRlbXB0cyk7XG4gICAgICB9LCBzZWxmLl9vcGVyYXRpb25UaW1lb3V0KTtcblxuICAgICAgaWYgKHNlbGYuX29wdGlvbnMudW5yZWYpIHtcbiAgICAgICAgICBzZWxmLl90aW1lb3V0LnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5fZm4oc2VsZi5fYXR0ZW1wdHMpO1xuICB9LCB0aW1lb3V0KTtcblxuICBpZiAodGhpcy5fb3B0aW9ucy51bnJlZikge1xuICAgICAgdGhpcy5fdGltZXIudW5yZWYoKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLmF0dGVtcHQgPSBmdW5jdGlvbihmbiwgdGltZW91dE9wcykge1xuICB0aGlzLl9mbiA9IGZuO1xuXG4gIGlmICh0aW1lb3V0T3BzKSB7XG4gICAgaWYgKHRpbWVvdXRPcHMudGltZW91dCkge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uVGltZW91dCA9IHRpbWVvdXRPcHMudGltZW91dDtcbiAgICB9XG4gICAgaWYgKHRpbWVvdXRPcHMuY2IpIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYiA9IHRpbWVvdXRPcHMuY2I7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5fb3BlcmF0aW9uVGltZW91dENiKSB7XG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9vcGVyYXRpb25UaW1lb3V0Q2IoKTtcbiAgICB9LCBzZWxmLl9vcGVyYXRpb25UaW1lb3V0KTtcbiAgfVxuXG4gIHRoaXMuX29wZXJhdGlvblN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgdGhpcy5fZm4odGhpcy5fYXR0ZW1wdHMpO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnRyeSA9IGZ1bmN0aW9uKGZuKSB7XG4gIGNvbnNvbGUubG9nKCdVc2luZyBSZXRyeU9wZXJhdGlvbi50cnkoKSBpcyBkZXByZWNhdGVkJyk7XG4gIHRoaXMuYXR0ZW1wdChmbik7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihmbikge1xuICBjb25zb2xlLmxvZygnVXNpbmcgUmV0cnlPcGVyYXRpb24uc3RhcnQoKSBpcyBkZXByZWNhdGVkJyk7XG4gIHRoaXMuYXR0ZW1wdChmbik7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUudHJ5O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuZXJyb3JzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lcnJvcnM7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuYXR0ZW1wdHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2F0dGVtcHRzO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLm1haW5FcnJvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNvdW50cyA9IHt9O1xuICB2YXIgbWFpbkVycm9yID0gbnVsbDtcbiAgdmFyIG1haW5FcnJvckNvdW50ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Vycm9ycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlcnJvciA9IHRoaXMuX2Vycm9yc1tpXTtcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgdmFyIGNvdW50ID0gKGNvdW50c1ttZXNzYWdlXSB8fCAwKSArIDE7XG5cbiAgICBjb3VudHNbbWVzc2FnZV0gPSBjb3VudDtcblxuICAgIGlmIChjb3VudCA+PSBtYWluRXJyb3JDb3VudCkge1xuICAgICAgbWFpbkVycm9yID0gZXJyb3I7XG4gICAgICBtYWluRXJyb3JDb3VudCA9IGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYWluRXJyb3I7XG59O1xuIl0sIm5hbWVzIjpbIlJldHJ5T3BlcmF0aW9uIiwidGltZW91dHMiLCJvcHRpb25zIiwiZm9yZXZlciIsIl9vcmlnaW5hbFRpbWVvdXRzIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiX3RpbWVvdXRzIiwiX29wdGlvbnMiLCJfbWF4UmV0cnlUaW1lIiwibWF4UmV0cnlUaW1lIiwiSW5maW5pdHkiLCJfZm4iLCJfZXJyb3JzIiwiX2F0dGVtcHRzIiwiX29wZXJhdGlvblRpbWVvdXQiLCJfb3BlcmF0aW9uVGltZW91dENiIiwiX3RpbWVvdXQiLCJfb3BlcmF0aW9uU3RhcnQiLCJfdGltZXIiLCJfY2FjaGVkVGltZW91dHMiLCJzbGljZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJwcm90b3R5cGUiLCJyZXNldCIsInN0b3AiLCJjbGVhclRpbWVvdXQiLCJyZXRyeSIsImVyciIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsImdldFRpbWUiLCJwdXNoIiwidW5zaGlmdCIsIkVycm9yIiwidGltZW91dCIsInNoaWZ0IiwidW5kZWZpbmVkIiwic3BsaWNlIiwibGVuZ3RoIiwic2VsZiIsInNldFRpbWVvdXQiLCJ1bnJlZiIsImF0dGVtcHQiLCJmbiIsInRpbWVvdXRPcHMiLCJjYiIsInRyeSIsImNvbnNvbGUiLCJsb2ciLCJzdGFydCIsImVycm9ycyIsImF0dGVtcHRzIiwibWFpbkVycm9yIiwiY291bnRzIiwibWFpbkVycm9yQ291bnQiLCJpIiwiZXJyb3IiLCJtZXNzYWdlIiwiY291bnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/retry/lib/retry_operation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/throttleit/index.js":
/*!******************************************!*\
  !*** ./node_modules/throttleit/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction throttle(function_, wait) {\n    if (typeof function_ !== \"function\") {\n        throw new TypeError(\"Expected the first argument to be a `function`, got `\".concat(typeof function_, \"`.\"));\n    }\n    // TODO: Add `wait` validation too in the next major version.\n    let timeoutId;\n    let lastCallTime = 0;\n    return function throttled() {\n        for(var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++){\n            arguments_[_key] = arguments[_key];\n        }\n        clearTimeout(timeoutId);\n        const now = Date.now();\n        const timeSinceLastCall = now - lastCallTime;\n        const delayForNextCall = wait - timeSinceLastCall;\n        if (delayForNextCall <= 0) {\n            lastCallTime = now;\n            function_.apply(this, arguments_);\n        } else {\n            timeoutId = setTimeout(()=>{\n                lastCallTime = Date.now();\n                function_.apply(this, arguments_);\n            }, delayForNextCall);\n        }\n    };\n}\nmodule.exports = throttle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJvdHRsZWl0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxTQUFTQSxTQUFTQyxTQUFTLEVBQUVDLElBQUk7SUFDaEMsSUFBSSxPQUFPRCxjQUFjLFlBQVk7UUFDcEMsTUFBTSxJQUFJRSxVQUFVLHdEQUE0RSxPQUFqQixPQUFPRixXQUFVO0lBQ2pHO0lBRUEsNkRBQTZEO0lBRTdELElBQUlHO0lBQ0osSUFBSUMsZUFBZTtJQUVuQixPQUFPLFNBQVNDO1FBQVU7WUFBR0MsV0FBSCx1QkFBYTs7UUFDdENDLGFBQWFKO1FBRWIsTUFBTUssTUFBTUMsS0FBS0QsR0FBRztRQUNwQixNQUFNRSxvQkFBb0JGLE1BQU1KO1FBQ2hDLE1BQU1PLG1CQUFtQlYsT0FBT1M7UUFFaEMsSUFBSUMsb0JBQW9CLEdBQUc7WUFDMUJQLGVBQWVJO1lBQ2ZSLFVBQVVZLEtBQUssQ0FBQyxJQUFJLEVBQUVOO1FBQ3ZCLE9BQU87WUFDTkgsWUFBWVUsV0FBVztnQkFDdEJULGVBQWVLLEtBQUtELEdBQUc7Z0JBQ3ZCUixVQUFVWSxLQUFLLENBQUMsSUFBSSxFQUFFTjtZQUN2QixHQUFHSztRQUNKO0lBQ0Q7QUFDRDtBQUVBRyxPQUFPQyxPQUFPLEdBQUdoQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyb3R0bGVpdC9pbmRleC5qcz83ZGM4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHRocm90dGxlKGZ1bmN0aW9uXywgd2FpdCkge1xuXHRpZiAodHlwZW9mIGZ1bmN0aW9uXyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhIFxcYGZ1bmN0aW9uXFxgLCBnb3QgXFxgJHt0eXBlb2YgZnVuY3Rpb25ffVxcYC5gKTtcblx0fVxuXG5cdC8vIFRPRE86IEFkZCBgd2FpdGAgdmFsaWRhdGlvbiB0b28gaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cblxuXHRsZXQgdGltZW91dElkO1xuXHRsZXQgbGFzdENhbGxUaW1lID0gMDtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdGhyb3R0bGVkKC4uLmFyZ3VtZW50c18pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWVzXG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cblx0XHRjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXHRcdGNvbnN0IHRpbWVTaW5jZUxhc3RDYWxsID0gbm93IC0gbGFzdENhbGxUaW1lO1xuXHRcdGNvbnN0IGRlbGF5Rm9yTmV4dENhbGwgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cblx0XHRpZiAoZGVsYXlGb3JOZXh0Q2FsbCA8PSAwKSB7XG5cdFx0XHRsYXN0Q2FsbFRpbWUgPSBub3c7XG5cdFx0XHRmdW5jdGlvbl8uYXBwbHkodGhpcywgYXJndW1lbnRzXyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRsYXN0Q2FsbFRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRmdW5jdGlvbl8uYXBwbHkodGhpcywgYXJndW1lbnRzXyk7XG5cdFx0XHR9LCBkZWxheUZvck5leHRDYWxsKTtcblx0XHR9XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iXSwibmFtZXMiOlsidGhyb3R0bGUiLCJmdW5jdGlvbl8iLCJ3YWl0IiwiVHlwZUVycm9yIiwidGltZW91dElkIiwibGFzdENhbGxUaW1lIiwidGhyb3R0bGVkIiwiYXJndW1lbnRzXyIsImNsZWFyVGltZW91dCIsIm5vdyIsIkRhdGUiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsImRlbGF5Rm9yTmV4dENhbGwiLCJhcHBseSIsInNldFRpbWVvdXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/throttleit/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/CodeDisplay.tsx":
/*!************************************!*\
  !*** ./components/CodeDisplay.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ CodeDisplay; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/providers/AppProvider */ \"(app-pages-browser)/./components/providers/AppProvider.tsx\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction CodeDisplay() {\n    var _state_data;\n    _s();\n    const { state, reset, uploadSuccess } = (0,_components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__.useApp)();\n    const { code, expiresAt, expiryMinutes, maxDownloads } = state.data || {};\n    const [timeLeft, setTimeLeft] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [copied, setCopied] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Local state for UI toggles\n    const [selectedExpiry, setSelectedExpiry] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(expiryMinutes || 10);\n    const [selectedLimit, setSelectedLimit] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(maxDownloads === \"Unlimited\" ? \"Unlimited\" : maxDownloads || \"Unlimited\");\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!expiresAt) return;\n        const updateTimer = ()=>{\n            const now = Date.now();\n            const diff = expiresAt - now;\n            if (diff <= 0) {\n                setTimeLeft(\"EXPIRED\");\n                return;\n            }\n            const minutes = Math.floor(diff / 60000);\n            const seconds = Math.floor(diff % 60000 / 1000);\n            setTimeLeft(\"\".concat(minutes, \":\").concat(seconds < 10 ? \"0\" : \"\").concat(seconds));\n        };\n        updateTimer();\n        const interval = setInterval(updateTimer, 1000);\n        return ()=>clearInterval(interval);\n    }, [\n        expiresAt\n    ]);\n    const copyCode = ()=>{\n        if (!code) return;\n        navigator.clipboard.writeText(code);\n        setCopied(true);\n        setTimeout(()=>setCopied(false), 2000);\n    };\n    const handleUpdate = async (updates)=>{\n        if (!code) return;\n        try {\n            const updatedData = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_3__.updateFileMetadata)(code, updates);\n            uploadSuccess({\n                ...state.data,\n                ...updatedData\n            });\n            if (updates.expiryMinutes) setSelectedExpiry(updates.expiryMinutes);\n            if (updates.maxDownloads !== undefined) setSelectedLimit(updates.maxDownloads === Infinity ? \"Unlimited\" : updates.maxDownloads);\n        } catch (err) {\n            console.error(\"Failed to update metadata\", err);\n            alert(\"Failed to update settings\");\n        }\n    };\n    var _state_data_downloadsLeft;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"text-center\",\n        style: {\n            width: \"100%\",\n            padding: \"var(--space-lg) 0\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"font-bold uppercase\",\n                style: {\n                    fontSize: \"1.2rem\",\n                    marginBottom: \"var(--space-md)\"\n                },\n                children: \"YOUR CODE\"\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                lineNumber: 59,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"brutal-code\",\n                children: code\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                lineNumber: 63,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginTop: \"var(--space-lg)\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    className: \"brutal-button\",\n                    onClick: copyCode,\n                    style: {\n                        minWidth: \"200px\"\n                    },\n                    children: copied ? \"COPIED!\" : \"COPY CODE\"\n                }, void 0, false, {\n                    fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                    lineNumber: 68,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                lineNumber: 67,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"brutal-container\",\n                style: {\n                    marginTop: \"var(--space-xl)\",\n                    width: \"100%\",\n                    textAlign: \"left\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            display: \"flex\",\n                            justifyContent: \"space-between\",\n                            marginBottom: \"var(--space-md)\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-bold\",\n                                children: \"EXPIRES IN:\"\n                            }, void 0, false, {\n                                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                                lineNumber: 76,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-mono\",\n                                style: {\n                                    color: \"var(--color-accent-red)\"\n                                },\n                                children: timeLeft\n                            }, void 0, false, {\n                                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                                lineNumber: 77,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                        lineNumber: 75,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            display: \"flex\",\n                            justifyContent: \"space-between\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-bold\",\n                                children: \"DOWNLOADS LEFT:\"\n                            }, void 0, false, {\n                                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                                lineNumber: 80,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-mono\",\n                                children: maxDownloads === Infinity ? \"\" : (_state_data_downloadsLeft = (_state_data = state.data) === null || _state_data === void 0 ? void 0 : _state_data.downloadsLeft) !== null && _state_data_downloadsLeft !== void 0 ? _state_data_downloadsLeft : maxDownloads\n                            }, void 0, false, {\n                                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                                lineNumber: 81,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                        lineNumber: 79,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                lineNumber: 74,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                style: {\n                    marginTop: \"var(--space-lg)\",\n                    textDecoration: \"underline\",\n                    cursor: \"pointer\",\n                    opacity: 0.7\n                },\n                onClick: reset,\n                children: \"SEND ANOTHER FILE\"\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n                lineNumber: 87,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\CodeDisplay.tsx\",\n        lineNumber: 58,\n        columnNumber: 9\n    }, this);\n}\n_s(CodeDisplay, \"eLmc2Wj7ek/CdIhJzx+FQDjwGBY=\", false, function() {\n    return [\n        _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__.useApp\n    ];\n});\n_c = CodeDisplay;\nvar _c;\n$RefreshReg$(_c, \"CodeDisplay\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQ29kZURpc3BsYXkudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQzRDO0FBQ2dCO0FBQ2I7QUFFaEMsU0FBU0k7UUEyRTREQzs7SUExRWhGLE1BQU0sRUFBRUEsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLGFBQWEsRUFBRSxHQUFHTCx5RUFBTUE7SUFDOUMsTUFBTSxFQUFFTSxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsYUFBYSxFQUFFQyxZQUFZLEVBQUUsR0FBR04sTUFBTU8sSUFBSSxJQUFJLENBQUM7SUFDeEUsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUdkLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQ2UsUUFBUUMsVUFBVSxHQUFHaEIsK0NBQVFBLENBQUM7SUFFckMsNkJBQTZCO0lBQzdCLE1BQU0sQ0FBQ2lCLGdCQUFnQkMsa0JBQWtCLEdBQUdsQiwrQ0FBUUEsQ0FBQ1UsaUJBQWlCO0lBQ3RFLE1BQU0sQ0FBQ1MsZUFBZUMsaUJBQWlCLEdBQUdwQiwrQ0FBUUEsQ0FBQ1csaUJBQWlCLGNBQWMsY0FBY0EsZ0JBQWdCO0lBRWhIVixnREFBU0EsQ0FBQztRQUNOLElBQUksQ0FBQ1EsV0FBVztRQUNoQixNQUFNWSxjQUFjO1lBQ2hCLE1BQU1DLE1BQU1DLEtBQUtELEdBQUc7WUFDcEIsTUFBTUUsT0FBT2YsWUFBWWE7WUFDekIsSUFBSUUsUUFBUSxHQUFHO2dCQUNYVixZQUFZO2dCQUNaO1lBQ0o7WUFDQSxNQUFNVyxVQUFVQyxLQUFLQyxLQUFLLENBQUNILE9BQU87WUFDbEMsTUFBTUksVUFBVUYsS0FBS0MsS0FBSyxDQUFDLE9BQVEsUUFBUztZQUM1Q2IsWUFBWSxHQUFjYyxPQUFYSCxTQUFRLEtBQTZCRyxPQUExQkEsVUFBVSxLQUFLLE1BQU0sSUFBYSxPQUFSQTtRQUN4RDtRQUVBUDtRQUNBLE1BQU1RLFdBQVdDLFlBQVlULGFBQWE7UUFDMUMsT0FBTyxJQUFNVSxjQUFjRjtJQUMvQixHQUFHO1FBQUNwQjtLQUFVO0lBRWQsTUFBTXVCLFdBQVc7UUFDYixJQUFJLENBQUN4QixNQUFNO1FBQ1h5QixVQUFVQyxTQUFTLENBQUNDLFNBQVMsQ0FBQzNCO1FBQzlCUSxVQUFVO1FBQ1ZvQixXQUFXLElBQU1wQixVQUFVLFFBQVE7SUFDdkM7SUFFQSxNQUFNcUIsZUFBZSxPQUFPQztRQUN4QixJQUFJLENBQUM5QixNQUFNO1FBQ1gsSUFBSTtZQUNBLE1BQU0rQixjQUFjLE1BQU1wQyw0REFBa0JBLENBQUNLLE1BQU04QjtZQUNuRC9CLGNBQWM7Z0JBQUUsR0FBR0YsTUFBTU8sSUFBSTtnQkFBRSxHQUFHMkIsV0FBVztZQUFDO1lBRTlDLElBQUlELFFBQVE1QixhQUFhLEVBQUVRLGtCQUFrQm9CLFFBQVE1QixhQUFhO1lBQ2xFLElBQUk0QixRQUFRM0IsWUFBWSxLQUFLNkIsV0FBV3BCLGlCQUFpQmtCLFFBQVEzQixZQUFZLEtBQUs4QixXQUFXLGNBQWNILFFBQVEzQixZQUFZO1FBRW5JLEVBQUUsT0FBTytCLEtBQUs7WUFDVkMsUUFBUUMsS0FBSyxDQUFDLDZCQUE2QkY7WUFDM0NHLE1BQU07UUFDVjtJQUNKO1FBMEJnRnhDO0lBeEJoRixxQkFDSSw4REFBQ3lDO1FBQUlDLFdBQVU7UUFBY0MsT0FBTztZQUFFQyxPQUFPO1lBQVFDLFNBQVM7UUFBb0I7OzBCQUM5RSw4REFBQ0M7Z0JBQUVKLFdBQVU7Z0JBQXNCQyxPQUFPO29CQUFFSSxVQUFVO29CQUFVQyxjQUFjO2dCQUFrQjswQkFBRzs7Ozs7OzBCQUluRyw4REFBQ1A7Z0JBQUlDLFdBQVU7MEJBQ1Z2Qzs7Ozs7OzBCQUdMLDhEQUFDc0M7Z0JBQUlFLE9BQU87b0JBQUVNLFdBQVc7Z0JBQWtCOzBCQUN2Qyw0RUFBQ0M7b0JBQU9SLFdBQVU7b0JBQWdCUyxTQUFTeEI7b0JBQVVnQixPQUFPO3dCQUFFUyxVQUFVO29CQUFROzhCQUMzRTFDLFNBQVMsWUFBWTs7Ozs7Ozs7Ozs7MEJBSzlCLDhEQUFDK0I7Z0JBQUlDLFdBQVU7Z0JBQW1CQyxPQUFPO29CQUFFTSxXQUFXO29CQUFtQkwsT0FBTztvQkFBUVMsV0FBVztnQkFBTzs7a0NBQ3RHLDhEQUFDWjt3QkFBSUUsT0FBTzs0QkFBRVcsU0FBUzs0QkFBUUMsZ0JBQWdCOzRCQUFpQlAsY0FBYzt3QkFBa0I7OzBDQUM1Riw4REFBQ1E7Z0NBQUtkLFdBQVU7MENBQVk7Ozs7OzswQ0FDNUIsOERBQUNjO2dDQUFLZCxXQUFVO2dDQUFZQyxPQUFPO29DQUFFYyxPQUFPO2dDQUEwQjswQ0FBSWpEOzs7Ozs7Ozs7Ozs7a0NBRTlFLDhEQUFDaUM7d0JBQUlFLE9BQU87NEJBQUVXLFNBQVM7NEJBQVFDLGdCQUFnQjt3QkFBZ0I7OzBDQUMzRCw4REFBQ0M7Z0NBQUtkLFdBQVU7MENBQVk7Ozs7OzswQ0FDNUIsOERBQUNjO2dDQUFLZCxXQUFVOzBDQUFhcEMsaUJBQWlCOEIsV0FBVyxNQUFPcEMsQ0FBQUEsNkJBQUFBLGNBQUFBLE1BQU1PLElBQUksY0FBVlAsa0NBQUFBLFlBQVkwRCxhQUFhLGNBQXpCMUQsdUNBQUFBLDRCQUE2Qk07Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFNckcsOERBQUN3QztnQkFDR0gsT0FBTztvQkFBRU0sV0FBVztvQkFBbUJVLGdCQUFnQjtvQkFBYUMsUUFBUTtvQkFBV0MsU0FBUztnQkFBSTtnQkFDcEdWLFNBQVNsRDswQkFDWjs7Ozs7Ozs7Ozs7O0FBS2I7R0F6RndCRjs7UUFDb0JGLHFFQUFNQTs7O0tBRDFCRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NvZGVEaXNwbGF5LnRzeD9iMTJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VBcHAgfSBmcm9tICdAL2NvbXBvbmVudHMvcHJvdmlkZXJzL0FwcFByb3ZpZGVyJztcclxuaW1wb3J0IHsgdXBkYXRlRmlsZU1ldGFkYXRhIH0gZnJvbSAnQC9saWIvYXBpJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvZGVEaXNwbGF5KCkge1xyXG4gICAgY29uc3QgeyBzdGF0ZSwgcmVzZXQsIHVwbG9hZFN1Y2Nlc3MgfSA9IHVzZUFwcCgpO1xyXG4gICAgY29uc3QgeyBjb2RlLCBleHBpcmVzQXQsIGV4cGlyeU1pbnV0ZXMsIG1heERvd25sb2FkcyB9ID0gc3RhdGUuZGF0YSB8fCB7fTtcclxuICAgIGNvbnN0IFt0aW1lTGVmdCwgc2V0VGltZUxlZnRdID0gdXNlU3RhdGUoJycpO1xyXG4gICAgY29uc3QgW2NvcGllZCwgc2V0Q29waWVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICAvLyBMb2NhbCBzdGF0ZSBmb3IgVUkgdG9nZ2xlc1xyXG4gICAgY29uc3QgW3NlbGVjdGVkRXhwaXJ5LCBzZXRTZWxlY3RlZEV4cGlyeV0gPSB1c2VTdGF0ZShleHBpcnlNaW51dGVzIHx8IDEwKTtcclxuICAgIGNvbnN0IFtzZWxlY3RlZExpbWl0LCBzZXRTZWxlY3RlZExpbWl0XSA9IHVzZVN0YXRlKG1heERvd25sb2FkcyA9PT0gJ1VubGltaXRlZCcgPyAnVW5saW1pdGVkJyA6IG1heERvd25sb2FkcyB8fCAnVW5saW1pdGVkJyk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWV4cGlyZXNBdCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZVRpbWVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gZXhwaXJlc0F0IC0gbm93O1xyXG4gICAgICAgICAgICBpZiAoZGlmZiA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lTGVmdCgnRVhQSVJFRCcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKGRpZmYgLyA2MDAwMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKChkaWZmICUgNjAwMDApIC8gMTAwMCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVMZWZ0KGAke21pbnV0ZXN9OiR7c2Vjb25kcyA8IDEwID8gJzAnIDogJyd9JHtzZWNvbmRzfWApO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHVwZGF0ZVRpbWVyKCk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh1cGRhdGVUaW1lciwgMTAwMCk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgfSwgW2V4cGlyZXNBdF0pO1xyXG5cclxuICAgIGNvbnN0IGNvcHlDb2RlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghY29kZSkgcmV0dXJuO1xyXG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KGNvZGUpO1xyXG4gICAgICAgIHNldENvcGllZCh0cnVlKTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldENvcGllZChmYWxzZSksIDIwMDApO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVVcGRhdGUgPSBhc3luYyAodXBkYXRlczogYW55KSA9PiB7XHJcbiAgICAgICAgaWYgKCFjb2RlKSByZXR1cm47XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSBhd2FpdCB1cGRhdGVGaWxlTWV0YWRhdGEoY29kZSwgdXBkYXRlcyk7XHJcbiAgICAgICAgICAgIHVwbG9hZFN1Y2Nlc3MoeyAuLi5zdGF0ZS5kYXRhLCAuLi51cGRhdGVkRGF0YSB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh1cGRhdGVzLmV4cGlyeU1pbnV0ZXMpIHNldFNlbGVjdGVkRXhwaXJ5KHVwZGF0ZXMuZXhwaXJ5TWludXRlcyk7XHJcbiAgICAgICAgICAgIGlmICh1cGRhdGVzLm1heERvd25sb2FkcyAhPT0gdW5kZWZpbmVkKSBzZXRTZWxlY3RlZExpbWl0KHVwZGF0ZXMubWF4RG93bmxvYWRzID09PSBJbmZpbml0eSA/ICdVbmxpbWl0ZWQnIDogdXBkYXRlcy5tYXhEb3dubG9hZHMpO1xyXG5cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBtZXRhZGF0YScsIGVycik7XHJcbiAgICAgICAgICAgIGFsZXJ0KCdGYWlsZWQgdG8gdXBkYXRlIHNldHRpbmdzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBwYWRkaW5nOiAndmFyKC0tc3BhY2UtbGcpIDAnIH19PlxyXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LWJvbGQgdXBwZXJjYXNlXCIgc3R5bGU9e3sgZm9udFNpemU6ICcxLjJyZW0nLCBtYXJnaW5Cb3R0b206ICd2YXIoLS1zcGFjZS1tZCknIH19PlxyXG4gICAgICAgICAgICAgICAgWU9VUiBDT0RFXHJcbiAgICAgICAgICAgIDwvcD5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnJ1dGFsLWNvZGVcIj5cclxuICAgICAgICAgICAgICAgIHtjb2RlfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luVG9wOiAndmFyKC0tc3BhY2UtbGcpJyB9fT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnJ1dGFsLWJ1dHRvblwiIG9uQ2xpY2s9e2NvcHlDb2RlfSBzdHlsZT17eyBtaW5XaWR0aDogJzIwMHB4JyB9fT5cclxuICAgICAgICAgICAgICAgICAgICB7Y29waWVkID8gJ0NPUElFRCEnIDogJ0NPUFkgQ09ERSd9XHJcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICB7LyogU3VjY2VzcyBTdGF0cyAqL31cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJicnV0YWwtY29udGFpbmVyXCIgc3R5bGU9e3sgbWFyZ2luVG9wOiAndmFyKC0tc3BhY2UteGwpJywgd2lkdGg6ICcxMDAlJywgdGV4dEFsaWduOiAnbGVmdCcgfX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JywganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJywgbWFyZ2luQm90dG9tOiAndmFyKC0tc3BhY2UtbWQpJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LWJvbGRcIj5FWFBJUkVTIElOOjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LW1vbm9cIiBzdHlsZT17eyBjb2xvcjogJ3ZhcigtLWNvbG9yLWFjY2VudC1yZWQpJyB9fT57dGltZUxlZnR9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JywganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LWJvbGRcIj5ET1dOTE9BRFMgTEVGVDo8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1tb25vXCI+e21heERvd25sb2FkcyA9PT0gSW5maW5pdHkgPyAn4oieJyA6IChzdGF0ZS5kYXRhPy5kb3dubG9hZHNMZWZ0ID8/IG1heERvd25sb2Fkcyl9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICA8cFxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luVG9wOiAndmFyKC0tc3BhY2UtbGcpJywgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnLCBjdXJzb3I6ICdwb2ludGVyJywgb3BhY2l0eTogMC43IH19XHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtyZXNldH1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgU0VORCBBTk9USEVSIEZJTEVcclxuICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VBcHAiLCJ1cGRhdGVGaWxlTWV0YWRhdGEiLCJDb2RlRGlzcGxheSIsInN0YXRlIiwicmVzZXQiLCJ1cGxvYWRTdWNjZXNzIiwiY29kZSIsImV4cGlyZXNBdCIsImV4cGlyeU1pbnV0ZXMiLCJtYXhEb3dubG9hZHMiLCJkYXRhIiwidGltZUxlZnQiLCJzZXRUaW1lTGVmdCIsImNvcGllZCIsInNldENvcGllZCIsInNlbGVjdGVkRXhwaXJ5Iiwic2V0U2VsZWN0ZWRFeHBpcnkiLCJzZWxlY3RlZExpbWl0Iiwic2V0U2VsZWN0ZWRMaW1pdCIsInVwZGF0ZVRpbWVyIiwibm93IiwiRGF0ZSIsImRpZmYiLCJtaW51dGVzIiwiTWF0aCIsImZsb29yIiwic2Vjb25kcyIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY29weUNvZGUiLCJuYXZpZ2F0b3IiLCJjbGlwYm9hcmQiLCJ3cml0ZVRleHQiLCJzZXRUaW1lb3V0IiwiaGFuZGxlVXBkYXRlIiwidXBkYXRlcyIsInVwZGF0ZWREYXRhIiwidW5kZWZpbmVkIiwiSW5maW5pdHkiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJhbGVydCIsImRpdiIsImNsYXNzTmFtZSIsInN0eWxlIiwid2lkdGgiLCJwYWRkaW5nIiwicCIsImZvbnRTaXplIiwibWFyZ2luQm90dG9tIiwibWFyZ2luVG9wIiwiYnV0dG9uIiwib25DbGljayIsIm1pbldpZHRoIiwidGV4dEFsaWduIiwiZGlzcGxheSIsImp1c3RpZnlDb250ZW50Iiwic3BhbiIsImNvbG9yIiwiZG93bmxvYWRzTGVmdCIsInRleHREZWNvcmF0aW9uIiwiY3Vyc29yIiwib3BhY2l0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/CodeDisplay.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ConfigSelector.tsx":
/*!***************************************!*\
  !*** ./components/ConfigSelector.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ConfigSelector; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/providers/AppProvider */ \"(app-pages-browser)/./components/providers/AppProvider.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction ConfigSelector() {\n    _s();\n    const { state, setExpiry, setDownloads } = (0,_components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_1__.useApp)();\n    const { config, status } = state;\n    const isLocked = status === \"UPLOADING\";\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            marginBottom: \"var(--space-xl)\",\n            width: \"100%\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginBottom: \"var(--space-lg)\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"font-bold uppercase\",\n                        style: {\n                            fontSize: \"0.8rem\",\n                            marginBottom: \"var(--space-sm)\"\n                        },\n                        children: \"Expires In (Required)\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ConfigSelector.tsx\",\n                        lineNumber: 13,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            display: \"flex\",\n                            gap: \"var(--space-sm)\"\n                        },\n                        children: [\n                            5,\n                            10,\n                            30\n                        ].map((min)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>!isLocked && setExpiry(min),\n                                disabled: isLocked,\n                                className: \"text-mono\",\n                                style: {\n                                    flex: 1,\n                                    padding: \"var(--space-sm)\",\n                                    border: \"var(--border-thick) solid var(--color-border)\",\n                                    backgroundColor: config.expiry === min ? \"var(--color-bg-primary)\" : \"var(--color-bg-card)\",\n                                    color: config.expiry === min ? \"var(--color-text-primary)\" : \"#999\",\n                                    fontWeight: config.expiry === min ? 800 : 400,\n                                    cursor: isLocked ? \"not-allowed\" : \"pointer\",\n                                    transition: \"all 0.1s ease\",\n                                    boxShadow: config.expiry === min ? \"4px 4px 0 var(--color-border)\" : \"none\",\n                                    transform: config.expiry === min ? \"translate(-2px, -2px)\" : \"none\",\n                                    opacity: isLocked ? 0.7 : 1\n                                },\n                                children: [\n                                    min,\n                                    \"m\"\n                                ]\n                            }, min, true, {\n                                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ConfigSelector.tsx\",\n                                lineNumber: 18,\n                                columnNumber: 25\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ConfigSelector.tsx\",\n                        lineNumber: 16,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ConfigSelector.tsx\",\n                lineNumber: 12,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"font-bold uppercase\",\n                        style: {\n                            fontSize: \"0.8rem\",\n                            marginBottom: \"var(--space-sm)\"\n                        },\n                        children: \"Download Limit (Required)\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ConfigSelector.tsx\",\n                        lineNumber: 45,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            display: \"flex\",\n                            gap: \"var(--space-sm)\"\n                        },\n                        children: [\n                            1,\n                            3,\n                            100\n                        ].map((limit)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>!isLocked && setDownloads(limit),\n                                disabled: isLocked,\n                                className: \"text-mono\",\n                                style: {\n                                    flex: 1,\n                                    padding: \"var(--space-sm)\",\n                                    border: \"var(--border-thick) solid var(--color-border)\",\n                                    backgroundColor: config.maxDownloads === limit ? \"var(--color-bg-primary)\" : \"var(--color-bg-card)\",\n                                    color: config.maxDownloads === limit ? \"var(--color-text-primary)\" : \"#999\",\n                                    fontWeight: config.maxDownloads === limit ? 800 : 400,\n                                    cursor: isLocked ? \"not-allowed\" : \"pointer\",\n                                    transition: \"all 0.1s ease\",\n                                    boxShadow: config.maxDownloads === limit ? \"4px 4px 0 var(--color-border)\" : \"none\",\n                                    transform: config.maxDownloads === limit ? \"translate(-2px, -2px)\" : \"none\",\n                                    opacity: isLocked ? 0.7 : 1\n                                },\n                                children: limit === 100 ? \"\" : limit\n                            }, limit, false, {\n                                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ConfigSelector.tsx\",\n                                lineNumber: 50,\n                                columnNumber: 25\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ConfigSelector.tsx\",\n                        lineNumber: 48,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ConfigSelector.tsx\",\n                lineNumber: 44,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ConfigSelector.tsx\",\n        lineNumber: 10,\n        columnNumber: 9\n    }, this);\n}\n_s(ConfigSelector, \"bAo61gN/cFVy3iNWV41dGJkW32A=\", false, function() {\n    return [\n        _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_1__.useApp\n    ];\n});\n_c = ConfigSelector;\nvar _c;\n$RefreshReg$(_c, \"ConfigSelector\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQ29uZmlnU2VsZWN0b3IudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQzREO0FBRTdDLFNBQVNDOztJQUNwQixNQUFNLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR0oseUVBQU1BO0lBQ2pELE1BQU0sRUFBRUssTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0o7SUFDM0IsTUFBTUssV0FBV0QsV0FBVztJQUU1QixxQkFDSSw4REFBQ0U7UUFBSUMsT0FBTztZQUFFQyxjQUFjO1lBQW1CQyxPQUFPO1FBQU87OzBCQUV6RCw4REFBQ0g7Z0JBQUlDLE9BQU87b0JBQUVDLGNBQWM7Z0JBQWtCOztrQ0FDMUMsOERBQUNFO3dCQUFFQyxXQUFVO3dCQUFzQkosT0FBTzs0QkFBRUssVUFBVTs0QkFBVUosY0FBYzt3QkFBa0I7a0NBQUc7Ozs7OztrQ0FHbkcsOERBQUNGO3dCQUFJQyxPQUFPOzRCQUFFTSxTQUFTOzRCQUFRQyxLQUFLO3dCQUFrQjtrQ0FDakQ7NEJBQUM7NEJBQUc7NEJBQUk7eUJBQUcsQ0FBQ0MsR0FBRyxDQUFDLENBQUNDLG9CQUNkLDhEQUFDQztnQ0FFR0MsU0FBUyxJQUFNLENBQUNiLFlBQVlKLFVBQVVlO2dDQUN0Q0csVUFBVWQ7Z0NBQ1ZNLFdBQVU7Z0NBQ1ZKLE9BQU87b0NBQ0hhLE1BQU07b0NBQ05DLFNBQVM7b0NBQ1RDLFFBQVE7b0NBQ1JDLGlCQUFpQnBCLE9BQU9xQixNQUFNLEtBQUtSLE1BQU0sNEJBQTRCO29DQUNyRVMsT0FBT3RCLE9BQU9xQixNQUFNLEtBQUtSLE1BQU0sOEJBQThCO29DQUM3RFUsWUFBWXZCLE9BQU9xQixNQUFNLEtBQUtSLE1BQU0sTUFBTTtvQ0FDMUNXLFFBQVF0QixXQUFXLGdCQUFnQjtvQ0FDbkN1QixZQUFZO29DQUNaQyxXQUFXMUIsT0FBT3FCLE1BQU0sS0FBS1IsTUFBTSxrQ0FBa0M7b0NBQ3JFYyxXQUFXM0IsT0FBT3FCLE1BQU0sS0FBS1IsTUFBTSwwQkFBMEI7b0NBQzdEZSxTQUFTMUIsV0FBVyxNQUFNO2dDQUM5Qjs7b0NBRUNXO29DQUFJOzsrQkFsQkFBOzs7Ozs7Ozs7Ozs7Ozs7OzBCQXlCckIsOERBQUNWOztrQ0FDRyw4REFBQ0k7d0JBQUVDLFdBQVU7d0JBQXNCSixPQUFPOzRCQUFFSyxVQUFVOzRCQUFVSixjQUFjO3dCQUFrQjtrQ0FBRzs7Ozs7O2tDQUduRyw4REFBQ0Y7d0JBQUlDLE9BQU87NEJBQUVNLFNBQVM7NEJBQVFDLEtBQUs7d0JBQWtCO2tDQUNqRDs0QkFBQzs0QkFBRzs0QkFBRzt5QkFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQ2lCLHNCQUNkLDhEQUFDZjtnQ0FFR0MsU0FBUyxJQUFNLENBQUNiLFlBQVlILGFBQWE4QjtnQ0FDekNiLFVBQVVkO2dDQUNWTSxXQUFVO2dDQUNWSixPQUFPO29DQUNIYSxNQUFNO29DQUNOQyxTQUFTO29DQUNUQyxRQUFRO29DQUNSQyxpQkFBaUJwQixPQUFPOEIsWUFBWSxLQUFLRCxRQUFRLDRCQUE0QjtvQ0FDN0VQLE9BQU90QixPQUFPOEIsWUFBWSxLQUFLRCxRQUFRLDhCQUE4QjtvQ0FDckVOLFlBQVl2QixPQUFPOEIsWUFBWSxLQUFLRCxRQUFRLE1BQU07b0NBQ2xETCxRQUFRdEIsV0FBVyxnQkFBZ0I7b0NBQ25DdUIsWUFBWTtvQ0FDWkMsV0FBVzFCLE9BQU84QixZQUFZLEtBQUtELFFBQVEsa0NBQWtDO29DQUM3RUYsV0FBVzNCLE9BQU84QixZQUFZLEtBQUtELFFBQVEsMEJBQTBCO29DQUNyRUQsU0FBUzFCLFdBQVcsTUFBTTtnQ0FDOUI7MENBRUMyQixVQUFVLE1BQU0sTUFBTUE7K0JBbEJsQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QmpDO0dBeEV3QmpDOztRQUN1QkQscUVBQU1BOzs7S0FEN0JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ29uZmlnU2VsZWN0b3IudHN4PzRlODAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcbmltcG9ydCB7IHVzZUFwcCB9IGZyb20gJ0AvY29tcG9uZW50cy9wcm92aWRlcnMvQXBwUHJvdmlkZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29uZmlnU2VsZWN0b3IoKSB7XHJcbiAgICBjb25zdCB7IHN0YXRlLCBzZXRFeHBpcnksIHNldERvd25sb2FkcyB9ID0gdXNlQXBwKCk7XHJcbiAgICBjb25zdCB7IGNvbmZpZywgc3RhdHVzIH0gPSBzdGF0ZTtcclxuICAgIGNvbnN0IGlzTG9ja2VkID0gc3RhdHVzID09PSAnVVBMT0FESU5HJztcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAndmFyKC0tc3BhY2UteGwpJywgd2lkdGg6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgey8qIEV4cGlyeSBTZWN0aW9uICovfVxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogJ3ZhcigtLXNwYWNlLWxnKScgfX0+XHJcbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LWJvbGQgdXBwZXJjYXNlXCIgc3R5bGU9e3sgZm9udFNpemU6ICcwLjhyZW0nLCBtYXJnaW5Cb3R0b206ICd2YXIoLS1zcGFjZS1zbSknIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIEV4cGlyZXMgSW4gKFJlcXVpcmVkKVxyXG4gICAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcsIGdhcDogJ3ZhcigtLXNwYWNlLXNtKScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAge1s1LCAxMCwgMzBdLm1hcCgobWluKSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17bWlufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gIWlzTG9ja2VkICYmIHNldEV4cGlyeShtaW4pfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzTG9ja2VkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1tb25vXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAndmFyKC0tc3BhY2Utc20pJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6ICd2YXIoLS1ib3JkZXItdGhpY2spIHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlciknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29uZmlnLmV4cGlyeSA9PT0gbWluID8gJ3ZhcigtLWNvbG9yLWJnLXByaW1hcnkpJyA6ICd2YXIoLS1jb2xvci1iZy1jYXJkKScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbmZpZy5leHBpcnkgPT09IG1pbiA/ICd2YXIoLS1jb2xvci10ZXh0LXByaW1hcnkpJyA6ICcjOTk5JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBjb25maWcuZXhwaXJ5ID09PSBtaW4gPyA4MDAgOiA0MDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBpc0xvY2tlZCA/ICdub3QtYWxsb3dlZCcgOiAncG9pbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2FsbCAwLjFzIGVhc2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogY29uZmlnLmV4cGlyeSA9PT0gbWluID8gJzRweCA0cHggMCB2YXIoLS1jb2xvci1ib3JkZXIpJyA6ICdub25lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGNvbmZpZy5leHBpcnkgPT09IG1pbiA/ICd0cmFuc2xhdGUoLTJweCwgLTJweCknIDogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGlzTG9ja2VkID8gMC43IDogMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge21pbn1tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgey8qIERvd25sb2FkcyBTZWN0aW9uICovfVxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZm9udC1ib2xkIHVwcGVyY2FzZVwiIHN0eWxlPXt7IGZvbnRTaXplOiAnMC44cmVtJywgbWFyZ2luQm90dG9tOiAndmFyKC0tc3BhY2Utc20pJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICBEb3dubG9hZCBMaW1pdCAoUmVxdWlyZWQpXHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JywgZ2FwOiAndmFyKC0tc3BhY2Utc20pJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICB7WzEsIDMsIDEwMF0ubWFwKChsaW1pdCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2xpbWl0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gIWlzTG9ja2VkICYmIHNldERvd25sb2FkcyhsaW1pdCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17aXNMb2NrZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LW1vbm9cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICd2YXIoLS1zcGFjZS1zbSknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ3ZhcigtLWJvcmRlci10aGljaykgc29saWQgdmFyKC0tY29sb3ItYm9yZGVyKScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb25maWcubWF4RG93bmxvYWRzID09PSBsaW1pdCA/ICd2YXIoLS1jb2xvci1iZy1wcmltYXJ5KScgOiAndmFyKC0tY29sb3ItYmctY2FyZCknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb25maWcubWF4RG93bmxvYWRzID09PSBsaW1pdCA/ICd2YXIoLS1jb2xvci10ZXh0LXByaW1hcnkpJyA6ICcjOTk5JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBjb25maWcubWF4RG93bmxvYWRzID09PSBsaW1pdCA/IDgwMCA6IDQwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IGlzTG9ja2VkID8gJ25vdC1hbGxvd2VkJyA6ICdwb2ludGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnYWxsIDAuMXMgZWFzZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBjb25maWcubWF4RG93bmxvYWRzID09PSBsaW1pdCA/ICc0cHggNHB4IDAgdmFyKC0tY29sb3ItYm9yZGVyKScgOiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBjb25maWcubWF4RG93bmxvYWRzID09PSBsaW1pdCA/ICd0cmFuc2xhdGUoLTJweCwgLTJweCknIDogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGlzTG9ja2VkID8gMC43IDogMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2xpbWl0ID09PSAxMDAgPyAn4oieJyA6IGxpbWl0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUFwcCIsIkNvbmZpZ1NlbGVjdG9yIiwic3RhdGUiLCJzZXRFeHBpcnkiLCJzZXREb3dubG9hZHMiLCJjb25maWciLCJzdGF0dXMiLCJpc0xvY2tlZCIsImRpdiIsInN0eWxlIiwibWFyZ2luQm90dG9tIiwid2lkdGgiLCJwIiwiY2xhc3NOYW1lIiwiZm9udFNpemUiLCJkaXNwbGF5IiwiZ2FwIiwibWFwIiwibWluIiwiYnV0dG9uIiwib25DbGljayIsImRpc2FibGVkIiwiZmxleCIsInBhZGRpbmciLCJib3JkZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJleHBpcnkiLCJjb2xvciIsImZvbnRXZWlnaHQiLCJjdXJzb3IiLCJ0cmFuc2l0aW9uIiwiYm94U2hhZG93IiwidHJhbnNmb3JtIiwib3BhY2l0eSIsImxpbWl0IiwibWF4RG93bmxvYWRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ConfigSelector.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/DownloadInput.tsx":
/*!**************************************!*\
  !*** ./components/DownloadInput.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DownloadInput; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/providers/AppProvider */ \"(app-pages-browser)/./components/providers/AppProvider.tsx\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction DownloadInput() {\n    _s();\n    const { fetchFileStart, fetchFileSuccess, fetchFileError } = (0,_components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__.useApp)();\n    const [code, setCode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _inputRef_current;\n        (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();\n    }, []);\n    const handleSubmit = async (e)=>{\n        e.preventDefault();\n        if (!code || code.length < 5) return;\n        setIsLoading(true);\n        fetchFileStart();\n        try {\n            const data = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_3__.getFileMetadata)(code);\n            setTimeout(()=>{\n                fetchFileSuccess(data);\n            }, 500);\n        } catch (err) {\n            console.error(err);\n            let msg = err.error || \"File not found\";\n            if (msg.includes(\"not found\")) {\n                msg = \"INVALID CODE\";\n            }\n            fetchFileError(msg);\n            setIsLoading(false);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"text-center\",\n        style: {\n            width: \"100%\",\n            padding: \"var(--space-lg) 0\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"font-bold uppercase\",\n                style: {\n                    fontSize: \"1.2rem\",\n                    marginBottom: \"var(--space-md)\"\n                },\n                children: \"ENTER CODE\"\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadInput.tsx\",\n                lineNumber: 41,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                onSubmit: handleSubmit,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        ref: inputRef,\n                        type: \"text\",\n                        className: \"brutal-input\",\n                        placeholder: \"XXXXX\",\n                        maxLength: 10,\n                        value: code,\n                        onChange: (e)=>setCode(e.target.value.toUpperCase()),\n                        disabled: isLoading,\n                        \"aria-label\": \"Enter download code\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadInput.tsx\",\n                        lineNumber: 46,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"submit\",\n                        className: \"brutal-button\",\n                        style: {\n                            width: \"100%\",\n                            marginTop: \"var(--space-lg)\"\n                        },\n                        disabled: isLoading || code.length < 5,\n                        children: isLoading ? \"SEARCHING...\" : \"GET FILE\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadInput.tsx\",\n                        lineNumber: 58,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadInput.tsx\",\n                lineNumber: 45,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadInput.tsx\",\n        lineNumber: 40,\n        columnNumber: 9\n    }, this);\n}\n_s(DownloadInput, \"uPlLRqc6hp9QQhxrD9zgq6OR4qg=\", false, function() {\n    return [\n        _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__.useApp\n    ];\n});\n_c = DownloadInput;\nvar _c;\n$RefreshReg$(_c, \"DownloadInput\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvRG93bmxvYWRJbnB1dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDK0Q7QUFDSDtBQUNoQjtBQUU3QixTQUFTSzs7SUFDcEIsTUFBTSxFQUFFQyxjQUFjLEVBQUVDLGdCQUFnQixFQUFFQyxjQUFjLEVBQUUsR0FBR0wseUVBQU1BO0lBQ25FLE1BQU0sQ0FBQ00sTUFBTUMsUUFBUSxHQUFHViwrQ0FBUUEsQ0FBQztJQUNqQyxNQUFNLENBQUNXLFdBQVdDLGFBQWEsR0FBR1osK0NBQVFBLENBQUM7SUFDM0MsTUFBTWEsV0FBV1gsNkNBQU1BLENBQW1CO0lBRTFDRCxnREFBU0EsQ0FBQztZQUNOWTtTQUFBQSxvQkFBQUEsU0FBU0MsT0FBTyxjQUFoQkQsd0NBQUFBLGtCQUFrQkUsS0FBSztJQUMzQixHQUFHLEVBQUU7SUFFTCxNQUFNQyxlQUFlLE9BQU9DO1FBQ3hCQSxFQUFFQyxjQUFjO1FBQ2hCLElBQUksQ0FBQ1QsUUFBUUEsS0FBS1UsTUFBTSxHQUFHLEdBQUc7UUFFOUJQLGFBQWE7UUFDYk47UUFFQSxJQUFJO1lBQ0EsTUFBTWMsT0FBTyxNQUFNaEIseURBQWVBLENBQUNLO1lBQ25DWSxXQUFXO2dCQUNQZCxpQkFBaUJhO1lBQ3JCLEdBQUc7UUFDUCxFQUFFLE9BQU9FLEtBQVU7WUFDZkMsUUFBUUMsS0FBSyxDQUFDRjtZQUNkLElBQUlHLE1BQU1ILElBQUlFLEtBQUssSUFBSTtZQUN2QixJQUFJQyxJQUFJQyxRQUFRLENBQUMsY0FBYztnQkFDM0JELE1BQU07WUFDVjtZQUNBakIsZUFBZWlCO1lBQ2ZiLGFBQWE7UUFDakI7SUFDSjtJQUVBLHFCQUNJLDhEQUFDZTtRQUFJQyxXQUFVO1FBQWNDLE9BQU87WUFBRUMsT0FBTztZQUFRQyxTQUFTO1FBQW9COzswQkFDOUUsOERBQUNDO2dCQUFFSixXQUFVO2dCQUFzQkMsT0FBTztvQkFBRUksVUFBVTtvQkFBVUMsY0FBYztnQkFBa0I7MEJBQUc7Ozs7OzswQkFJbkcsOERBQUNDO2dCQUFLQyxVQUFVcEI7O2tDQUNaLDhEQUFDcUI7d0JBQ0dDLEtBQUt6Qjt3QkFDTDBCLE1BQUs7d0JBQ0xYLFdBQVU7d0JBQ1ZZLGFBQVk7d0JBQ1pDLFdBQVc7d0JBQ1hDLE9BQU9qQzt3QkFDUGtDLFVBQVUsQ0FBQzFCLElBQU1QLFFBQVFPLEVBQUUyQixNQUFNLENBQUNGLEtBQUssQ0FBQ0csV0FBVzt3QkFDbkRDLFVBQVVuQzt3QkFDVm9DLGNBQVc7Ozs7OztrQ0FHZiw4REFBQ0M7d0JBQ0dULE1BQUs7d0JBQ0xYLFdBQVU7d0JBQ1ZDLE9BQU87NEJBQUVDLE9BQU87NEJBQVFtQixXQUFXO3dCQUFrQjt3QkFDckRILFVBQVVuQyxhQUFhRixLQUFLVSxNQUFNLEdBQUc7a0NBRXBDUixZQUFZLGlCQUFpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS2xEO0dBL0R3Qk47O1FBQ3lDRixxRUFBTUE7OztLQUQvQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Eb3dubG9hZElucHV0LnRzeD8zYmQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIEZvcm1FdmVudCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlQXBwIH0gZnJvbSAnQC9jb21wb25lbnRzL3Byb3ZpZGVycy9BcHBQcm92aWRlcic7XHJcbmltcG9ydCB7IGdldEZpbGVNZXRhZGF0YSB9IGZyb20gJ0AvbGliL2FwaSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEb3dubG9hZElucHV0KCkge1xyXG4gICAgY29uc3QgeyBmZXRjaEZpbGVTdGFydCwgZmV0Y2hGaWxlU3VjY2VzcywgZmV0Y2hGaWxlRXJyb3IgfSA9IHVzZUFwcCgpO1xyXG4gICAgY29uc3QgW2NvZGUsIHNldENvZGVdID0gdXNlU3RhdGUoJycpO1xyXG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaW5wdXRSZWYuY3VycmVudD8uZm9jdXMoKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoZTogRm9ybUV2ZW50KSA9PiB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGlmICghY29kZSB8fCBjb2RlLmxlbmd0aCA8IDUpIHJldHVybjtcclxuXHJcbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgIGZldGNoRmlsZVN0YXJ0KCk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRGaWxlTWV0YWRhdGEoY29kZSk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZmV0Y2hGaWxlU3VjY2VzcyhkYXRhKTtcclxuICAgICAgICAgICAgfSwgNTAwKTtcclxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgIGxldCBtc2cgPSBlcnIuZXJyb3IgfHwgJ0ZpbGUgbm90IGZvdW5kJztcclxuICAgICAgICAgICAgaWYgKG1zZy5pbmNsdWRlcygnbm90IGZvdW5kJykpIHtcclxuICAgICAgICAgICAgICAgIG1zZyA9ICdJTlZBTElEIENPREUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZldGNoRmlsZUVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBwYWRkaW5nOiAndmFyKC0tc3BhY2UtbGcpIDAnIH19PlxyXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LWJvbGQgdXBwZXJjYXNlXCIgc3R5bGU9e3sgZm9udFNpemU6ICcxLjJyZW0nLCBtYXJnaW5Cb3R0b206ICd2YXIoLS1zcGFjZS1tZCknIH19PlxyXG4gICAgICAgICAgICAgICAgRU5URVIgQ09ERVxyXG4gICAgICAgICAgICA8L3A+XHJcblxyXG4gICAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0fT5cclxuICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZj17aW5wdXRSZWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJydXRhbC1pbnB1dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJYWFhYWFwiXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4TGVuZ3RoPXsxMH1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Y29kZX1cclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldENvZGUoZS50YXJnZXQudmFsdWUudG9VcHBlckNhc2UoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzTG9hZGluZ31cclxuICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiRW50ZXIgZG93bmxvYWQgY29kZVwiXHJcbiAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJicnV0YWwtYnV0dG9uXCJcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBtYXJnaW5Ub3A6ICd2YXIoLS1zcGFjZS1sZyknIH19XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzTG9hZGluZyB8fCBjb2RlLmxlbmd0aCA8IDV9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge2lzTG9hZGluZyA/ICdTRUFSQ0hJTkcuLi4nIDogJ0dFVCBGSUxFJ31cclxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUFwcCIsImdldEZpbGVNZXRhZGF0YSIsIkRvd25sb2FkSW5wdXQiLCJmZXRjaEZpbGVTdGFydCIsImZldGNoRmlsZVN1Y2Nlc3MiLCJmZXRjaEZpbGVFcnJvciIsImNvZGUiLCJzZXRDb2RlIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiaW5wdXRSZWYiLCJjdXJyZW50IiwiZm9jdXMiLCJoYW5kbGVTdWJtaXQiLCJlIiwicHJldmVudERlZmF1bHQiLCJsZW5ndGgiLCJkYXRhIiwic2V0VGltZW91dCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsIm1zZyIsImluY2x1ZGVzIiwiZGl2IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJ3aWR0aCIsInBhZGRpbmciLCJwIiwiZm9udFNpemUiLCJtYXJnaW5Cb3R0b20iLCJmb3JtIiwib25TdWJtaXQiLCJpbnB1dCIsInJlZiIsInR5cGUiLCJwbGFjZWhvbGRlciIsIm1heExlbmd0aCIsInZhbHVlIiwib25DaGFuZ2UiLCJ0YXJnZXQiLCJ0b1VwcGVyQ2FzZSIsImRpc2FibGVkIiwiYXJpYS1sYWJlbCIsImJ1dHRvbiIsIm1hcmdpblRvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/DownloadInput.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/DownloadingState.tsx":
/*!*****************************************!*\
  !*** ./components/DownloadingState.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DownloadingState; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/providers/AppProvider */ \"(app-pages-browser)/./components/providers/AppProvider.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction DownloadingState() {\n    _s();\n    const { state, reset } = (0,_components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__.useApp)();\n    const { code, originalName, size } = state.data || {};\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (code) {\n            const fetchDownload = async ()=>{\n                try {\n                    // Use the new claim function\n                    // We need to import it properly. Assuming claimDownload is exported.\n                    // But I need to update the import statement too.\n                    // Since replace_file_content target is the hook, I can't easily change imports up top without multi-replace.\n                    // I will do multi-replace or just fetch directly here using the new path.\n                    // Let's use fetch directly matching the API I just built to be safe and avoid import errors in this tool call.\n                    const res = await fetch(\"/api/share/\".concat(code, \"/download\"), {\n                        method: \"POST\"\n                    });\n                    const data = await res.json();\n                    if (data.url) {\n                        window.location.href = data.url;\n                    // Handle multi-file if needed later\n                    } else {\n                        console.error(\"Download failed\", data.error);\n                    // Optional: Navigate to error state\n                    }\n                } catch (e) {\n                    console.error(\"Download network error\");\n                }\n            };\n            // Small delay for UI\n            const timer = setTimeout(fetchDownload, 1000);\n            return ()=>clearTimeout(timer);\n        }\n    }, [\n        code\n    ]);\n    const formatSize = (bytes)=>{\n        if (bytes === undefined || bytes === 0) return \"0 B\";\n        const k = 1024;\n        const sizes = [\n            \"B\",\n            \"KB\",\n            \"MB\",\n            \"GB\"\n        ];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + \" \" + sizes[i];\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"text-center\",\n        style: {\n            width: \"100%\",\n            padding: \"var(--space-lg) 0\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"font-bold uppercase\",\n                style: {\n                    fontSize: \"1.2rem\",\n                    marginBottom: \"var(--space-md)\"\n                },\n                children: \"DOWNLOADING...\"\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadingState.tsx\",\n                lineNumber: 54,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"brutal-container\",\n                style: {\n                    backgroundColor: \"var(--color-bg-mint)\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"font-bold\",\n                        style: {\n                            fontSize: \"1.5rem\",\n                            wordBreak: \"break-all\"\n                        },\n                        children: originalName\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadingState.tsx\",\n                        lineNumber: 59,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-mono\",\n                        style: {\n                            marginTop: \"var(--space-sm)\"\n                        },\n                        children: formatSize(size)\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadingState.tsx\",\n                        lineNumber: 62,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadingState.tsx\",\n                lineNumber: 58,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"brutal-progress\",\n                style: {\n                    marginTop: \"var(--space-lg)\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"brutal-progress-fill\",\n                    style: {\n                        width: \"100%\",\n                        animation: \"pulse 2s infinite\"\n                    }\n                }, void 0, false, {\n                    fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadingState.tsx\",\n                    lineNumber: 68,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadingState.tsx\",\n                lineNumber: 67,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"brutal-button\",\n                onClick: reset,\n                style: {\n                    marginTop: \"var(--space-xl)\",\n                    width: \"100%\"\n                },\n                children: \"SEND A FILE\"\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadingState.tsx\",\n                lineNumber: 74,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\DownloadingState.tsx\",\n        lineNumber: 53,\n        columnNumber: 9\n    }, this);\n}\n_s(DownloadingState, \"NSb0tALBg7XT7WiuBr7uew9MFXk=\", false, function() {\n    return [\n        _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__.useApp\n    ];\n});\n_c = DownloadingState;\nvar _c;\n$RefreshReg$(_c, \"DownloadingState\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvRG93bmxvYWRpbmdTdGF0ZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNrQztBQUMwQjtBQUc3QyxTQUFTRTs7SUFDcEIsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRSxHQUFHSCx5RUFBTUE7SUFDL0IsTUFBTSxFQUFFSSxJQUFJLEVBQUVDLFlBQVksRUFBRUMsSUFBSSxFQUFFLEdBQUdKLE1BQU1LLElBQUksSUFBSSxDQUFDO0lBRXBEUixnREFBU0EsQ0FBQztRQUNOLElBQUlLLE1BQU07WUFDTixNQUFNSSxnQkFBZ0I7Z0JBQ2xCLElBQUk7b0JBQ0EsNkJBQTZCO29CQUM3QixxRUFBcUU7b0JBQ3JFLGlEQUFpRDtvQkFDakQsNkdBQTZHO29CQUM3RywwRUFBMEU7b0JBQzFFLCtHQUErRztvQkFFL0csTUFBTUMsTUFBTSxNQUFNQyxNQUFNLGNBQW1CLE9BQUxOLE1BQUssY0FBWTt3QkFDbkRPLFFBQVE7b0JBQ1o7b0JBQ0EsTUFBTUosT0FBTyxNQUFNRSxJQUFJRyxJQUFJO29CQUUzQixJQUFJTCxLQUFLTSxHQUFHLEVBQUU7d0JBQ1ZDLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSSxHQUFHVCxLQUFLTSxHQUFHO29CQUMvQixvQ0FBb0M7b0JBQ3hDLE9BQU87d0JBQ0hJLFFBQVFDLEtBQUssQ0FBQyxtQkFBbUJYLEtBQUtXLEtBQUs7b0JBQzNDLG9DQUFvQztvQkFDeEM7Z0JBQ0osRUFBRSxPQUFPQyxHQUFHO29CQUNSRixRQUFRQyxLQUFLLENBQUM7Z0JBQ2xCO1lBQ0o7WUFFQSxxQkFBcUI7WUFDckIsTUFBTUUsUUFBUUMsV0FBV2IsZUFBZTtZQUN4QyxPQUFPLElBQU1jLGFBQWFGO1FBQzlCO0lBQ0osR0FBRztRQUFDaEI7S0FBSztJQUVULE1BQU1tQixhQUFhLENBQUNDO1FBQ2hCLElBQUlBLFVBQVVDLGFBQWFELFVBQVUsR0FBRyxPQUFPO1FBQy9DLE1BQU1FLElBQUk7UUFDVixNQUFNQyxRQUFRO1lBQUM7WUFBSztZQUFNO1lBQU07U0FBSztRQUNyQyxNQUFNQyxJQUFJQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLEdBQUcsQ0FBQ1AsU0FBU0ssS0FBS0UsR0FBRyxDQUFDTDtRQUNoRCxPQUFPTSxXQUFXLENBQUNSLFFBQVFLLEtBQUtJLEdBQUcsQ0FBQ1AsR0FBR0UsRUFBQyxFQUFHTSxPQUFPLENBQUMsTUFBTSxNQUFNUCxLQUFLLENBQUNDLEVBQUU7SUFDM0U7SUFFQSxxQkFDSSw4REFBQ087UUFBSUMsV0FBVTtRQUFjQyxPQUFPO1lBQUVDLE9BQU87WUFBUUMsU0FBUztRQUFvQjs7MEJBQzlFLDhEQUFDQztnQkFBRUosV0FBVTtnQkFBc0JDLE9BQU87b0JBQUVJLFVBQVU7b0JBQVVDLGNBQWM7Z0JBQWtCOzBCQUFHOzs7Ozs7MEJBSW5HLDhEQUFDUDtnQkFBSUMsV0FBVTtnQkFBbUJDLE9BQU87b0JBQUVNLGlCQUFpQjtnQkFBdUI7O2tDQUMvRSw4REFBQ0g7d0JBQUVKLFdBQVU7d0JBQVlDLE9BQU87NEJBQUVJLFVBQVU7NEJBQVVHLFdBQVc7d0JBQVk7a0NBQ3hFdkM7Ozs7OztrQ0FFTCw4REFBQ21DO3dCQUFFSixXQUFVO3dCQUFZQyxPQUFPOzRCQUFFUSxXQUFXO3dCQUFrQjtrQ0FDMUR0QixXQUFXakI7Ozs7Ozs7Ozs7OzswQkFJcEIsOERBQUM2QjtnQkFBSUMsV0FBVTtnQkFBa0JDLE9BQU87b0JBQUVRLFdBQVc7Z0JBQWtCOzBCQUNuRSw0RUFBQ1Y7b0JBQ0dDLFdBQVU7b0JBQ1ZDLE9BQU87d0JBQUVDLE9BQU87d0JBQVFRLFdBQVc7b0JBQW9COzs7Ozs7Ozs7OzswQkFJL0QsOERBQUNDO2dCQUNHWCxXQUFVO2dCQUNWWSxTQUFTN0M7Z0JBQ1RrQyxPQUFPO29CQUFFUSxXQUFXO29CQUFtQlAsT0FBTztnQkFBTzswQkFDeEQ7Ozs7Ozs7Ozs7OztBQUtiO0dBN0V3QnJDOztRQUNLRCxxRUFBTUE7OztLQURYQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Rvd25sb2FkaW5nU3RhdGUudHN4P2NkYmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlQXBwIH0gZnJvbSAnQC9jb21wb25lbnRzL3Byb3ZpZGVycy9BcHBQcm92aWRlcic7XHJcbmltcG9ydCB7IGdldERvd25sb2FkVXJsIH0gZnJvbSAnQC9saWIvYXBpJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERvd25sb2FkaW5nU3RhdGUoKSB7XHJcbiAgICBjb25zdCB7IHN0YXRlLCByZXNldCB9ID0gdXNlQXBwKCk7XHJcbiAgICBjb25zdCB7IGNvZGUsIG9yaWdpbmFsTmFtZSwgc2l6ZSB9ID0gc3RhdGUuZGF0YSB8fCB7fTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChjb2RlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZldGNoRG93bmxvYWQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgbmV3IGNsYWltIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBpbXBvcnQgaXQgcHJvcGVybHkuIEFzc3VtaW5nIGNsYWltRG93bmxvYWQgaXMgZXhwb3J0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0IEkgbmVlZCB0byB1cGRhdGUgdGhlIGltcG9ydCBzdGF0ZW1lbnQgdG9vLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHJlcGxhY2VfZmlsZV9jb250ZW50IHRhcmdldCBpcyB0aGUgaG9vaywgSSBjYW4ndCBlYXNpbHkgY2hhbmdlIGltcG9ydHMgdXAgdG9wIHdpdGhvdXQgbXVsdGktcmVwbGFjZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJIHdpbGwgZG8gbXVsdGktcmVwbGFjZSBvciBqdXN0IGZldGNoIGRpcmVjdGx5IGhlcmUgdXNpbmcgdGhlIG5ldyBwYXRoLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExldCdzIHVzZSBmZXRjaCBkaXJlY3RseSBtYXRjaGluZyB0aGUgQVBJIEkganVzdCBidWlsdCB0byBiZSBzYWZlIGFuZCBhdm9pZCBpbXBvcnQgZXJyb3JzIGluIHRoaXMgdG9vbCBjYWxsLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9zaGFyZS8ke2NvZGV9L2Rvd25sb2FkYCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS51cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkYXRhLnVybDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG11bHRpLWZpbGUgaWYgbmVlZGVkIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRG93bmxvYWQgZmFpbGVkJywgZGF0YS5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsOiBOYXZpZ2F0ZSB0byBlcnJvciBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdEb3dubG9hZCBuZXR3b3JrIGVycm9yJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBTbWFsbCBkZWxheSBmb3IgVUlcclxuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KGZldGNoRG93bmxvYWQsIDEwMDApO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbY29kZV0pO1xyXG5cclxuICAgIGNvbnN0IGZvcm1hdFNpemUgPSAoYnl0ZXM6IG51bWJlciB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgIGlmIChieXRlcyA9PT0gdW5kZWZpbmVkIHx8IGJ5dGVzID09PSAwKSByZXR1cm4gJzAgQic7XHJcbiAgICAgICAgY29uc3QgayA9IDEwMjQ7XHJcbiAgICAgICAgY29uc3Qgc2l6ZXMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InXTtcclxuICAgICAgICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZyhrKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoKGJ5dGVzIC8gTWF0aC5wb3coaywgaSkpLnRvRml4ZWQoMikpICsgJyAnICsgc2l6ZXNbaV07XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlclwiIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIHBhZGRpbmc6ICd2YXIoLS1zcGFjZS1sZykgMCcgfX0+XHJcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtYm9sZCB1cHBlcmNhc2VcIiBzdHlsZT17eyBmb250U2l6ZTogJzEuMnJlbScsIG1hcmdpbkJvdHRvbTogJ3ZhcigtLXNwYWNlLW1kKScgfX0+XHJcbiAgICAgICAgICAgICAgICBET1dOTE9BRElORy4uLlxyXG4gICAgICAgICAgICA8L3A+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJydXRhbC1jb250YWluZXJcIiBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6ICd2YXIoLS1jb2xvci1iZy1taW50KScgfX0+XHJcbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LWJvbGRcIiBzdHlsZT17eyBmb250U2l6ZTogJzEuNXJlbScsIHdvcmRCcmVhazogJ2JyZWFrLWFsbCcgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAge29yaWdpbmFsTmFtZX1cclxuICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtbW9ub1wiIHN0eWxlPXt7IG1hcmdpblRvcDogJ3ZhcigtLXNwYWNlLXNtKScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAge2Zvcm1hdFNpemUoc2l6ZSl9XHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJicnV0YWwtcHJvZ3Jlc3NcIiBzdHlsZT17eyBtYXJnaW5Ub3A6ICd2YXIoLS1zcGFjZS1sZyknIH19PlxyXG4gICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJydXRhbC1wcm9ncmVzcy1maWxsXCJcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBhbmltYXRpb246ICdwdWxzZSAycyBpbmZpbml0ZScgfX1cclxuICAgICAgICAgICAgICAgID48L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJicnV0YWwtYnV0dG9uXCJcclxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3Jlc2V0fVxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luVG9wOiAndmFyKC0tc3BhY2UteGwpJywgd2lkdGg6ICcxMDAlJyB9fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICBTRU5EIEEgRklMRVxyXG4gICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZUFwcCIsIkRvd25sb2FkaW5nU3RhdGUiLCJzdGF0ZSIsInJlc2V0IiwiY29kZSIsIm9yaWdpbmFsTmFtZSIsInNpemUiLCJkYXRhIiwiZmV0Y2hEb3dubG9hZCIsInJlcyIsImZldGNoIiwibWV0aG9kIiwianNvbiIsInVybCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImNvbnNvbGUiLCJlcnJvciIsImUiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJmb3JtYXRTaXplIiwiYnl0ZXMiLCJ1bmRlZmluZWQiLCJrIiwic2l6ZXMiLCJpIiwiTWF0aCIsImZsb29yIiwibG9nIiwicGFyc2VGbG9hdCIsInBvdyIsInRvRml4ZWQiLCJkaXYiLCJjbGFzc05hbWUiLCJzdHlsZSIsIndpZHRoIiwicGFkZGluZyIsInAiLCJmb250U2l6ZSIsIm1hcmdpbkJvdHRvbSIsImJhY2tncm91bmRDb2xvciIsIndvcmRCcmVhayIsIm1hcmdpblRvcCIsImFuaW1hdGlvbiIsImJ1dHRvbiIsIm9uQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/DownloadingState.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ErrorDisplay.tsx":
/*!*************************************!*\
  !*** ./components/ErrorDisplay.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ErrorDisplay; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/providers/AppProvider */ \"(app-pages-browser)/./components/providers/AppProvider.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction ErrorDisplay() {\n    _s();\n    const { state, reset } = (0,_components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_1__.useApp)();\n    const { error } = state;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"text-center\",\n        style: {\n            width: \"100%\",\n            padding: \"var(--space-lg) 0\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"brutal-error brutal-container\",\n                style: {\n                    marginBottom: \"var(--space-lg)\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"font-bold uppercase\",\n                        style: {\n                            fontSize: \"1.5rem\",\n                            color: \"var(--color-accent-red)\"\n                        },\n                        children: \"ERROR\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ErrorDisplay.tsx\",\n                        lineNumber: 11,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        style: {\n                            marginTop: \"var(--space-md)\",\n                            fontSize: \"1.2rem\"\n                        },\n                        children: error || \"SOMETHING WENT WRONG\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ErrorDisplay.tsx\",\n                        lineNumber: 14,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ErrorDisplay.tsx\",\n                lineNumber: 10,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"brutal-button\",\n                onClick: reset,\n                style: {\n                    width: \"100%\"\n                },\n                children: \"TRY AGAIN\"\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ErrorDisplay.tsx\",\n                lineNumber: 19,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ErrorDisplay.tsx\",\n        lineNumber: 9,\n        columnNumber: 9\n    }, this);\n}\n_s(ErrorDisplay, \"qVU/vf9+94EZr84+F082WodG0K8=\", false, function() {\n    return [\n        _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_1__.useApp\n    ];\n});\n_c = ErrorDisplay;\nvar _c;\n$RefreshReg$(_c, \"ErrorDisplay\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvRXJyb3JEaXNwbGF5LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUM0RDtBQUU3QyxTQUFTQzs7SUFDcEIsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRSxHQUFHSCx5RUFBTUE7SUFDL0IsTUFBTSxFQUFFSSxLQUFLLEVBQUUsR0FBR0Y7SUFFbEIscUJBQ0ksOERBQUNHO1FBQUlDLFdBQVU7UUFBY0MsT0FBTztZQUFFQyxPQUFPO1lBQVFDLFNBQVM7UUFBb0I7OzBCQUM5RSw4REFBQ0o7Z0JBQUlDLFdBQVU7Z0JBQWdDQyxPQUFPO29CQUFFRyxjQUFjO2dCQUFrQjs7a0NBQ3BGLDhEQUFDQzt3QkFBRUwsV0FBVTt3QkFBc0JDLE9BQU87NEJBQUVLLFVBQVU7NEJBQVVDLE9BQU87d0JBQTBCO2tDQUFHOzs7Ozs7a0NBR3BHLDhEQUFDRjt3QkFBRUosT0FBTzs0QkFBRU8sV0FBVzs0QkFBbUJGLFVBQVU7d0JBQVM7a0NBQ3hEUixTQUFTOzs7Ozs7Ozs7Ozs7MEJBSWxCLDhEQUFDVztnQkFDR1QsV0FBVTtnQkFDVlUsU0FBU2I7Z0JBQ1RJLE9BQU87b0JBQUVDLE9BQU87Z0JBQU87MEJBQzFCOzs7Ozs7Ozs7Ozs7QUFLYjtHQXhCd0JQOztRQUNLRCxxRUFBTUE7OztLQURYQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Vycm9yRGlzcGxheS50c3g/NGUxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuaW1wb3J0IHsgdXNlQXBwIH0gZnJvbSAnQC9jb21wb25lbnRzL3Byb3ZpZGVycy9BcHBQcm92aWRlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFcnJvckRpc3BsYXkoKSB7XHJcbiAgICBjb25zdCB7IHN0YXRlLCByZXNldCB9ID0gdXNlQXBwKCk7XHJcbiAgICBjb25zdCB7IGVycm9yIH0gPSBzdGF0ZTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBwYWRkaW5nOiAndmFyKC0tc3BhY2UtbGcpIDAnIH19PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJydXRhbC1lcnJvciBicnV0YWwtY29udGFpbmVyXCIgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAndmFyKC0tc3BhY2UtbGcpJyB9fT5cclxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtYm9sZCB1cHBlcmNhc2VcIiBzdHlsZT17eyBmb250U2l6ZTogJzEuNXJlbScsIGNvbG9yOiAndmFyKC0tY29sb3ItYWNjZW50LXJlZCknIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIEVSUk9SXHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICA8cCBzdHlsZT17eyBtYXJnaW5Ub3A6ICd2YXIoLS1zcGFjZS1tZCknLCBmb250U2l6ZTogJzEuMnJlbScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAge2Vycm9yIHx8ICdTT01FVEhJTkcgV0VOVCBXUk9ORyd9XHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnJ1dGFsLWJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtyZXNldH1cclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScgfX1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgVFJZIEFHQUlOXHJcbiAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlQXBwIiwiRXJyb3JEaXNwbGF5Iiwic3RhdGUiLCJyZXNldCIsImVycm9yIiwiZGl2IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJ3aWR0aCIsInBhZGRpbmciLCJtYXJnaW5Cb3R0b20iLCJwIiwiZm9udFNpemUiLCJjb2xvciIsIm1hcmdpblRvcCIsImJ1dHRvbiIsIm9uQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ErrorDisplay.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/MainApp.tsx":
/*!********************************!*\
  !*** ./components/MainApp.tsx ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MainApp; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/providers/AppProvider */ \"(app-pages-browser)/./components/providers/AppProvider.tsx\");\n/* harmony import */ var _components_UploadZone__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/UploadZone */ \"(app-pages-browser)/./components/UploadZone.tsx\");\n/* harmony import */ var _components_CodeDisplay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/CodeDisplay */ \"(app-pages-browser)/./components/CodeDisplay.tsx\");\n/* harmony import */ var _components_DownloadInput__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/DownloadInput */ \"(app-pages-browser)/./components/DownloadInput.tsx\");\n/* harmony import */ var _components_DownloadingState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/DownloadingState */ \"(app-pages-browser)/./components/DownloadingState.tsx\");\n/* harmony import */ var _components_ErrorDisplay__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/ErrorDisplay */ \"(app-pages-browser)/./components/ErrorDisplay.tsx\");\n/* harmony import */ var _components_ScreenLoader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/components/ScreenLoader */ \"(app-pages-browser)/./components/ScreenLoader.tsx\");\n/* harmony import */ var _components_ConfigSelector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/components/ConfigSelector */ \"(app-pages-browser)/./components/ConfigSelector.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nfunction MainApp() {\n    _s();\n    const { state, setMode, reset } = (0,_components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__.useApp)();\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    if (loading) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ScreenLoader__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n            onComplete: ()=>setLoading(false)\n        }, void 0, false, {\n            fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n            lineNumber: 18,\n            columnNumber: 16\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"full-screen\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: \"absolute\",\n                    top: \"2rem\",\n                    right: \"2rem\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    className: \"brutal-button\",\n                    onClick: ()=>setMode(state.mode === \"UPLOAD\" ? \"DOWNLOAD\" : \"UPLOAD\"),\n                    children: state.mode === \"UPLOAD\" ? \"SWITCH TO DOWNLOAD\" : \"SWITCH TO UPLOAD\"\n                }, void 0, false, {\n                    fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n                    lineNumber: 24,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n                lineNumber: 23,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"brutal-container\",\n                style: {\n                    maxWidth: \"600px\",\n                    width: \"100%\",\n                    minHeight: \"400px\",\n                    display: \"flex\",\n                    flexDirection: \"column\",\n                    justifyContent: \"center\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-center\",\n                        style: {\n                            marginBottom: \"var(--space-xl)\",\n                            cursor: \"pointer\"\n                        },\n                        onClick: reset,\n                        role: \"button\",\n                        tabIndex: 0,\n                        onKeyDown: (e)=>(e.key === \"Enter\" || e.key === \" \") && reset(),\n                        children: \"DropCode\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n                        lineNumber: 33,\n                        columnNumber: 17\n                    }, this),\n                    (state.status === \"IDLE\" || state.status === \"READY\") && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ConfigSelector__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {}, void 0, false, {\n                                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n                                lineNumber: 46,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_UploadZone__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n                                lineNumber: 47,\n                                columnNumber: 25\n                            }, this)\n                        ]\n                    }, void 0, true),\n                    state.status === \"UPLOADING\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ScreenLoader__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                        messages: [\n                            \"SEALING FILE\",\n                            \"BURNING LINK\",\n                            \"SETTING EXPIRY\",\n                            \"DO NOT REFRESH\",\n                            \"(YOU WILL ANYWAY)\"\n                        ]\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n                        lineNumber: 51,\n                        columnNumber: 21\n                    }, this),\n                    state.status === \"GENERATED\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_CodeDisplay__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n                        lineNumber: 61,\n                        columnNumber: 50\n                    }, this),\n                    state.status === \"DOWNLOAD_ENTRY\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_DownloadInput__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {}, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n                        lineNumber: 63,\n                        columnNumber: 55\n                    }, this),\n                    state.status === \"DOWNLOADING\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_DownloadingState__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {}, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n                        lineNumber: 64,\n                        columnNumber: 52\n                    }, this),\n                    state.status === \"ERROR\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ErrorDisplay__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {}, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n                        lineNumber: 66,\n                        columnNumber: 46\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n                lineNumber: 32,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\MainApp.tsx\",\n        lineNumber: 22,\n        columnNumber: 9\n    }, this);\n}\n_s(MainApp, \"Ezwlaegxeslp+TxzfsszX7jZoJc=\", false, function() {\n    return [\n        _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__.useApp\n    ];\n});\n_c = MainApp;\nvar _c;\n$RefreshReg$(_c, \"MainApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTWFpbkFwcC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDNEM7QUFDZ0I7QUFDWDtBQUVFO0FBQ0k7QUFDTTtBQUNSO0FBQ0E7QUFDSTtBQUUxQyxTQUFTUzs7SUFDcEIsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxFQUFFLEdBQUdYLHlFQUFNQTtJQUN4QyxNQUFNLENBQUNZLFNBQVNDLFdBQVcsR0FBR2QsK0NBQVFBLENBQUM7SUFFdkMsSUFBSWEsU0FBUztRQUNULHFCQUFPLDhEQUFDTixnRUFBWUE7WUFBQ1EsWUFBWSxJQUFNRCxXQUFXOzs7Ozs7SUFDdEQ7SUFFQSxxQkFDSSw4REFBQ0U7UUFBSUMsV0FBVTs7MEJBQ1gsOERBQUNEO2dCQUFJRSxPQUFPO29CQUFFQyxVQUFVO29CQUFZQyxLQUFLO29CQUFRQyxPQUFPO2dCQUFPOzBCQUMzRCw0RUFBQ0M7b0JBQ0dMLFdBQVU7b0JBQ1ZNLFNBQVMsSUFBTVosUUFBUUQsTUFBTWMsSUFBSSxLQUFLLFdBQVcsYUFBYTs4QkFFN0RkLE1BQU1jLElBQUksS0FBSyxXQUFXLHVCQUF1Qjs7Ozs7Ozs7Ozs7MEJBSTFELDhEQUFDUjtnQkFBSUMsV0FBVTtnQkFBbUJDLE9BQU87b0JBQUVPLFVBQVU7b0JBQVNDLE9BQU87b0JBQVFDLFdBQVc7b0JBQVNDLFNBQVM7b0JBQVFDLGVBQWU7b0JBQVVDLGdCQUFnQjtnQkFBUzs7a0NBQ2hLLDhEQUFDQzt3QkFDR2QsV0FBVTt3QkFDVkMsT0FBTzs0QkFBRWMsY0FBYzs0QkFBbUJDLFFBQVE7d0JBQVU7d0JBQzVEVixTQUFTWDt3QkFDVHNCLE1BQUs7d0JBQ0xDLFVBQVU7d0JBQ1ZDLFdBQVcsQ0FBQ0MsSUFBTSxDQUFDQSxFQUFFQyxHQUFHLEtBQUssV0FBV0QsRUFBRUMsR0FBRyxLQUFLLEdBQUUsS0FBTTFCO2tDQUM3RDs7Ozs7O29CQUlDRixDQUFBQSxNQUFNNkIsTUFBTSxLQUFLLFVBQVU3QixNQUFNNkIsTUFBTSxLQUFLLE9BQU0sbUJBQ2hEOzswQ0FDSSw4REFBQy9CLGtFQUFjQTs7Ozs7MENBQ2YsOERBQUNOLDhEQUFVQTs7Ozs7OztvQkFHbEJRLE1BQU02QixNQUFNLEtBQUssNkJBQ2QsOERBQUNoQyxnRUFBWUE7d0JBQ1RpQyxVQUFVOzRCQUNOOzRCQUNBOzRCQUNBOzRCQUNBOzRCQUNBO3lCQUNIOzs7Ozs7b0JBR1I5QixNQUFNNkIsTUFBTSxLQUFLLDZCQUFlLDhEQUFDcEMsK0RBQVdBOzs7OztvQkFFNUNPLE1BQU02QixNQUFNLEtBQUssa0NBQW9CLDhEQUFDbkMsaUVBQWFBOzs7OztvQkFDbkRNLE1BQU02QixNQUFNLEtBQUssK0JBQWlCLDhEQUFDbEMsb0VBQWdCQTs7Ozs7b0JBRW5ESyxNQUFNNkIsTUFBTSxLQUFLLHlCQUFXLDhEQUFDakMsZ0VBQVlBOzs7Ozs7Ozs7Ozs7Ozs7OztBQUkxRDtHQXpEd0JHOztRQUNjUixxRUFBTUE7OztLQURwQlEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9NYWluQXBwLnRzeD84OGUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VBcHAgfSBmcm9tICdAL2NvbXBvbmVudHMvcHJvdmlkZXJzL0FwcFByb3ZpZGVyJztcclxuaW1wb3J0IFVwbG9hZFpvbmUgZnJvbSAnQC9jb21wb25lbnRzL1VwbG9hZFpvbmUnO1xyXG5pbXBvcnQgVXBsb2FkaW5nU3RhdGUgZnJvbSAnQC9jb21wb25lbnRzL1VwbG9hZGluZ1N0YXRlJztcclxuaW1wb3J0IENvZGVEaXNwbGF5IGZyb20gJ0AvY29tcG9uZW50cy9Db2RlRGlzcGxheSc7XHJcbmltcG9ydCBEb3dubG9hZElucHV0IGZyb20gJ0AvY29tcG9uZW50cy9Eb3dubG9hZElucHV0JztcclxuaW1wb3J0IERvd25sb2FkaW5nU3RhdGUgZnJvbSAnQC9jb21wb25lbnRzL0Rvd25sb2FkaW5nU3RhdGUnO1xyXG5pbXBvcnQgRXJyb3JEaXNwbGF5IGZyb20gJ0AvY29tcG9uZW50cy9FcnJvckRpc3BsYXknO1xyXG5pbXBvcnQgU2NyZWVuTG9hZGVyIGZyb20gJ0AvY29tcG9uZW50cy9TY3JlZW5Mb2FkZXInO1xyXG5pbXBvcnQgQ29uZmlnU2VsZWN0b3IgZnJvbSAnQC9jb21wb25lbnRzL0NvbmZpZ1NlbGVjdG9yJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1haW5BcHAoKSB7XHJcbiAgICBjb25zdCB7IHN0YXRlLCBzZXRNb2RlLCByZXNldCB9ID0gdXNlQXBwKCk7XHJcbiAgICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcclxuXHJcbiAgICBpZiAobG9hZGluZykge1xyXG4gICAgICAgIHJldHVybiA8U2NyZWVuTG9hZGVyIG9uQ29tcGxldGU9eygpID0+IHNldExvYWRpbmcoZmFsc2UpfSAvPjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZnVsbC1zY3JlZW5cIj5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiAnMnJlbScsIHJpZ2h0OiAnMnJlbScgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnJ1dGFsLWJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0TW9kZShzdGF0ZS5tb2RlID09PSAnVVBMT0FEJyA/ICdET1dOTE9BRCcgOiAnVVBMT0FEJyl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge3N0YXRlLm1vZGUgPT09ICdVUExPQUQnID8gJ1NXSVRDSCBUTyBET1dOTE9BRCcgOiAnU1dJVENIIFRPIFVQTE9BRCd9XHJcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJydXRhbC1jb250YWluZXJcIiBzdHlsZT17eyBtYXhXaWR0aDogJzYwMHB4Jywgd2lkdGg6ICcxMDAlJywgbWluSGVpZ2h0OiAnNDAwcHgnLCBkaXNwbGF5OiAnZmxleCcsIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLCBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicgfX0+XHJcbiAgICAgICAgICAgICAgICA8aDFcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlclwiXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAndmFyKC0tc3BhY2UteGwpJywgY3Vyc29yOiAncG9pbnRlcicgfX1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtyZXNldH1cclxuICAgICAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcclxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD17MH1cclxuICAgICAgICAgICAgICAgICAgICBvbktleURvd249eyhlKSA9PiAoZS5rZXkgPT09ICdFbnRlcicgfHwgZS5rZXkgPT09ICcgJykgJiYgcmVzZXQoKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICBEcm9wQ29kZVxyXG4gICAgICAgICAgICAgICAgPC9oMT5cclxuXHJcbiAgICAgICAgICAgICAgICB7KHN0YXRlLnN0YXR1cyA9PT0gJ0lETEUnIHx8IHN0YXRlLnN0YXR1cyA9PT0gJ1JFQURZJykgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDb25maWdTZWxlY3RvciAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VXBsb2FkWm9uZSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvPlxyXG4gICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgIHtzdGF0ZS5zdGF0dXMgPT09ICdVUExPQURJTkcnICYmIChcclxuICAgICAgICAgICAgICAgICAgICA8U2NyZWVuTG9hZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzPXtbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlNFQUxJTkcgRklMRVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJCVVJOSU5HIExJTktcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU0VUVElORyBFWFBJUllcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRE8gTk9UIFJFRlJFU0hcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFlPVSBXSUxMIEFOWVdBWSlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAge3N0YXRlLnN0YXR1cyA9PT0gJ0dFTkVSQVRFRCcgJiYgPENvZGVEaXNwbGF5IC8+fVxyXG5cclxuICAgICAgICAgICAgICAgIHtzdGF0ZS5zdGF0dXMgPT09ICdET1dOTE9BRF9FTlRSWScgJiYgPERvd25sb2FkSW5wdXQgLz59XHJcbiAgICAgICAgICAgICAgICB7c3RhdGUuc3RhdHVzID09PSAnRE9XTkxPQURJTkcnICYmIDxEb3dubG9hZGluZ1N0YXRlIC8+fVxyXG5cclxuICAgICAgICAgICAgICAgIHtzdGF0ZS5zdGF0dXMgPT09ICdFUlJPUicgJiYgPEVycm9yRGlzcGxheSAvPn1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUFwcCIsIlVwbG9hZFpvbmUiLCJDb2RlRGlzcGxheSIsIkRvd25sb2FkSW5wdXQiLCJEb3dubG9hZGluZ1N0YXRlIiwiRXJyb3JEaXNwbGF5IiwiU2NyZWVuTG9hZGVyIiwiQ29uZmlnU2VsZWN0b3IiLCJNYWluQXBwIiwic3RhdGUiLCJzZXRNb2RlIiwicmVzZXQiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsIm9uQ29tcGxldGUiLCJkaXYiLCJjbGFzc05hbWUiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwicmlnaHQiLCJidXR0b24iLCJvbkNsaWNrIiwibW9kZSIsIm1heFdpZHRoIiwid2lkdGgiLCJtaW5IZWlnaHQiLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsImp1c3RpZnlDb250ZW50IiwiaDEiLCJtYXJnaW5Cb3R0b20iLCJjdXJzb3IiLCJyb2xlIiwidGFiSW5kZXgiLCJvbktleURvd24iLCJlIiwia2V5Iiwic3RhdHVzIiwibWVzc2FnZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/MainApp.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ScreenLoader.tsx":
/*!*************************************!*\
  !*** ./components/ScreenLoader.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ScreenLoader; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction ScreenLoader(param) {\n    let { onComplete, messages } = param;\n    _s();\n    const [msgIndex, setMsgIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const defaultMessages = [\n        \"INITIALIZING\",\n        \"LOADING ASSETS\",\n        \"PREPARING DROP\"\n    ];\n    const msgs = messages || defaultMessages;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const interval = setInterval(()=>{\n            setMsgIndex((current)=>(current + 1) % msgs.length);\n        }, 1500);\n        // If onComplete is provided, trigger it after a set time (e.g. 2s)\n        // so it doesn't loop forever as a splash screen.\n        let timeout;\n        if (onComplete) {\n            timeout = setTimeout(()=>{\n                onComplete();\n            }, 2000);\n        }\n        return ()=>{\n            clearInterval(interval);\n            if (timeout) clearTimeout(timeout);\n        };\n    }, [\n        onComplete,\n        msgs.length\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed inset-0 z-50 flex flex-col items-center justify-center overflow-hidden bg-[var(--color-bg-body)]\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative w-32 h-32 flex items-center justify-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"absolute w-full h-full border-black bg-white animate-compress\",\n                        style: {\n                            borderStyle: \"solid\",\n                            boxShadow: \"8px 8px 0 rgba(0,0,0,0.1)\"\n                        }\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ScreenLoader.tsx\",\n                        lineNumber: 39,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"absolute z-10 w-12 h-12 bg-black animate-lock\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ScreenLoader.tsx\",\n                        lineNumber: 48,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ScreenLoader.tsx\",\n                lineNumber: 37,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mt-12 h-8 flex items-center justify-center\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"font-bold font-mono text-xl tracking-widest uppercase\",\n                    children: msgs[msgIndex]\n                }, void 0, false, {\n                    fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ScreenLoader.tsx\",\n                    lineNumber: 53,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ScreenLoader.tsx\",\n                lineNumber: 52,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mt-2 opacity-50 font-mono text-xs uppercase\",\n                children: \"DropCode v2.0\"\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ScreenLoader.tsx\",\n                lineNumber: 59,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\ScreenLoader.tsx\",\n        lineNumber: 34,\n        columnNumber: 9\n    }, this);\n}\n_s(ScreenLoader, \"v7R7NwXNYh27TvhMwCk9oiMmpYk=\");\n_c = ScreenLoader;\nvar _c;\n$RefreshReg$(_c, \"ScreenLoader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU2NyZWVuTG9hZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDbUQ7QUFFcEMsU0FBU0csYUFBYSxLQUEwRTtRQUExRSxFQUFFQyxVQUFVLEVBQUVDLFFBQVEsRUFBb0QsR0FBMUU7O0lBQ2pDLE1BQU0sQ0FBQ0MsVUFBVUMsWUFBWSxHQUFHTCwrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNTSxrQkFBa0I7UUFDcEI7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNQyxPQUFPSixZQUFZRztJQUV6QlAsZ0RBQVNBLENBQUM7UUFDTixNQUFNUyxXQUFXQyxZQUFZO1lBQ3pCSixZQUFZLENBQUNLLFVBQVksQ0FBQ0EsVUFBVSxLQUFLSCxLQUFLSSxNQUFNO1FBQ3hELEdBQUc7UUFFSCxtRUFBbUU7UUFDbkUsaURBQWlEO1FBQ2pELElBQUlDO1FBQ0osSUFBSVYsWUFBWTtZQUNaVSxVQUFVQyxXQUFXO2dCQUNqQlg7WUFDSixHQUFHO1FBQ1A7UUFFQSxPQUFPO1lBQ0hZLGNBQWNOO1lBQ2QsSUFBSUksU0FBU0csYUFBYUg7UUFDOUI7SUFDSixHQUFHO1FBQUNWO1FBQVlLLEtBQUtJLE1BQU07S0FBQztJQUU1QixxQkFDSSw4REFBQ0s7UUFBSUMsV0FBVTs7MEJBR1gsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FFWCw4REFBQ0Q7d0JBQ0dDLFdBQVU7d0JBQ1ZDLE9BQU87NEJBQ0hDLGFBQWE7NEJBQ2JDLFdBQVc7d0JBQ2Y7Ozs7OztrQ0FJSiw4REFBQ0o7d0JBQUlDLFdBQVU7Ozs7Ozs7Ozs7OzswQkFJbkIsOERBQUNEO2dCQUFJQyxXQUFVOzBCQUNYLDRFQUFDSTtvQkFBRUosV0FBVTs4QkFDUlYsSUFBSSxDQUFDSCxTQUFTOzs7Ozs7Ozs7OzswQkFLdkIsOERBQUNZO2dCQUFJQyxXQUFVOzBCQUE4Qzs7Ozs7Ozs7Ozs7O0FBS3pFO0dBNUR3QmhCO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvU2NyZWVuTG9hZGVyLnRzeD84YWEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNjcmVlbkxvYWRlcih7IG9uQ29tcGxldGUsIG1lc3NhZ2VzIH06IHsgb25Db21wbGV0ZT86ICgpID0+IHZvaWQsIG1lc3NhZ2VzPzogc3RyaW5nW10gfSkge1xyXG4gICAgY29uc3QgW21zZ0luZGV4LCBzZXRNc2dJbmRleF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IGRlZmF1bHRNZXNzYWdlcyA9IFtcclxuICAgICAgICBcIklOSVRJQUxJWklOR1wiLFxyXG4gICAgICAgIFwiTE9BRElORyBBU1NFVFNcIixcclxuICAgICAgICBcIlBSRVBBUklORyBEUk9QXCIsXHJcbiAgICBdO1xyXG4gICAgY29uc3QgbXNncyA9IG1lc3NhZ2VzIHx8IGRlZmF1bHRNZXNzYWdlcztcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRNc2dJbmRleCgoY3VycmVudCkgPT4gKGN1cnJlbnQgKyAxKSAlIG1zZ3MubGVuZ3RoKTtcclxuICAgICAgICB9LCAxNTAwKTtcclxuXHJcbiAgICAgICAgLy8gSWYgb25Db21wbGV0ZSBpcyBwcm92aWRlZCwgdHJpZ2dlciBpdCBhZnRlciBhIHNldCB0aW1lIChlLmcuIDJzKVxyXG4gICAgICAgIC8vIHNvIGl0IGRvZXNuJ3QgbG9vcCBmb3JldmVyIGFzIGEgc3BsYXNoIHNjcmVlbi5cclxuICAgICAgICBsZXQgdGltZW91dDogTm9kZUpTLlRpbWVvdXQ7XHJcbiAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9LCAyMDAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbb25Db21wbGV0ZSwgbXNncy5sZW5ndGhdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZml4ZWQgaW5zZXQtMCB6LTUwIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG92ZXJmbG93LWhpZGRlbiBiZy1bdmFyKC0tY29sb3ItYmctYm9keSldXCI+XHJcblxyXG4gICAgICAgICAgICB7LyogVGhlIEJveCAqL31cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSB3LTMyIGgtMzIgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIj5cclxuICAgICAgICAgICAgICAgIHsvKiBPdXRlciBGcmFtZSAtIFNxdWFzaGVzICovfVxyXG4gICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIHctZnVsbCBoLWZ1bGwgYm9yZGVyLWJsYWNrIGJnLXdoaXRlIGFuaW1hdGUtY29tcHJlc3NcIlxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6ICc4cHggOHB4IDAgcmdiYSgwLDAsMCwwLjEpJ1xyXG4gICAgICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICA+PC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgey8qIElubmVyIExvY2svU3ltYm9sIC0gU25hcHMgaW4gKi99XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHotMTAgdy0xMiBoLTEyIGJnLWJsYWNrIGFuaW1hdGUtbG9ja1wiPjwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHsvKiBNaWNyb2NvcHkgKi99XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMTIgaC04IGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LWJvbGQgZm9udC1tb25vIHRleHQteGwgdHJhY2tpbmctd2lkZXN0IHVwcGVyY2FzZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHttc2dzW21zZ0luZGV4XX1cclxuICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICB7LyogU3VidGV4dCAqL31cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC0yIG9wYWNpdHktNTAgZm9udC1tb25vIHRleHQteHMgdXBwZXJjYXNlXCI+XHJcbiAgICAgICAgICAgICAgICBEcm9wQ29kZSB2Mi4wXHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIlNjcmVlbkxvYWRlciIsIm9uQ29tcGxldGUiLCJtZXNzYWdlcyIsIm1zZ0luZGV4Iiwic2V0TXNnSW5kZXgiLCJkZWZhdWx0TWVzc2FnZXMiLCJtc2dzIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImN1cnJlbnQiLCJsZW5ndGgiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFySW50ZXJ2YWwiLCJjbGVhclRpbWVvdXQiLCJkaXYiLCJjbGFzc05hbWUiLCJzdHlsZSIsImJvcmRlclN0eWxlIiwiYm94U2hhZG93IiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ScreenLoader.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/UploadZone.tsx":
/*!***********************************!*\
  !*** ./components/UploadZone.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ UploadZone; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/providers/AppProvider */ \"(app-pages-browser)/./components/providers/AppProvider.tsx\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction UploadZone() {\n    _s();\n    const { state, startUpload, setProgress, uploadSuccess, uploadError } = (0,_components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__.useApp)();\n    const [isDragOver, setIsDragOver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isReady = state.status === \"READY\";\n    const handleFile = async (files)=>{\n        if (!files || files.length === 0) return;\n        // Guardrail: Must be READY\n        if (!isReady) {\n            alert(\"Please select Expiry and Download Limit first.\");\n            return;\n        }\n        // Calculate total size\n        let totalSize = 0;\n        const fileList = files instanceof FileList ? Array.from(files) : files;\n        // This is safe because we just converted it to an array\n        for (const file of fileList){\n            totalSize += file.size;\n        }\n        // Check MVP file size limit (200MB total)\n        if (totalSize > 200 * 1024 * 1024) {\n            alert(\"Total size too large (Max 200MB)\");\n            return;\n        }\n        startUpload();\n        try {\n            // Pass the config from state\n            const settings = {\n                expiryMinutes: state.config.expiry,\n                maxDownloads: state.config.maxDownloads\n            };\n            const data = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_3__.uploadFile)(fileList, settings, (percent)=>{\n                setProgress(percent);\n            });\n            // Small delay to ensure users see 100% completion\n            setTimeout(()=>{\n                uploadSuccess(data);\n            }, 300);\n        } catch (err) {\n            console.error(err);\n            uploadError(err.error || \"Upload failed\");\n        }\n    };\n    const onDrop = (e)=>{\n        e.preventDefault();\n        setIsDragOver(false);\n        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n            handleFile(e.dataTransfer.files);\n        }\n    };\n    const onDragOver = (e)=>{\n        e.preventDefault();\n        setIsDragOver(true);\n    };\n    const onDragLeave = ()=>{\n        setIsDragOver(false);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"brutal-upload-zone \".concat(isDragOver ? \"dragover\" : \"\"),\n        style: {\n            opacity: isReady ? 1 : 0.5,\n            cursor: isReady ? \"pointer\" : \"not-allowed\",\n            position: \"relative\"\n        },\n        onDrop: onDrop,\n        onDragOver: onDragOver,\n        onDragLeave: onDragLeave,\n        onClick: ()=>{\n            var _fileInputRef_current;\n            return isReady && ((_fileInputRef_current = fileInputRef.current) === null || _fileInputRef_current === void 0 ? void 0 : _fileInputRef_current.click());\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                type: \"file\",\n                multiple: true,\n                accept: \"*/*\",\n                style: {\n                    display: \"none\"\n                },\n                ref: fileInputRef,\n                onChange: (e)=>handleFile(e.target.files),\n                \"aria-label\": \"Upload File\",\n                disabled: !isReady\n            }, void 0, false, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\UploadZone.tsx\",\n                lineNumber: 88,\n                columnNumber: 13\n            }, this),\n            !isReady ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"font-bold uppercase\",\n                        style: {\n                            fontSize: \"1.2rem\",\n                            color: \"black\"\n                        },\n                        children: \"CONFIGURATION REQUIRED\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\UploadZone.tsx\",\n                        lineNumber: 101,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-mono\",\n                        style: {\n                            fontSize: \"0.9rem\",\n                            marginTop: \"var(--space-sm)\"\n                        },\n                        children: \"SELECT EXPIRY & LIMIT ABOVE\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\UploadZone.tsx\",\n                        lineNumber: 104,\n                        columnNumber: 21\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\UploadZone.tsx\",\n                lineNumber: 100,\n                columnNumber: 17\n            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"font-bold uppercase\",\n                        style: {\n                            fontSize: \"1.5rem\",\n                            pointerEvents: \"none\"\n                        },\n                        children: isDragOver ? \"Drop It!\" : \"Drop File Here\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\UploadZone.tsx\",\n                        lineNumber: 110,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        style: {\n                            marginTop: \"var(--space-md)\",\n                            color: \"black\",\n                            pointerEvents: \"none\",\n                            fontWeight: \"bold\"\n                        },\n                        children: \"CLICK IF YOU MUST\"\n                    }, void 0, false, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\UploadZone.tsx\",\n                        lineNumber: 113,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-mono\",\n                        style: {\n                            marginTop: \"var(--space-lg)\",\n                            fontSize: \"0.8rem\",\n                            color: \"black\",\n                            pointerEvents: \"none\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: \"MAX 200MB  ENCRYPTED\"\n                            }, void 0, false, {\n                                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\UploadZone.tsx\",\n                                lineNumber: 117,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: \"NO ACCOUNTS  NO LOGS\"\n                            }, void 0, false, {\n                                fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\UploadZone.tsx\",\n                                lineNumber: 118,\n                                columnNumber: 25\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\UploadZone.tsx\",\n                        lineNumber: 116,\n                        columnNumber: 21\n                    }, this)\n                ]\n            }, void 0, true)\n        ]\n    }, void 0, true, {\n        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\UploadZone.tsx\",\n        lineNumber: 76,\n        columnNumber: 9\n    }, this);\n}\n_s(UploadZone, \"o5HxhU8cJKrhyO8cEjMOYx/ZYkU=\", false, function() {\n    return [\n        _components_providers_AppProvider__WEBPACK_IMPORTED_MODULE_2__.useApp\n    ];\n});\n_c = UploadZone;\nvar _c;\n$RefreshReg$(_c, \"UploadZone\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvVXBsb2FkWm9uZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDb0Q7QUFDUTtBQUNyQjtBQUV4QixTQUFTSTs7SUFDcEIsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxhQUFhLEVBQUVDLFdBQVcsRUFBRSxHQUFHUCx5RUFBTUE7SUFDOUUsTUFBTSxDQUFDUSxZQUFZQyxjQUFjLEdBQUdWLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU1XLGVBQWVaLDZDQUFNQSxDQUFtQjtJQUU5QyxNQUFNYSxVQUFVUixNQUFNUyxNQUFNLEtBQUs7SUFFakMsTUFBTUMsYUFBYSxPQUFPQztRQUN0QixJQUFJLENBQUNBLFNBQVNBLE1BQU1DLE1BQU0sS0FBSyxHQUFHO1FBRWxDLDJCQUEyQjtRQUMzQixJQUFJLENBQUNKLFNBQVM7WUFDVkssTUFBTTtZQUNOO1FBQ0o7UUFFQSx1QkFBdUI7UUFDdkIsSUFBSUMsWUFBWTtRQUNoQixNQUFNQyxXQUFXSixpQkFBaUJLLFdBQVdDLE1BQU1DLElBQUksQ0FBQ1AsU0FBU0E7UUFFakUsd0RBQXdEO1FBQ3hELEtBQUssTUFBTVEsUUFBUUosU0FBb0I7WUFDbkNELGFBQWFLLEtBQUtDLElBQUk7UUFDMUI7UUFFQSwwQ0FBMEM7UUFDMUMsSUFBSU4sWUFBWSxNQUFNLE9BQU8sTUFBTTtZQUMvQkQsTUFBTTtZQUNOO1FBQ0o7UUFFQVo7UUFDQSxJQUFJO1lBQ0EsNkJBQTZCO1lBQzdCLE1BQU1vQixXQUFXO2dCQUNiQyxlQUFldEIsTUFBTXVCLE1BQU0sQ0FBQ0MsTUFBTTtnQkFDbENDLGNBQWN6QixNQUFNdUIsTUFBTSxDQUFDRSxZQUFZO1lBQzNDO1lBRUEsTUFBTUMsT0FBTyxNQUFNNUIsb0RBQVVBLENBQUNpQixVQUFvQk0sVUFBVSxDQUFDTTtnQkFDekR6QixZQUFZeUI7WUFDaEI7WUFDQSxrREFBa0Q7WUFDbERDLFdBQVc7Z0JBQ1B6QixjQUFjdUI7WUFDbEIsR0FBRztRQUNQLEVBQUUsT0FBT0csS0FBVTtZQUNmQyxRQUFRQyxLQUFLLENBQUNGO1lBQ2R6QixZQUFZeUIsSUFBSUUsS0FBSyxJQUFJO1FBQzdCO0lBQ0o7SUFFQSxNQUFNQyxTQUFTLENBQUNDO1FBQ1pBLEVBQUVDLGNBQWM7UUFDaEI1QixjQUFjO1FBQ2QsSUFBSTJCLEVBQUVFLFlBQVksQ0FBQ3hCLEtBQUssSUFBSXNCLEVBQUVFLFlBQVksQ0FBQ3hCLEtBQUssQ0FBQ0MsTUFBTSxHQUFHLEdBQUc7WUFDekRGLFdBQVd1QixFQUFFRSxZQUFZLENBQUN4QixLQUFLO1FBQ25DO0lBQ0o7SUFFQSxNQUFNeUIsYUFBYSxDQUFDSDtRQUNoQkEsRUFBRUMsY0FBYztRQUNoQjVCLGNBQWM7SUFDbEI7SUFFQSxNQUFNK0IsY0FBYztRQUNoQi9CLGNBQWM7SUFDbEI7SUFFQSxxQkFDSSw4REFBQ2dDO1FBQ0dDLFdBQVcsc0JBQW1ELE9BQTdCbEMsYUFBYSxhQUFhO1FBQzNEbUMsT0FBTztZQUNIQyxTQUFTakMsVUFBVSxJQUFJO1lBQ3ZCa0MsUUFBUWxDLFVBQVUsWUFBWTtZQUM5Qm1DLFVBQVU7UUFDZDtRQUNBWCxRQUFRQTtRQUNSSSxZQUFZQTtRQUNaQyxhQUFhQTtRQUNiTyxTQUFTO2dCQUFpQnJDO21CQUFYQyxhQUFXRCx3QkFBQUEsYUFBYXNDLE9BQU8sY0FBcEJ0Qyw0Q0FBQUEsc0JBQXNCdUMsS0FBSzs7OzBCQUVyRCw4REFBQ0M7Z0JBQ0dDLE1BQUs7Z0JBQ0xDLFFBQVE7Z0JBQ1JDLFFBQU87Z0JBQ1BWLE9BQU87b0JBQUVXLFNBQVM7Z0JBQU87Z0JBQ3pCQyxLQUFLN0M7Z0JBQ0w4QyxVQUFVLENBQUNwQixJQUFNdkIsV0FBV3VCLEVBQUVxQixNQUFNLENBQUMzQyxLQUFLO2dCQUMxQzRDLGNBQVc7Z0JBQ1hDLFVBQVUsQ0FBQ2hEOzs7Ozs7WUFHZCxDQUFDQSx3QkFDRSw4REFBQzhCO2dCQUFJQyxXQUFVOztrQ0FDWCw4REFBQ2tCO3dCQUFFbEIsV0FBVTt3QkFBc0JDLE9BQU87NEJBQUVrQixVQUFVOzRCQUFVQyxPQUFPO3dCQUFRO2tDQUFHOzs7Ozs7a0NBR2xGLDhEQUFDRjt3QkFBRWxCLFdBQVU7d0JBQVlDLE9BQU87NEJBQUVrQixVQUFVOzRCQUFVRSxXQUFXO3dCQUFrQjtrQ0FBRzs7Ozs7Ozs7Ozs7cUNBSzFGOztrQ0FDSSw4REFBQ0g7d0JBQUVsQixXQUFVO3dCQUFzQkMsT0FBTzs0QkFBRWtCLFVBQVU7NEJBQVVHLGVBQWU7d0JBQU87a0NBQ2pGeEQsYUFBYSxhQUFhOzs7Ozs7a0NBRS9CLDhEQUFDb0Q7d0JBQUVqQixPQUFPOzRCQUFFb0IsV0FBVzs0QkFBbUJELE9BQU87NEJBQVNFLGVBQWU7NEJBQVFDLFlBQVk7d0JBQU87a0NBQUc7Ozs7OztrQ0FHdkcsOERBQUN4Qjt3QkFBSUMsV0FBVTt3QkFBWUMsT0FBTzs0QkFBRW9CLFdBQVc7NEJBQW1CRixVQUFVOzRCQUFVQyxPQUFPOzRCQUFTRSxlQUFlO3dCQUFPOzswQ0FDeEgsOERBQUNKOzBDQUFFOzs7Ozs7MENBQ0gsOERBQUNBOzBDQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU0zQjtHQXRId0IxRDs7UUFDb0RGLHFFQUFNQTs7O0tBRDFERSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1VwbG9hZFpvbmUudHN4P2YzODMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcbmltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUsIERyYWdFdmVudCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlQXBwIH0gZnJvbSAnQC9jb21wb25lbnRzL3Byb3ZpZGVycy9BcHBQcm92aWRlcic7XHJcbmltcG9ydCB7IHVwbG9hZEZpbGUgfSBmcm9tICdAL2xpYi9hcGknO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVXBsb2FkWm9uZSgpIHtcclxuICAgIGNvbnN0IHsgc3RhdGUsIHN0YXJ0VXBsb2FkLCBzZXRQcm9ncmVzcywgdXBsb2FkU3VjY2VzcywgdXBsb2FkRXJyb3IgfSA9IHVzZUFwcCgpO1xyXG4gICAgY29uc3QgW2lzRHJhZ092ZXIsIHNldElzRHJhZ092ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgZmlsZUlucHV0UmVmID0gdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IGlzUmVhZHkgPSBzdGF0ZS5zdGF0dXMgPT09ICdSRUFEWSc7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRmlsZSA9IGFzeW5jIChmaWxlczogRmlsZUxpc3QgfCBGaWxlW10gfCBudWxsKSA9PiB7XHJcbiAgICAgICAgaWYgKCFmaWxlcyB8fCBmaWxlcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gR3VhcmRyYWlsOiBNdXN0IGJlIFJFQURZXHJcbiAgICAgICAgaWYgKCFpc1JlYWR5KSB7XHJcbiAgICAgICAgICAgIGFsZXJ0KCdQbGVhc2Ugc2VsZWN0IEV4cGlyeSBhbmQgRG93bmxvYWQgTGltaXQgZmlyc3QuJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0b3RhbCBzaXplXHJcbiAgICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7XHJcbiAgICAgICAgY29uc3QgZmlsZUxpc3QgPSBmaWxlcyBpbnN0YW5jZW9mIEZpbGVMaXN0ID8gQXJyYXkuZnJvbShmaWxlcykgOiBmaWxlcztcclxuXHJcbiAgICAgICAgLy8gVGhpcyBpcyBzYWZlIGJlY2F1c2Ugd2UganVzdCBjb252ZXJ0ZWQgaXQgdG8gYW4gYXJyYXlcclxuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZUxpc3QgYXMgRmlsZVtdKSB7XHJcbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBmaWxlLnNpemU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBNVlAgZmlsZSBzaXplIGxpbWl0ICgyMDBNQiB0b3RhbClcclxuICAgICAgICBpZiAodG90YWxTaXplID4gMjAwICogMTAyNCAqIDEwMjQpIHtcclxuICAgICAgICAgICAgYWxlcnQoJ1RvdGFsIHNpemUgdG9vIGxhcmdlIChNYXggMjAwTUIpJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0VXBsb2FkKCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gUGFzcyB0aGUgY29uZmlnIGZyb20gc3RhdGVcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICBleHBpcnlNaW51dGVzOiBzdGF0ZS5jb25maWcuZXhwaXJ5ISxcclxuICAgICAgICAgICAgICAgIG1heERvd25sb2Fkczogc3RhdGUuY29uZmlnLm1heERvd25sb2FkcyFcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB1cGxvYWRGaWxlKGZpbGVMaXN0IGFzIEZpbGVbXSwgc2V0dGluZ3MsIChwZXJjZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRQcm9ncmVzcyhwZXJjZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSB1c2VycyBzZWUgMTAwJSBjb21wbGV0aW9uXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdXBsb2FkU3VjY2VzcyhkYXRhKTtcclxuICAgICAgICAgICAgfSwgMzAwKTtcclxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgIHVwbG9hZEVycm9yKGVyci5lcnJvciB8fCAnVXBsb2FkIGZhaWxlZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb25Ecm9wID0gKGU6IERyYWdFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgc2V0SXNEcmFnT3ZlcihmYWxzZSk7XHJcbiAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyLmZpbGVzICYmIGUuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaGFuZGxlRmlsZShlLmRhdGFUcmFuc2Zlci5maWxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBvbkRyYWdPdmVyID0gKGU6IERyYWdFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgc2V0SXNEcmFnT3Zlcih0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb25EcmFnTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgc2V0SXNEcmFnT3ZlcihmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2BicnV0YWwtdXBsb2FkLXpvbmUgJHtpc0RyYWdPdmVyID8gJ2RyYWdvdmVyJyA6ICcnfWB9XHJcbiAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBpc1JlYWR5ID8gMSA6IDAuNSxcclxuICAgICAgICAgICAgICAgIGN1cnNvcjogaXNSZWFkeSA/ICdwb2ludGVyJyA6ICdub3QtYWxsb3dlZCcsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBvbkRyb3A9e29uRHJvcH1cclxuICAgICAgICAgICAgb25EcmFnT3Zlcj17b25EcmFnT3Zlcn1cclxuICAgICAgICAgICAgb25EcmFnTGVhdmU9e29uRHJhZ0xlYXZlfVxyXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBpc1JlYWR5ICYmIGZpbGVJbnB1dFJlZi5jdXJyZW50Py5jbGljaygpfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICB0eXBlPVwiZmlsZVwiXHJcbiAgICAgICAgICAgICAgICBtdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgYWNjZXB0PVwiKi8qXCJcclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdub25lJyB9fVxyXG4gICAgICAgICAgICAgICAgcmVmPXtmaWxlSW5wdXRSZWZ9XHJcbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IGhhbmRsZUZpbGUoZS50YXJnZXQuZmlsZXMpfVxyXG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlVwbG9hZCBGaWxlXCJcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXshaXNSZWFkeX1cclxuICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgIHshaXNSZWFkeSA/IChcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LWJvbGQgdXBwZXJjYXNlXCIgc3R5bGU9e3sgZm9udFNpemU6ICcxLjJyZW0nLCBjb2xvcjogJ2JsYWNrJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgQ09ORklHVVJBVElPTiBSRVFVSVJFRFxyXG4gICAgICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LW1vbm9cIiBzdHlsZT17eyBmb250U2l6ZTogJzAuOXJlbScsIG1hcmdpblRvcDogJ3ZhcigtLXNwYWNlLXNtKScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNFTEVDVCBFWFBJUlkgJiBMSU1JVCBBQk9WRVxyXG4gICAgICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LWJvbGQgdXBwZXJjYXNlXCIgc3R5bGU9e3sgZm9udFNpemU6ICcxLjVyZW0nLCBwb2ludGVyRXZlbnRzOiAnbm9uZScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtpc0RyYWdPdmVyID8gXCJEcm9wIEl0IVwiIDogXCJEcm9wIEZpbGUgSGVyZVwifVxyXG4gICAgICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICAgICAgICA8cCBzdHlsZT17eyBtYXJnaW5Ub3A6ICd2YXIoLS1zcGFjZS1tZCknLCBjb2xvcjogJ2JsYWNrJywgcG9pbnRlckV2ZW50czogJ25vbmUnLCBmb250V2VpZ2h0OiAnYm9sZCcgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENMSUNLIElGIFlPVSBNVVNUXHJcbiAgICAgICAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1tb25vXCIgc3R5bGU9e3sgbWFyZ2luVG9wOiAndmFyKC0tc3BhY2UtbGcpJywgZm9udFNpemU6ICcwLjhyZW0nLCBjb2xvcjogJ2JsYWNrJywgcG9pbnRlckV2ZW50czogJ25vbmUnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cD5NQVggMjAwTUIg4oCiIEVOQ1JZUFRFRDwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHA+Tk8gQUNDT1VOVFMg4oCiIE5PIExPR1M8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgKX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQXBwIiwidXBsb2FkRmlsZSIsIlVwbG9hZFpvbmUiLCJzdGF0ZSIsInN0YXJ0VXBsb2FkIiwic2V0UHJvZ3Jlc3MiLCJ1cGxvYWRTdWNjZXNzIiwidXBsb2FkRXJyb3IiLCJpc0RyYWdPdmVyIiwic2V0SXNEcmFnT3ZlciIsImZpbGVJbnB1dFJlZiIsImlzUmVhZHkiLCJzdGF0dXMiLCJoYW5kbGVGaWxlIiwiZmlsZXMiLCJsZW5ndGgiLCJhbGVydCIsInRvdGFsU2l6ZSIsImZpbGVMaXN0IiwiRmlsZUxpc3QiLCJBcnJheSIsImZyb20iLCJmaWxlIiwic2l6ZSIsInNldHRpbmdzIiwiZXhwaXJ5TWludXRlcyIsImNvbmZpZyIsImV4cGlyeSIsIm1heERvd25sb2FkcyIsImRhdGEiLCJwZXJjZW50Iiwic2V0VGltZW91dCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsIm9uRHJvcCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImRhdGFUcmFuc2ZlciIsIm9uRHJhZ092ZXIiLCJvbkRyYWdMZWF2ZSIsImRpdiIsImNsYXNzTmFtZSIsInN0eWxlIiwib3BhY2l0eSIsImN1cnNvciIsInBvc2l0aW9uIiwib25DbGljayIsImN1cnJlbnQiLCJjbGljayIsImlucHV0IiwidHlwZSIsIm11bHRpcGxlIiwiYWNjZXB0IiwiZGlzcGxheSIsInJlZiIsIm9uQ2hhbmdlIiwidGFyZ2V0IiwiYXJpYS1sYWJlbCIsImRpc2FibGVkIiwicCIsImZvbnRTaXplIiwiY29sb3IiLCJtYXJnaW5Ub3AiLCJwb2ludGVyRXZlbnRzIiwiZm9udFdlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/UploadZone.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/providers/AppProvider.tsx":
/*!**********************************************!*\
  !*** ./components/providers/AppProvider.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppProvider: function() { return /* binding */ AppProvider; },\n/* harmony export */   useApp: function() { return /* binding */ useApp; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ AppProvider,useApp auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst initialState = {\n    status: \"IDLE\",\n    data: null,\n    error: null,\n    progress: 0,\n    mode: \"UPLOAD\",\n    config: {\n        expiry: null,\n        maxDownloads: null\n    }\n};\nconst ACTIONS = {\n    SET_MODE: \"SET_MODE\",\n    START_UPLOAD: \"START_UPLOAD\",\n    SET_PROGRESS: \"SET_PROGRESS\",\n    UPLOAD_SUCCESS: \"UPLOAD_SUCCESS\",\n    UPLOAD_ERROR: \"UPLOAD_ERROR\",\n    ENTER_DOWNLOAD: \"ENTER_DOWNLOAD\",\n    FETCH_FILE_START: \"FETCH_FILE_START\",\n    FETCH_FILE_SUCCESS: \"FETCH_FILE_SUCCESS\",\n    FETCH_FILE_ERROR: \"FETCH_FILE_ERROR\",\n    RESET: \"RESET\",\n    SET_CONFIG_EXPIRY: \"SET_CONFIG_EXPIRY\",\n    SET_CONFIG_DOWNLOADS: \"SET_CONFIG_DOWNLOADS\"\n};\nfunction appReducer(state, action) {\n    switch(action.type){\n        case \"SET_MODE\":\n            return {\n                ...state,\n                mode: action.payload,\n                status: action.payload === \"UPLOAD\" ? \"IDLE\" : \"DOWNLOAD_ENTRY\",\n                error: null\n            };\n        case \"START_UPLOAD\":\n            return {\n                ...state,\n                status: \"UPLOADING\",\n                progress: 0,\n                error: null\n            };\n        case \"SET_PROGRESS\":\n            return {\n                ...state,\n                progress: action.payload\n            };\n        case \"UPLOAD_SUCCESS\":\n            return {\n                ...state,\n                status: \"GENERATED\",\n                data: action.payload,\n                progress: 100\n            };\n        case \"UPLOAD_ERROR\":\n            return {\n                ...state,\n                status: \"ERROR\",\n                error: action.payload,\n                progress: 0\n            };\n        case \"ENTER_DOWNLOAD\":\n            return {\n                ...state,\n                status: \"DOWNLOAD_ENTRY\",\n                error: null,\n                data: null\n            };\n        case \"FETCH_FILE_START\":\n            return {\n                ...state,\n                status: \"DOWNLOADING\",\n                progress: 0,\n                error: null\n            };\n        case \"FETCH_FILE_SUCCESS\":\n            return {\n                ...state,\n                status: \"DOWNLOADING\",\n                data: action.payload\n            };\n        case \"FETCH_FILE_ERROR\":\n            return {\n                ...state,\n                status: \"ERROR\",\n                error: action.payload\n            };\n        case \"RESET\":\n            // Keep the config on reset for better UX? Or clear it? \n            // Prompt says: \"Reset: UI state, Config selections\". So clear it.\n            return {\n                ...initialState,\n                mode: state.mode\n            };\n        case \"SET_CONFIG_EXPIRY\":\n            {\n                const newConfig = {\n                    ...state.config,\n                    expiry: action.payload\n                };\n                const isReady = newConfig.expiry !== null && newConfig.maxDownloads !== null;\n                return {\n                    ...state,\n                    config: newConfig,\n                    status: isReady && state.status === \"IDLE\" ? \"READY\" : state.status\n                };\n            }\n        case \"SET_CONFIG_DOWNLOADS\":\n            {\n                const newConfig = {\n                    ...state.config,\n                    maxDownloads: action.payload\n                };\n                const isReady = newConfig.expiry !== null && newConfig.maxDownloads !== null;\n                return {\n                    ...state,\n                    config: newConfig,\n                    status: isReady && state.status === \"IDLE\" ? \"READY\" : state.status\n                };\n            }\n        default:\n            return state;\n    }\n}\nconst AppContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction AppProvider(param) {\n    let { children } = param;\n    _s();\n    const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useReducer)(appReducer, initialState);\n    const value = {\n        state,\n        setMode: (mode)=>dispatch({\n                type: \"SET_MODE\",\n                payload: mode\n            }),\n        startUpload: ()=>dispatch({\n                type: \"START_UPLOAD\"\n            }),\n        setProgress: (progress)=>dispatch({\n                type: \"SET_PROGRESS\",\n                payload: progress\n            }),\n        uploadSuccess: (data)=>dispatch({\n                type: \"UPLOAD_SUCCESS\",\n                payload: data\n            }),\n        uploadError: (error)=>dispatch({\n                type: \"UPLOAD_ERROR\",\n                payload: error\n            }),\n        enterDownload: ()=>dispatch({\n                type: \"ENTER_DOWNLOAD\"\n            }),\n        fetchFileStart: ()=>dispatch({\n                type: \"FETCH_FILE_START\"\n            }),\n        fetchFileSuccess: (data)=>dispatch({\n                type: \"FETCH_FILE_SUCCESS\",\n                payload: data\n            }),\n        fetchFileError: (error)=>dispatch({\n                type: \"FETCH_FILE_ERROR\",\n                payload: error\n            }),\n        reset: ()=>dispatch({\n                type: \"RESET\"\n            }),\n        setExpiry: (minutes)=>dispatch({\n                type: \"SET_CONFIG_EXPIRY\",\n                payload: minutes\n            }),\n        setDownloads: (count)=>dispatch({\n                type: \"SET_CONFIG_DOWNLOADS\",\n                payload: count\n            })\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AppContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"X:\\\\projects\\\\DropCode\\\\components\\\\providers\\\\AppProvider.tsx\",\n        lineNumber: 138,\n        columnNumber: 12\n    }, this);\n}\n_s(AppProvider, \"6JWkGZ32UPfojeNx+xqn8ZU8A0Q=\");\n_c = AppProvider;\nfunction useApp() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AppContext);\n    if (!context) {\n        throw new Error(\"useApp must be used within an AppProvider\");\n    }\n    return context;\n}\n_s1(useApp, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvcHJvdmlkZXJzL0FwcFByb3ZpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRXlFO0FBZXpFLE1BQU1HLGVBQXlCO0lBQzNCQyxRQUFRO0lBQ1JDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxVQUFVO0lBQ1ZDLE1BQU07SUFDTkMsUUFBUTtRQUNKQyxRQUFRO1FBQ1JDLGNBQWM7SUFDbEI7QUFDSjtBQUVBLE1BQU1DLFVBQVU7SUFDWkMsVUFBVTtJQUNWQyxjQUFjO0lBQ2RDLGNBQWM7SUFDZEMsZ0JBQWdCO0lBQ2hCQyxjQUFjO0lBQ2RDLGdCQUFnQjtJQUNoQkMsa0JBQWtCO0lBQ2xCQyxvQkFBb0I7SUFDcEJDLGtCQUFrQjtJQUNsQkMsT0FBTztJQUNQQyxtQkFBbUI7SUFDbkJDLHNCQUFzQjtBQUMxQjtBQWdCQSxTQUFTQyxXQUFXQyxLQUFlLEVBQUVDLE1BQWM7SUFDL0MsT0FBUUEsT0FBT0MsSUFBSTtRQUNmLEtBQUs7WUFDRCxPQUFPO2dCQUNILEdBQUdGLEtBQUs7Z0JBQ1JsQixNQUFNbUIsT0FBT0UsT0FBTztnQkFDcEJ6QixRQUFRdUIsT0FBT0UsT0FBTyxLQUFLLFdBQVcsU0FBUztnQkFDL0N2QixPQUFPO1lBQ1g7UUFDSixLQUFLO1lBQ0QsT0FBTztnQkFBRSxHQUFHb0IsS0FBSztnQkFBRXRCLFFBQVE7Z0JBQWFHLFVBQVU7Z0JBQUdELE9BQU87WUFBSztRQUNyRSxLQUFLO1lBQ0QsT0FBTztnQkFBRSxHQUFHb0IsS0FBSztnQkFBRW5CLFVBQVVvQixPQUFPRSxPQUFPO1lBQUM7UUFDaEQsS0FBSztZQUNELE9BQU87Z0JBQUUsR0FBR0gsS0FBSztnQkFBRXRCLFFBQVE7Z0JBQWFDLE1BQU1zQixPQUFPRSxPQUFPO2dCQUFFdEIsVUFBVTtZQUFJO1FBQ2hGLEtBQUs7WUFDRCxPQUFPO2dCQUFFLEdBQUdtQixLQUFLO2dCQUFFdEIsUUFBUTtnQkFBU0UsT0FBT3FCLE9BQU9FLE9B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YyxDQUFDQyxRQUFrQmYsU0FBUztnQkFBRVAsTUFBTTtnQkFBd0JDLFNBQVNxQjtZQUFNO0lBQzdGO0lBRUEscUJBQU8sOERBQUNsQixXQUFXbUIsUUFBUTtRQUFDZixPQUFPQTtrQkFBUUY7Ozs7OztBQUMvQztHQXBCZ0JEO0tBQUFBO0FBc0JULFNBQVNtQjs7SUFDWixNQUFNQyxVQUFVcEQsaURBQVVBLENBQUMrQjtJQUMzQixJQUFJLENBQUNxQixTQUFTO1FBQ1YsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0EsT0FBT0Q7QUFDWDtJQU5nQkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9wcm92aWRlcnMvQXBwUHJvdmlkZXIudHN4PzllZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VSZWR1Y2VyLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IEZpbGVNZXRhZGF0YSB9IGZyb20gJ0AvbGliL2FwaSc7XHJcblxyXG5leHBvcnQgdHlwZSBBcHBTdGF0ZSA9IHtcclxuICAgIHN0YXR1czogJ0lETEUnIHwgJ1JFQURZJyB8ICdVUExPQURJTkcnIHwgJ0dFTkVSQVRFRCcgfCAnRE9XTkxPQURfRU5UUlknIHwgJ0RPV05MT0FESU5HJyB8ICdFUlJPUic7XHJcbiAgICBkYXRhOiBGaWxlTWV0YWRhdGEgfCBudWxsO1xyXG4gICAgZXJyb3I6IHN0cmluZyB8IG51bGw7XHJcbiAgICBwcm9ncmVzczogbnVtYmVyO1xyXG4gICAgbW9kZTogJ1VQTE9BRCcgfCAnRE9XTkxPQUQnO1xyXG4gICAgY29uZmlnOiB7XHJcbiAgICAgICAgZXhwaXJ5OiBudW1iZXIgfCBudWxsO1xyXG4gICAgICAgIG1heERvd25sb2FkczogbnVtYmVyIHwgbnVsbDtcclxuICAgIH07XHJcbn07XHJcblxyXG5jb25zdCBpbml0aWFsU3RhdGU6IEFwcFN0YXRlID0ge1xyXG4gICAgc3RhdHVzOiAnSURMRScsXHJcbiAgICBkYXRhOiBudWxsLFxyXG4gICAgZXJyb3I6IG51bGwsXHJcbiAgICBwcm9ncmVzczogMCxcclxuICAgIG1vZGU6ICdVUExPQUQnLFxyXG4gICAgY29uZmlnOiB7XHJcbiAgICAgICAgZXhwaXJ5OiBudWxsLFxyXG4gICAgICAgIG1heERvd25sb2FkczogbnVsbCxcclxuICAgIH0sXHJcbn07XHJcblxyXG5jb25zdCBBQ1RJT05TID0ge1xyXG4gICAgU0VUX01PREU6ICdTRVRfTU9ERScsXHJcbiAgICBTVEFSVF9VUExPQUQ6ICdTVEFSVF9VUExPQUQnLFxyXG4gICAgU0VUX1BST0dSRVNTOiAnU0VUX1BST0dSRVNTJyxcclxuICAgIFVQTE9BRF9TVUNDRVNTOiAnVVBMT0FEX1NVQ0NFU1MnLFxyXG4gICAgVVBMT0FEX0VSUk9SOiAnVVBMT0FEX0VSUk9SJyxcclxuICAgIEVOVEVSX0RPV05MT0FEOiAnRU5URVJfRE9XTkxPQUQnLFxyXG4gICAgRkVUQ0hfRklMRV9TVEFSVDogJ0ZFVENIX0ZJTEVfU1RBUlQnLFxyXG4gICAgRkVUQ0hfRklMRV9TVUNDRVNTOiAnRkVUQ0hfRklMRV9TVUNDRVNTJyxcclxuICAgIEZFVENIX0ZJTEVfRVJST1I6ICdGRVRDSF9GSUxFX0VSUk9SJyxcclxuICAgIFJFU0VUOiAnUkVTRVQnLFxyXG4gICAgU0VUX0NPTkZJR19FWFBJUlk6ICdTRVRfQ09ORklHX0VYUElSWScsXHJcbiAgICBTRVRfQ09ORklHX0RPV05MT0FEUzogJ1NFVF9DT05GSUdfRE9XTkxPQURTJyxcclxufSBhcyBjb25zdDtcclxuXHJcbnR5cGUgQWN0aW9uID1cclxuICAgIHwgeyB0eXBlOiAnU0VUX01PREUnOyBwYXlsb2FkOiAnVVBMT0FEJyB8ICdET1dOTE9BRCcgfVxyXG4gICAgfCB7IHR5cGU6ICdTVEFSVF9VUExPQUQnIH1cclxuICAgIHwgeyB0eXBlOiAnU0VUX1BST0dSRVNTJzsgcGF5bG9hZDogbnVtYmVyIH1cclxuICAgIHwgeyB0eXBlOiAnVVBMT0FEX1NVQ0NFU1MnOyBwYXlsb2FkOiBhbnkgfVxyXG4gICAgfCB7IHR5cGU6ICdVUExPQURfRVJST1InOyBwYXlsb2FkOiBzdHJpbmcgfVxyXG4gICAgfCB7IHR5cGU6ICdFTlRFUl9ET1dOTE9BRCcgfVxyXG4gICAgfCB7IHR5cGU6ICdGRVRDSF9GSUxFX1NUQVJUJyB9XHJcbiAgICB8IHsgdHlwZTogJ0ZFVENIX0ZJTEVfU1VDQ0VTUyc7IHBheWxvYWQ6IGFueSB9XHJcbiAgICB8IHsgdHlwZTogJ0ZFVENIX0ZJTEVfRVJST1InOyBwYXlsb2FkOiBzdHJpbmcgfVxyXG4gICAgfCB7IHR5cGU6ICdSRVNFVCcgfVxyXG4gICAgfCB7IHR5cGU6ICdTRVRfQ09ORklHX0VYUElSWSc7IHBheWxvYWQ6IG51bWJlciB9XHJcbiAgICB8IHsgdHlwZTogJ1NFVF9DT05GSUdfRE9XTkxPQURTJzsgcGF5bG9hZDogbnVtYmVyIH07XHJcblxyXG5mdW5jdGlvbiBhcHBSZWR1Y2VyKHN0YXRlOiBBcHBTdGF0ZSwgYWN0aW9uOiBBY3Rpb24pOiBBcHBTdGF0ZSB7XHJcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnU0VUX01PREUnOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXHJcbiAgICAgICAgICAgICAgICBtb2RlOiBhY3Rpb24ucGF5bG9hZCxcclxuICAgICAgICAgICAgICAgIHN0YXR1czogYWN0aW9uLnBheWxvYWQgPT09ICdVUExPQUQnID8gJ0lETEUnIDogJ0RPV05MT0FEX0VOVFJZJyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgY2FzZSAnU1RBUlRfVVBMT0FEJzpcclxuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIHN0YXR1czogJ1VQTE9BRElORycsIHByb2dyZXNzOiAwLCBlcnJvcjogbnVsbCB9O1xyXG4gICAgICAgIGNhc2UgJ1NFVF9QUk9HUkVTUyc6XHJcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBwcm9ncmVzczogYWN0aW9uLnBheWxvYWQgfTtcclxuICAgICAgICBjYXNlICdVUExPQURfU1VDQ0VTUyc6XHJcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBzdGF0dXM6ICdHRU5FUkFURUQnLCBkYXRhOiBhY3Rpb24ucGF5bG9hZCwgcHJvZ3Jlc3M6IDEwMCB9O1xyXG4gICAgICAgIGNhc2UgJ1VQTE9BRF9FUlJPUic6XHJcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBzdGF0dXM6ICdFUlJPUicsIGVycm9yOiBhY3Rpb24ucGF5bG9hZCwgcHJvZ3Jlc3M6IDAgfTtcclxuICAgICAgICBjYXNlICdFTlRFUl9ET1dOTE9BRCc6XHJcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBzdGF0dXM6ICdET1dOTE9BRF9FTlRSWScsIGVycm9yOiBudWxsLCBkYXRhOiBudWxsIH07XHJcbiAgICAgICAgY2FzZSAnRkVUQ0hfRklMRV9TVEFSVCc6XHJcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBzdGF0dXM6ICdET1dOTE9BRElORycsIHByb2dyZXNzOiAwLCBlcnJvcjogbnVsbCB9O1xyXG4gICAgICAgIGNhc2UgJ0ZFVENIX0ZJTEVfU1VDQ0VTUyc6XHJcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBzdGF0dXM6ICdET1dOTE9BRElORycsIGRhdGE6IGFjdGlvbi5wYXlsb2FkIH07XHJcbiAgICAgICAgY2FzZSAnRkVUQ0hfRklMRV9FUlJPUic6XHJcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBzdGF0dXM6ICdFUlJPUicsIGVycm9yOiBhY3Rpb24ucGF5bG9hZCB9O1xyXG4gICAgICAgIGNhc2UgJ1JFU0VUJzpcclxuICAgICAgICAgICAgLy8gS2VlcCB0aGUgY29uZmlnIG9uIHJlc2V0IGZvciBiZXR0ZXIgVVg/IE9yIGNsZWFyIGl0PyBcclxuICAgICAgICAgICAgLy8gUHJvbXB0IHNheXM6IFwiUmVzZXQ6IFVJIHN0YXRlLCBDb25maWcgc2VsZWN0aW9uc1wiLiBTbyBjbGVhciBpdC5cclxuICAgICAgICAgICAgcmV0dXJuIHsgLi4uaW5pdGlhbFN0YXRlLCBtb2RlOiBzdGF0ZS5tb2RlIH07XHJcbiAgICAgICAgY2FzZSAnU0VUX0NPTkZJR19FWFBJUlknOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IHsgLi4uc3RhdGUuY29uZmlnLCBleHBpcnk6IGFjdGlvbi5wYXlsb2FkIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGlzUmVhZHkgPSBuZXdDb25maWcuZXhwaXJ5ICE9PSBudWxsICYmIG5ld0NvbmZpZy5tYXhEb3dubG9hZHMgIT09IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBjb25maWc6IG5ld0NvbmZpZywgc3RhdHVzOiBpc1JlYWR5ICYmIHN0YXRlLnN0YXR1cyA9PT0gJ0lETEUnID8gJ1JFQURZJyA6IHN0YXRlLnN0YXR1cyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdTRVRfQ09ORklHX0RPV05MT0FEUyc6IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q29uZmlnID0geyAuLi5zdGF0ZS5jb25maWcsIG1heERvd25sb2FkczogYWN0aW9uLnBheWxvYWQgfTtcclxuICAgICAgICAgICAgY29uc3QgaXNSZWFkeSA9IG5ld0NvbmZpZy5leHBpcnkgIT09IG51bGwgJiYgbmV3Q29uZmlnLm1heERvd25sb2FkcyAhPT0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGNvbmZpZzogbmV3Q29uZmlnLCBzdGF0dXM6IGlzUmVhZHkgJiYgc3RhdGUuc3RhdHVzID09PSAnSURMRScgPyAnUkVBRFknIDogc3RhdGUuc3RhdHVzIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgQXBwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8e1xyXG4gICAgc3RhdGU6IEFwcFN0YXRlO1xyXG4gICAgc2V0TW9kZTogKG1vZGU6ICdVUExPQUQnIHwgJ0RPV05MT0FEJykgPT4gdm9pZDtcclxuICAgIHN0YXJ0VXBsb2FkOiAoKSA9PiB2b2lkO1xyXG4gICAgc2V0UHJvZ3Jlc3M6IChwcm9ncmVzczogbnVtYmVyKSA9PiB2b2lkO1xyXG4gICAgdXBsb2FkU3VjY2VzczogKGRhdGE6IGFueSkgPT4gdm9pZDtcclxuICAgIHVwbG9hZEVycm9yOiAoZXJyb3I6IHN0cmluZykgPT4gdm9pZDtcclxuICAgIGVudGVyRG93bmxvYWQ6ICgpID0+IHZvaWQ7XHJcbiAgICBmZXRjaEZpbGVTdGFydDogKCkgPT4gdm9pZDtcclxuICAgIGZldGNoRmlsZVN1Y2Nlc3M6IChkYXRhOiBhbnkpID0+IHZvaWQ7XHJcbiAgICBmZXRjaEZpbGVFcnJvcjogKGVycm9yOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgICByZXNldDogKCkgPT4gdm9pZDtcclxuICAgIHNldEV4cGlyeTogKG1pbnV0ZXM6IG51bWJlcikgPT4gdm9pZDtcclxuICAgIHNldERvd25sb2FkczogKGNvdW50OiBudW1iZXIpID0+IHZvaWQ7XHJcbn0gfCBudWxsPihudWxsKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBBcHBQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XHJcbiAgICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXIoYXBwUmVkdWNlciwgaW5pdGlhbFN0YXRlKTtcclxuXHJcbiAgICBjb25zdCB2YWx1ZSA9IHtcclxuICAgICAgICBzdGF0ZSxcclxuICAgICAgICBzZXRNb2RlOiAobW9kZTogJ1VQTE9BRCcgfCAnRE9XTkxPQUQnKSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdTRVRfTU9ERScsIHBheWxvYWQ6IG1vZGUgfSksXHJcbiAgICAgICAgc3RhcnRVcGxvYWQ6ICgpID0+IGRpc3BhdGNoKHsgdHlwZTogJ1NUQVJUX1VQTE9BRCcgfSksXHJcbiAgICAgICAgc2V0UHJvZ3Jlc3M6IChwcm9ncmVzczogbnVtYmVyKSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdTRVRfUFJPR1JFU1MnLCBwYXlsb2FkOiBwcm9ncmVzcyB9KSxcclxuICAgICAgICB1cGxvYWRTdWNjZXNzOiAoZGF0YTogYW55KSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdVUExPQURfU1VDQ0VTUycsIHBheWxvYWQ6IGRhdGEgfSksXHJcbiAgICAgICAgdXBsb2FkRXJyb3I6IChlcnJvcjogc3RyaW5nKSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdVUExPQURfRVJST1InLCBwYXlsb2FkOiBlcnJvciB9KSxcclxuICAgICAgICBlbnRlckRvd25sb2FkOiAoKSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdFTlRFUl9ET1dOTE9BRCcgfSksXHJcbiAgICAgICAgZmV0Y2hGaWxlU3RhcnQ6ICgpID0+IGRpc3BhdGNoKHsgdHlwZTogJ0ZFVENIX0ZJTEVfU1RBUlQnIH0pLFxyXG4gICAgICAgIGZldGNoRmlsZVN1Y2Nlc3M6IChkYXRhOiBhbnkpID0+IGRpc3BhdGNoKHsgdHlwZTogJ0ZFVENIX0ZJTEVfU1VDQ0VTUycsIHBheWxvYWQ6IGRhdGEgfSksXHJcbiAgICAgICAgZmV0Y2hGaWxlRXJyb3I6IChlcnJvcjogc3RyaW5nKSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdGRVRDSF9GSUxFX0VSUk9SJywgcGF5bG9hZDogZXJyb3IgfSksXHJcbiAgICAgICAgcmVzZXQ6ICgpID0+IGRpc3BhdGNoKHsgdHlwZTogJ1JFU0VUJyB9KSxcclxuICAgICAgICBzZXRFeHBpcnk6IChtaW51dGVzOiBudW1iZXIpID0+IGRpc3BhdGNoKHsgdHlwZTogJ1NFVF9DT05GSUdfRVhQSVJZJywgcGF5bG9hZDogbWludXRlcyB9KSxcclxuICAgICAgICBzZXREb3dubG9hZHM6IChjb3VudDogbnVtYmVyKSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdTRVRfQ09ORklHX0RPV05MT0FEUycsIHBheWxvYWQ6IGNvdW50IH0pLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gPEFwcENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT57Y2hpbGRyZW59PC9BcHBDb250ZXh0LlByb3ZpZGVyPjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFwcCgpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xyXG4gICAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBcHAgbXVzdCBiZSB1c2VkIHdpdGhpbiBhbiBBcHBQcm92aWRlcicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlUmVkdWNlciIsImluaXRpYWxTdGF0ZSIsInN0YXR1cyIsImRhdGEiLCJlcnJvciIsInByb2dyZXNzIiwibW9kZSIsImNvbmZpZyIsImV4cGlyeSIsIm1heERvd25sb2FkcyIsIkFDVElPTlMiLCJTRVRfTU9ERSIsIlNUQVJUX1VQTE9BRCIsIlNFVF9QUk9HUkVTUyIsIlVQTE9BRF9TVUNDRVNTIiwiVVBMT0FEX0VSUk9SIiwiRU5URVJfRE9XTkxPQUQiLCJGRVRDSF9GSUxFX1NUQVJUIiwiRkVUQ0hfRklMRV9TVUNDRVNTIiwiRkVUQ0hfRklMRV9FUlJPUiIsIlJFU0VUIiwiU0VUX0NPTkZJR19FWFBJUlkiLCJTRVRfQ09ORklHX0RPV05MT0FEUyIsImFwcFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInR5cGUiLCJwYXlsb2FkIiwibmV3Q29uZmlnIiwiaXNSZWFkeSIsIkFwcENvbnRleHQiLCJBcHBQcm92aWRlciIsImNoaWxkcmVuIiwiZGlzcGF0Y2giLCJ2YWx1ZSIsInNldE1vZGUiLCJzdGFydFVwbG9hZCIsInNldFByb2dyZXNzIiwidXBsb2FkU3VjY2VzcyIsInVwbG9hZEVycm9yIiwiZW50ZXJEb3dubG9hZCIsImZldGNoRmlsZVN0YXJ0IiwiZmV0Y2hGaWxlU3VjY2VzcyIsImZldGNoRmlsZUVycm9yIiwicmVzZXQiLCJzZXRFeHBpcnkiLCJtaW51dGVzIiwic2V0RG93bmxvYWRzIiwiY291bnQiLCJQcm92aWRlciIsInVzZUFwcCIsImNvbnRleHQiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/providers/AppProvider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   claimDownload: function() { return /* binding */ claimDownload; },\n/* harmony export */   getDownloadUrl: function() { return /* binding */ getDownloadUrl; },\n/* harmony export */   getFileMetadata: function() { return /* binding */ getFileMetadata; },\n/* harmony export */   updateFileMetadata: function() { return /* binding */ updateFileMetadata; },\n/* harmony export */   uploadFile: function() { return /* binding */ uploadFile; }\n/* harmony export */ });\n/* harmony import */ var _vercel_blob_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vercel/blob/client */ \"(app-pages-browser)/./node_modules/@vercel/blob/dist/client.js\");\n/* __next_internal_client_entry_do_not_use__ uploadFile,getFileMetadata,updateFileMetadata,claimDownload,getDownloadUrl auto */ \nconst API_BASE = \"/api\";\n// Helper to generate a random 6-character code\nconst generateShareCode = ()=>{\n    const chars = \"ABCDEFGHJKLMNPQRSTUVWXYZ23456789\"; // No I, O, 0, 1\n    let result = \"\";\n    for(let i = 0; i < 6; i++){\n        result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n};\nconst uploadFile = async (files, settings, onProgress)=>{\n    const fileList = files instanceof FileList ? Array.from(files) : files;\n    const shareCode = generateShareCode();\n    const uploadedBlobs = [];\n    let totalSize = 0;\n    // Calculate total size for progress tracking (simple version)\n    fileList.forEach((f)=>totalSize += f.size);\n    let uploadedBytes = 0;\n    for(let i = 0; i < fileList.length; i++){\n        const file = fileList[i];\n        const pathname = \"uploads/\".concat(shareCode, \"/\").concat(file.name);\n        try {\n            const blob = await (0,_vercel_blob_client__WEBPACK_IMPORTED_MODULE_0__.upload)(pathname, file, {\n                access: \"public\",\n                handleUploadUrl: \"/api/blob/upload-token\",\n                onUploadProgress: (progressEvent)=>{\n                    if (onProgress) {\n                        // This event returns absolute bytes uploaded for THIS file\n                        // We need to track global progress?\n                        // For MVP, simplistic approximation:\n                        // Let's just pass the single file progress for now to keep UI lively\n                        // without complex state management.\n                        // Or better: (uploadedBytesBefore + current) / total\n                        const currentFilePercent = progressEvent.percentage;\n                        // const totalPercent = Math.round(((uploadedBytes + (file.size * (currentFilePercent / 100))) / totalSize) * 100);\n                        // onProgress(totalPercent);\n                        onProgress(currentFilePercent); // Simple per-file progress\n                    }\n                }\n            });\n            uploadedBlobs.push({\n                url: blob.url,\n                originalName: file.name,\n                size: file.size,\n                mimeType: file.type,\n                pathname: blob.pathname\n            });\n            uploadedBytes += file.size;\n        } catch (err) {\n            console.error(\"Failed to upload \".concat(file.name), err);\n            throw {\n                error: \"Upload Failed\"\n            };\n        }\n    }\n    // Register with Backend (Phase 3)\n    try {\n        const res = await fetch(\"/api/share\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                shareCode,\n                files: uploadedBlobs,\n                settings: settings\n            })\n        });\n        if (!res.ok) {\n            throw new Error(\"Metadata registration failed\");\n        }\n        const data = await res.json();\n        // Return structured data expected by consumers\n        return {\n            code: shareCode,\n            files: uploadedBlobs,\n            totalSize,\n            expiresAt: data.expiresAt,\n            downloadsLeft: settings.maxDownloads\n        };\n    } catch (e) {\n        console.error(e);\n        throw {\n            error: \"Registration Failed\"\n        };\n    }\n};\nconst getFileMetadata = async (code)=>{\n    const res = await fetch(\"/api/share/\".concat(encodeURIComponent(code)));\n    const data = await res.json();\n    if (!res.ok) throw data;\n    return data;\n};\nconst updateFileMetadata = async (code, updates)=>{\n    // This seems unused or legacy? Keeping for safety but it endpoint likely doesn't exist yet.\n    // Implementation plan didn't mention update.\n    return {};\n};\n// Replaces getDownloadUrl with async claim\nconst claimDownload = async (code)=>{\n    const res = await fetch(\"/api/share/\".concat(encodeURIComponent(code), \"/download\"), {\n        method: \"POST\"\n    });\n    const data = await res.json();\n    if (!res.ok) throw data;\n    return data;\n};\n// Legacy support if needed, but we should switch to claimDownload\nconst getDownloadUrl = (code)=>{\n    return \"/api/share/\".concat(encodeURIComponent(code), \"/download\");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU9MO0lBQ2xDLE1BQU1YLE1BQU0sTUFBTUMsTUFBTSxjQUF1QyxPQUF6QmdCLG1CQUFtQk47SUFDekQsTUFBTUYsT0FBTyxNQUFNVCxJQUFJVSxJQUFJO0lBQzNCLElBQUksQ0FBQ1YsSUFBSU8sRUFBRSxFQUFFLE1BQU1FO0lBQ25CLE9BQU9BO0FBQ1gsRUFBRTtBQUVLLE1BQU1TLHFCQUFxQixPQUFPUCxNQUFjUTtJQUNuRCw0RkFBNEY7SUFDNUYsNkNBQTZDO0lBQzdDLE9BQU8sQ0FBQztBQUNaLEVBQUU7QUFFRiwyQ0FBMkM7QUFDcEMsTUFBTUMsZ0JBQWdCLE9BQU9UO0lBQ2hDLE1BQU1YLE1BQU0sTUFBTUMsTUFBTSxjQUF1QyxPQUF6QmdCLG1CQUFtQk4sT0FBTSxjQUFZO1FBQ3ZFVCxRQUFRO0lBQ1o7SUFDQSxNQUFNTyxPQUFPLE1BQU1ULElBQUlVLElBQUk7SUFDM0IsSUFBSSxDQUFDVixJQUFJTyxFQUFFLEVBQUUsTUFBTUU7SUFDbkIsT0FBT0E7QUFDWCxFQUFFO0FBQ0Ysa0VBQWtFO0FBQzNELE1BQU1ZLGlCQUFpQixDQUFDVjtJQUMzQixPQUFPLGNBQXVDLE9BQXpCTSxtQkFBbUJOLE9BQU07QUFDbEQsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXBpLnRzPzY4YTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcbmltcG9ydCB7IHVwbG9hZCB9IGZyb20gJ0B2ZXJjZWwvYmxvYi9jbGllbnQnO1xyXG5cclxuY29uc3QgQVBJX0JBU0UgPSAnL2FwaSc7XHJcblxyXG5leHBvcnQgdHlwZSBGaWxlTWV0YWRhdGEgPSB7XHJcbiAgICBjb2RlOiBzdHJpbmc7XHJcbiAgICBvcmlnaW5hbE5hbWU6IHN0cmluZztcclxuICAgIHNpemU6IG51bWJlcjtcclxuICAgIG1pbWVUeXBlOiBzdHJpbmc7XHJcbiAgICBleHBpcmVzQXQ6IG51bWJlcjtcclxuICAgIGZpbGVDb3VudDogbnVtYmVyO1xyXG4gICAgZXhwaXJ5TWludXRlczogbnVtYmVyO1xyXG4gICAgbWF4RG93bmxvYWRzOiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgICBkb3dubG9hZHM6IG51bWJlcjtcclxuICAgIGRvd25sb2Fkc0xlZnQ/OiBudW1iZXI7XHJcbiAgICBibG9iVXJsPzogc3RyaW5nOyAvLyBOZXcgZmllbGQgZm9yIGRpcmVjdCBibG9iIGRvd25sb2FkXHJcbn07XHJcblxyXG4vLyBIZWxwZXIgdG8gZ2VuZXJhdGUgYSByYW5kb20gNi1jaGFyYWN0ZXIgY29kZVxyXG5jb25zdCBnZW5lcmF0ZVNoYXJlQ29kZSA9ICgpID0+IHtcclxuICAgIGNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISktMTU5QUVJTVFVWV1hZWjIzNDU2Nzg5JzsgLy8gTm8gSSwgTywgMCwgMVxyXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgICByZXN1bHQgKz0gY2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGxvYWRGaWxlID0gYXN5bmMgKGZpbGVzOiBGaWxlW10gfCBGaWxlTGlzdCwgc2V0dGluZ3M6IHsgZXhwaXJ5TWludXRlczogbnVtYmVyLCBtYXhEb3dubG9hZHM6IG51bWJlciB9LCBvblByb2dyZXNzPzogKHBlcmNlbnQ6IG51bWJlcikgPT4gdm9pZCk6IFByb21pc2U8YW55PiA9PiB7XHJcbiAgICBjb25zdCBmaWxlTGlzdCA9IGZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QgPyBBcnJheS5mcm9tKGZpbGVzKSA6IGZpbGVzO1xyXG4gICAgY29uc3Qgc2hhcmVDb2RlID0gZ2VuZXJhdGVTaGFyZUNvZGUoKTtcclxuICAgIGNvbnN0IHVwbG9hZGVkQmxvYnM6IGFueVtdID0gW107XHJcbiAgICBsZXQgdG90YWxTaXplID0gMDtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgc2l6ZSBmb3IgcHJvZ3Jlc3MgdHJhY2tpbmcgKHNpbXBsZSB2ZXJzaW9uKVxyXG4gICAgZmlsZUxpc3QuZm9yRWFjaChmID0+IHRvdGFsU2l6ZSArPSBmLnNpemUpO1xyXG4gICAgbGV0IHVwbG9hZGVkQnl0ZXMgPSAwO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBmaWxlID0gZmlsZUxpc3RbaV07XHJcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBgdXBsb2Fkcy8ke3NoYXJlQ29kZX0vJHtmaWxlLm5hbWV9YDtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHVwbG9hZChwYXRobmFtZSwgZmlsZSwge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzOiAncHVibGljJyxcclxuICAgICAgICAgICAgICAgIGhhbmRsZVVwbG9hZFVybDogJy9hcGkvYmxvYi91cGxvYWQtdG9rZW4nLCAvLyBOZXcgZW5kcG9pbnRcclxuICAgICAgICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IChwcm9ncmVzc0V2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBldmVudCByZXR1cm5zIGFic29sdXRlIGJ5dGVzIHVwbG9hZGVkIGZvciBUSElTIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0cmFjayBnbG9iYWwgcHJvZ3Jlc3M/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBNVlAsIHNpbXBsaXN0aWMgYXBwcm94aW1hdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGV0J3MganVzdCBwYXNzIHRoZSBzaW5nbGUgZmlsZSBwcm9ncmVzcyBmb3Igbm93IHRvIGtlZXAgVUkgbGl2ZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgY29tcGxleCBzdGF0ZSBtYW5hZ2VtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPciBiZXR0ZXI6ICh1cGxvYWRlZEJ5dGVzQmVmb3JlICsgY3VycmVudCkgLyB0b3RhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmlsZVBlcmNlbnQgPSBwcm9ncmVzc0V2ZW50LnBlcmNlbnRhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IHRvdGFsUGVyY2VudCA9IE1hdGgucm91bmQoKCh1cGxvYWRlZEJ5dGVzICsgKGZpbGUuc2l6ZSAqIChjdXJyZW50RmlsZVBlcmNlbnQgLyAxMDApKSkgLyB0b3RhbFNpemUpICogMTAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25Qcm9ncmVzcyh0b3RhbFBlcmNlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzKGN1cnJlbnRGaWxlUGVyY2VudCk7IC8vIFNpbXBsZSBwZXItZmlsZSBwcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdXBsb2FkZWRCbG9icy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHVybDogYmxvYi51cmwsXHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE5hbWU6IGZpbGUubmFtZSxcclxuICAgICAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcclxuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBmaWxlLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBwYXRobmFtZTogYmxvYi5wYXRobmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdXBsb2FkZWRCeXRlcyArPSBmaWxlLnNpemU7XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gdXBsb2FkICR7ZmlsZS5uYW1lfWAsIGVycik7XHJcbiAgICAgICAgICAgIHRocm93IHsgZXJyb3I6ICdVcGxvYWQgRmFpbGVkJyB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWdpc3RlciB3aXRoIEJhY2tlbmQgKFBoYXNlIDMpXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL3NoYXJlJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgIHNoYXJlQ29kZSxcclxuICAgICAgICAgICAgICAgIGZpbGVzOiB1cGxvYWRlZEJsb2JzLFxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmICghcmVzLm9rKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YWRhdGEgcmVnaXN0cmF0aW9uIGZhaWxlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBzdHJ1Y3R1cmVkIGRhdGEgZXhwZWN0ZWQgYnkgY29uc3VtZXJzXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogc2hhcmVDb2RlLFxyXG4gICAgICAgICAgICBmaWxlczogdXBsb2FkZWRCbG9icyxcclxuICAgICAgICAgICAgdG90YWxTaXplLFxyXG4gICAgICAgICAgICBleHBpcmVzQXQ6IGRhdGEuZXhwaXJlc0F0LFxyXG4gICAgICAgICAgICBkb3dubG9hZHNMZWZ0OiBzZXR0aW5ncy5tYXhEb3dubG9hZHNcclxuICAgICAgICB9O1xyXG5cclxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgdGhyb3cgeyBlcnJvcjogJ1JlZ2lzdHJhdGlvbiBGYWlsZWQnIH07XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0RmlsZU1ldGFkYXRhID0gYXN5bmMgKGNvZGU6IHN0cmluZyk6IFByb21pc2U8RmlsZU1ldGFkYXRhPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9zaGFyZS8ke2VuY29kZVVSSUNvbXBvbmVudChjb2RlKX1gKTtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IGRhdGE7XHJcbiAgICByZXR1cm4gZGF0YTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVGaWxlTWV0YWRhdGEgPSBhc3luYyAoY29kZTogc3RyaW5nLCB1cGRhdGVzOiBhbnkpOiBQcm9taXNlPGFueT4gPT4ge1xyXG4gICAgLy8gVGhpcyBzZWVtcyB1bnVzZWQgb3IgbGVnYWN5PyBLZWVwaW5nIGZvciBzYWZldHkgYnV0IGl0IGVuZHBvaW50IGxpa2VseSBkb2Vzbid0IGV4aXN0IHlldC5cclxuICAgIC8vIEltcGxlbWVudGF0aW9uIHBsYW4gZGlkbid0IG1lbnRpb24gdXBkYXRlLlxyXG4gICAgcmV0dXJuIHt9O1xyXG59O1xyXG5cclxuLy8gUmVwbGFjZXMgZ2V0RG93bmxvYWRVcmwgd2l0aCBhc3luYyBjbGFpbVxyXG5leHBvcnQgY29uc3QgY2xhaW1Eb3dubG9hZCA9IGFzeW5jIChjb2RlOiBzdHJpbmcpOiBQcm9taXNlPHsgdXJsOiBzdHJpbmcsIGZpbGVzOiBhbnlbXSB9PiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9zaGFyZS8ke2VuY29kZVVSSUNvbXBvbmVudChjb2RlKX0vZG93bmxvYWRgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCdcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgZGF0YTtcclxuICAgIHJldHVybiBkYXRhO1xyXG59O1xyXG4vLyBMZWdhY3kgc3VwcG9ydCBpZiBuZWVkZWQsIGJ1dCB3ZSBzaG91bGQgc3dpdGNoIHRvIGNsYWltRG93bmxvYWRcclxuZXhwb3J0IGNvbnN0IGdldERvd25sb2FkVXJsID0gKGNvZGU6IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgICByZXR1cm4gYC9hcGkvc2hhcmUvJHtlbmNvZGVVUklDb21wb25lbnQoY29kZSl9L2Rvd25sb2FkYDtcclxufTtcclxuIl0sIm5hbWVzIjpbInVwbG9hZCIsIkFQSV9CQVNFIiwiZ2VuZXJhdGVTaGFyZUNvZGUiLCJjaGFycyIsInJlc3VsdCIsImkiLCJjaGFyQXQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsZW5ndGgiLCJ1cGxvYWRGaWxlIiwiZmlsZXMiLCJzZXR0aW5ncyIsIm9uUHJvZ3Jlc3MiLCJmaWxlTGlzdCIsIkZpbGVMaXN0IiwiQXJyYXkiLCJmcm9tIiwic2hhcmVDb2RlIiwidXBsb2FkZWRCbG9icyIsInRvdGFsU2l6ZSIsImZvckVhY2giLCJmIiwic2l6ZSIsInVwbG9hZGVkQnl0ZXMiLCJmaWxlIiwicGF0aG5hbWUiLCJuYW1lIiwiYmxvYiIsImFjY2VzcyIsImhhbmRsZVVwbG9hZFVybCIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJwcm9ncmVzc0V2ZW50IiwiY3VycmVudEZpbGVQZXJjZW50IiwicGVyY2VudGFnZSIsInB1c2giLCJ1cmwiLCJvcmlnaW5hbE5hbWUiLCJtaW1lVHlwZSIsInR5cGUiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiRXJyb3IiLCJkYXRhIiwianNvbiIsImNvZGUiLCJleHBpcmVzQXQiLCJkb3dubG9hZHNMZWZ0IiwibWF4RG93bmxvYWRzIiwiZSIsImdldEZpbGVNZXRhZGF0YSIsImVuY29kZVVSSUNvbXBvbmVudCIsInVwZGF0ZUZpbGVNZXRhZGF0YSIsInVwZGF0ZXMiLCJjbGFpbURvd25sb2FkIiwiZ2V0RG93bmxvYWRVcmwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: function() { return /* binding */ BlobAccessError; },\n/* harmony export */   BlobClientTokenExpiredError: function() { return /* binding */ BlobClientTokenExpiredError; },\n/* harmony export */   BlobContentTypeNotAllowedError: function() { return /* binding */ BlobContentTypeNotAllowedError; },\n/* harmony export */   BlobError: function() { return /* binding */ BlobError; },\n/* harmony export */   BlobFileTooLargeError: function() { return /* binding */ BlobFileTooLargeError; },\n/* harmony export */   BlobNotFoundError: function() { return /* binding */ BlobNotFoundError; },\n/* harmony export */   BlobPathnameMismatchError: function() { return /* binding */ BlobPathnameMismatchError; },\n/* harmony export */   BlobRequestAbortedError: function() { return /* binding */ BlobRequestAbortedError; },\n/* harmony export */   BlobServiceNotAvailable: function() { return /* binding */ BlobServiceNotAvailable; },\n/* harmony export */   BlobServiceRateLimited: function() { return /* binding */ BlobServiceRateLimited; },\n/* harmony export */   BlobStoreNotFoundError: function() { return /* binding */ BlobStoreNotFoundError; },\n/* harmony export */   BlobStoreSuspendedError: function() { return /* binding */ BlobStoreSuspendedError; },\n/* harmony export */   BlobUnknownError: function() { return /* binding */ BlobUnknownError; },\n/* harmony export */   MAXIMUM_PATHNAME_LENGTH: function() { return /* binding */ MAXIMUM_PATHNAME_LENGTH; },\n/* harmony export */   createCompleteMultipartUploadMethod: function() { return /* binding */ createCompleteMultipartUploadMethod; },\n/* harmony export */   createCreateMultipartUploadMethod: function() { return /* binding */ createCreateMultipartUploadMethod; },\n/* harmony export */   createCreateMultipartUploaderMethod: function() { return /* binding */ createCreateMultipartUploaderMethod; },\n/* harmony export */   createFolder: function() { return /* binding */ createFolder; },\n/* harmony export */   createPutMethod: function() { return /* binding */ createPutMethod; },\n/* harmony export */   createUploadPartMethod: function() { return /* binding */ createUploadPartMethod; },\n/* harmony export */   disallowedPathnameCharacters: function() { return /* binding */ disallowedPathnameCharacters; },\n/* harmony export */   getDownloadUrl: function() { return /* binding */ getDownloadUrl; },\n/* harmony export */   getTokenFromOptionsOrEnv: function() { return /* binding */ getTokenFromOptionsOrEnv; },\n/* harmony export */   requestApi: function() { return /* binding */ requestApi; }\n/* harmony export */ });\n/* harmony import */ var is_node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-node-process */ \"(app-pages-browser)/./node_modules/is-node-process/lib/index.mjs\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-buffer */ \"(app-pages-browser)/./node_modules/is-buffer/index.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream */ \"(app-pages-browser)/./node_modules/@vercel/blob/dist/stream-browser.js\");\n/* harmony import */ var async_retry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! async-retry */ \"(app-pages-browser)/./node_modules/async-retry/lib/index.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! undici */ \"(app-pages-browser)/./node_modules/@vercel/blob/dist/undici-browser.js\");\n/* harmony import */ var throttleit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! throttleit */ \"(app-pages-browser)/./node_modules/throttleit/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n// src/helpers.ts\n\n// src/multipart/helpers.ts\n\n\nvar supportsNewBlobFromArrayBuffer = new Promise((resolve)=>{\n    try {\n        const helloAsArrayBuffer = new Uint8Array([\n            104,\n            101,\n            108,\n            108,\n            111\n        ]);\n        const blob = new Blob([\n            helloAsArrayBuffer\n        ]);\n        blob.text().then((text)=>{\n            resolve(text === \"hello\");\n        }).catch(()=>{\n            resolve(false);\n        });\n    } catch (e) {\n        resolve(false);\n    }\n});\nasync function toReadableStream(value) {\n    if (value instanceof ReadableStream) {\n        return value;\n    }\n    if (value instanceof Blob) {\n        return value.stream();\n    }\n    if (isNodeJsReadableStream(value)) {\n        return stream__WEBPACK_IMPORTED_MODULE_2__.Readable.toWeb(value);\n    }\n    let streamValue;\n    if (value instanceof ArrayBuffer) {\n        streamValue = new Uint8Array(value);\n    } else if (isNodeJsBuffer(value)) {\n        streamValue = value;\n    } else {\n        streamValue = stringToUint8Array(value);\n    }\n    if (await supportsNewBlobFromArrayBuffer) {\n        return new Blob([\n            streamValue\n        ]).stream();\n    }\n    return new ReadableStream({\n        start (controller) {\n            controller.enqueue(streamValue);\n            controller.close();\n        }\n    });\n}\nfunction isNodeJsReadableStream(value) {\n    return typeof value === \"object\" && typeof value.pipe === \"function\" && value.readable && typeof value._read === \"function\" && // @ts-expect-error _readableState does exists on Readable\n    typeof value._readableState === \"object\";\n}\nfunction stringToUint8Array(s) {\n    const enc = new TextEncoder();\n    return enc.encode(s);\n}\nfunction isNodeJsBuffer(value) {\n    return is_buffer__WEBPACK_IMPORTED_MODULE_1__(value);\n}\n// src/bytes.ts\nvar parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i;\nvar map = {\n    b: 1,\n    kb: 1 << 10,\n    mb: 1 << 20,\n    gb: 1 << 30,\n    tb: 1024 ** 4,\n    pb: 1024 ** 5\n};\nfunction bytes(val) {\n    if (typeof val === \"number\" && !Number.isNaN(val)) {\n        return val;\n    }\n    if (typeof val !== \"string\") {\n        return null;\n    }\n    const results = parseRegExp.exec(val);\n    let floatValue;\n    let unit = \"b\";\n    if (!results) {\n        floatValue = parseInt(val, 10);\n    } else {\n        const [, res, , , unitMatch] = results;\n        if (!res) {\n            return null;\n        }\n        floatValue = parseFloat(res);\n        if (unitMatch) {\n            unit = unitMatch.toLowerCase();\n        }\n    }\n    if (Number.isNaN(floatValue)) {\n        return null;\n    }\n    return Math.floor(map[unit] * floatValue);\n}\n// src/helpers.ts\nvar defaultVercelBlobApiUrl = \"https://vercel.com/api/blob\";\nfunction getTokenFromOptionsOrEnv(options) {\n    if (options == null ? void 0 : options.token) {\n        return options.token;\n    }\n    if (process.env.BLOB_READ_WRITE_TOKEN) {\n        return process.env.BLOB_READ_WRITE_TOKEN;\n    }\n    throw new BlobError(\"No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.\");\n}\nvar BlobError = class extends Error {\n    constructor(message){\n        super(\"Vercel Blob: \".concat(message));\n    }\n};\nfunction getDownloadUrl(blobUrl) {\n    const url = new URL(blobUrl);\n    url.searchParams.set(\"download\", \"1\");\n    return url.toString();\n}\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\nvar disallowedPathnameCharacters = [\n    \"//\"\n];\nvar supportsRequestStreams = (()=>{\n    if ((0,is_node_process__WEBPACK_IMPORTED_MODULE_0__.isNodeProcess)()) {\n        return true;\n    }\n    const apiUrl = getApiUrl();\n    if (apiUrl.startsWith(\"http://localhost\")) {\n        return false;\n    }\n    let duplexAccessed = false;\n    const hasContentType = new Request(getApiUrl(), {\n        body: new ReadableStream(),\n        method: \"POST\",\n        // @ts-expect-error -- TypeScript doesn't yet have duplex but it's in the spec: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1729\n        get duplex () {\n            duplexAccessed = true;\n            return \"half\";\n        }\n    }).headers.has(\"Content-Type\");\n    return duplexAccessed && !hasContentType;\n})();\nfunction getApiUrl() {\n    let pathname = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    let baseUrl = null;\n    try {\n        baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n    } catch (e) {}\n    return \"\".concat(baseUrl || defaultVercelBlobApiUrl).concat(pathname);\n}\nvar TEXT_ENCODER = typeof TextEncoder === \"function\" ? new TextEncoder() : null;\nfunction computeBodyLength(body) {\n    if (!body) {\n        return 0;\n    }\n    if (typeof body === \"string\") {\n        if (TEXT_ENCODER) {\n            return TEXT_ENCODER.encode(body).byteLength;\n        }\n        return new Blob([\n            body\n        ]).size;\n    }\n    if (\"byteLength\" in body && typeof body.byteLength === \"number\") {\n        return body.byteLength;\n    }\n    if (\"size\" in body && typeof body.size === \"number\") {\n        return body.size;\n    }\n    return 0;\n}\nvar createChunkTransformStream = (chunkSize, onProgress)=>{\n    let buffer = new Uint8Array(0);\n    return new TransformStream({\n        transform (chunk, controller) {\n            queueMicrotask(()=>{\n                const newBuffer = new Uint8Array(buffer.length + chunk.byteLength);\n                newBuffer.set(buffer);\n                newBuffer.set(new Uint8Array(chunk), buffer.length);\n                buffer = newBuffer;\n                while(buffer.length >= chunkSize){\n                    const newChunk = buffer.slice(0, chunkSize);\n                    controller.enqueue(newChunk);\n                    onProgress == null ? void 0 : onProgress(newChunk.byteLength);\n                    buffer = buffer.slice(chunkSize);\n                }\n            });\n        },\n        flush (controller) {\n            queueMicrotask(()=>{\n                if (buffer.length > 0) {\n                    controller.enqueue(buffer);\n                    onProgress == null ? void 0 : onProgress(buffer.byteLength);\n                }\n            });\n        }\n    });\n};\nfunction isReadableStream(value) {\n    return globalThis.ReadableStream && // TODO: Can be removed once Node.js 16 is no more required internally\n    value instanceof ReadableStream;\n}\nfunction isStream(value) {\n    if (isReadableStream(value)) {\n        return true;\n    }\n    if (isNodeJsReadableStream(value)) {\n        return true;\n    }\n    return false;\n}\n// src/api.ts\n\n// src/debug.ts\nvar debugIsActive = false;\nvar _a, _b;\ntry {\n    if (((_a = process.env.DEBUG) == null ? void 0 : _a.includes(\"blob\")) || ((_b = process.env.NEXT_PUBLIC_DEBUG) == null ? void 0 : _b.includes(\"blob\"))) {\n        debugIsActive = true;\n    }\n} catch (e) {}\nfunction debug(message) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (debugIsActive) {\n        console.debug(\"vercel-blob: \".concat(message), ...args);\n    }\n}\n// src/dom-exception.ts\nvar _a2;\nvar DOMException2 = (_a2 = globalThis.DOMException) != null ? _a2 : (()=>{\n    try {\n        atob(\"~\");\n    } catch (err) {\n        return Object.getPrototypeOf(err).constructor;\n    }\n})();\n// src/is-network-error.ts\nvar objectToString = Object.prototype.toString;\nvar isError = (value)=>objectToString.call(value) === \"[object Error]\";\nvar errorMessages = /* @__PURE__ */ new Set([\n    \"network error\",\n    // Chrome\n    \"Failed to fetch\",\n    // Chrome\n    \"NetworkError when attempting to fetch resource.\",\n    // Firefox\n    \"The Internet connection appears to be offline.\",\n    // Safari 16\n    \"Load failed\",\n    // Safari 17+\n    \"Network request failed\",\n    // `cross-fetch`\n    \"fetch failed\",\n    // Undici (Node.js)\n    \"terminated\"\n]);\nfunction isNetworkError(error) {\n    const isValid = error && isError(error) && error.name === \"TypeError\" && typeof error.message === \"string\";\n    if (!isValid) {\n        return false;\n    }\n    if (error.message === \"Load failed\") {\n        return error.stack === void 0;\n    }\n    return errorMessages.has(error.message);\n}\n// src/fetch.ts\n\nvar hasFetch = typeof undici__WEBPACK_IMPORTED_MODULE_4__.fetch === \"function\";\nvar hasFetchWithUploadProgress = hasFetch && supportsRequestStreams;\nvar CHUNK_SIZE = 64 * 1024;\nvar blobFetch = async (param)=>{\n    let { input, init, onUploadProgress } = param;\n    debug(\"using fetch\");\n    let body;\n    if (init.body) {\n        if (onUploadProgress) {\n            const stream = await toReadableStream(init.body);\n            let loaded = 0;\n            const chunkTransformStream = createChunkTransformStream(CHUNK_SIZE, (newLoaded)=>{\n                loaded += newLoaded;\n                onUploadProgress(loaded);\n            });\n            body = stream.pipeThrough(chunkTransformStream);\n        } else {\n            body = init.body;\n        }\n    }\n    const duplex = supportsRequestStreams && body && isStream(body) ? \"half\" : void 0;\n    return (0,undici__WEBPACK_IMPORTED_MODULE_4__.fetch)(input, // @ts-expect-error -- Blob and Nodejs Blob are triggering type errors, fine with it\n    {\n        ...init,\n        ...init.body ? {\n            body\n        } : {},\n        duplex\n    });\n};\n// src/xhr.ts\nvar hasXhr = typeof XMLHttpRequest !== \"undefined\";\nvar blobXhr = async (param)=>{\n    let { input, init, onUploadProgress } = param;\n    debug(\"using xhr\");\n    let body = null;\n    if (init.body) {\n        if (isReadableStream(init.body)) {\n            body = await new Response(init.body).blob();\n        } else {\n            body = init.body;\n        }\n    }\n    return new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(init.method || \"GET\", input.toString(), true);\n        if (onUploadProgress) {\n            xhr.upload.addEventListener(\"progress\", (event)=>{\n                if (event.lengthComputable) {\n                    onUploadProgress(event.loaded);\n                }\n            });\n        }\n        xhr.onload = ()=>{\n            var _a3;\n            if ((_a3 = init.signal) == null ? void 0 : _a3.aborted) {\n                reject(new DOMException(\"The user aborted the request.\", \"AbortError\"));\n                return;\n            }\n            const headers = new Headers();\n            const rawHeaders = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n            rawHeaders.forEach((line)=>{\n                const parts = line.split(\": \");\n                const key = parts.shift();\n                const value = parts.join(\": \");\n                if (key) headers.set(key.toLowerCase(), value);\n            });\n            const response = new Response(xhr.response, {\n                status: xhr.status,\n                statusText: xhr.statusText,\n                headers\n            });\n            resolve(response);\n        };\n        xhr.onerror = ()=>{\n            reject(new TypeError(\"Network request failed\"));\n        };\n        xhr.ontimeout = ()=>{\n            reject(new TypeError(\"Network request timed out\"));\n        };\n        xhr.onabort = ()=>{\n            reject(new DOMException(\"The user aborted a request.\", \"AbortError\"));\n        };\n        if (init.headers) {\n            const headers = new Headers(init.headers);\n            headers.forEach((value, key)=>{\n                xhr.setRequestHeader(key, value);\n            });\n        }\n        if (init.signal) {\n            init.signal.addEventListener(\"abort\", ()=>{\n                xhr.abort();\n            });\n            if (init.signal.aborted) {\n                xhr.abort();\n                return;\n            }\n        }\n        xhr.send(body);\n    });\n};\n// src/request.ts\nvar blobRequest = async (param)=>{\n    let { input, init, onUploadProgress } = param;\n    if (onUploadProgress) {\n        if (hasFetchWithUploadProgress) {\n            return blobFetch({\n                input,\n                init,\n                onUploadProgress\n            });\n        }\n        if (hasXhr) {\n            return blobXhr({\n                input,\n                init,\n                onUploadProgress\n            });\n        }\n    }\n    if (hasFetch) {\n        return blobFetch({\n            input,\n            init\n        });\n    }\n    if (hasXhr) {\n        return blobXhr({\n            input,\n            init\n        });\n    }\n    throw new Error(\"No request implementation available\");\n};\n// src/api.ts\nvar MAXIMUM_PATHNAME_LENGTH = 950;\nvar BlobAccessError = class extends BlobError {\n    constructor(){\n        super(\"Access denied, please provide a valid token for this resource.\");\n    }\n};\nvar BlobContentTypeNotAllowedError = class extends BlobError {\n    constructor(message){\n        super(\"Content type mismatch, \".concat(message, \".\"));\n    }\n};\nvar BlobPathnameMismatchError = class extends BlobError {\n    constructor(message){\n        super(\"Pathname mismatch, \".concat(message, \". Check the pathname used in upload() or put() matches the one from the client token.\"));\n    }\n};\nvar BlobClientTokenExpiredError = class extends BlobError {\n    constructor(){\n        super(\"Client token has expired.\");\n    }\n};\nvar BlobFileTooLargeError = class extends BlobError {\n    constructor(message){\n        super(\"File is too large, \".concat(message, \".\"));\n    }\n};\nvar BlobStoreNotFoundError = class extends BlobError {\n    constructor(){\n        super(\"This store does not exist.\");\n    }\n};\nvar BlobStoreSuspendedError = class extends BlobError {\n    constructor(){\n        super(\"This store has been suspended.\");\n    }\n};\nvar BlobUnknownError = class extends BlobError {\n    constructor(){\n        super(\"Unknown error, please visit https://vercel.com/help.\");\n    }\n};\nvar BlobNotFoundError = class extends BlobError {\n    constructor(){\n        super(\"The requested blob does not exist\");\n    }\n};\nvar BlobServiceNotAvailable = class extends BlobError {\n    constructor(){\n        super(\"The blob service is currently not available. Please try again.\");\n    }\n};\nvar BlobServiceRateLimited = class extends BlobError {\n    constructor(seconds){\n        super(\"Too many requests please lower the number of concurrent requests \".concat(seconds ? \" - try again in \".concat(seconds, \" seconds\") : \"\", \".\"));\n        this.retryAfter = seconds != null ? seconds : 0;\n    }\n};\nvar BlobRequestAbortedError = class extends BlobError {\n    constructor(){\n        super(\"The request was aborted.\");\n    }\n};\nvar BLOB_API_VERSION = 11;\nfunction getApiVersion() {\n    let versionOverride = null;\n    try {\n        versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n    } catch (e) {}\n    return \"\".concat(versionOverride != null ? versionOverride : BLOB_API_VERSION);\n}\nfunction getRetries() {\n    try {\n        const retries = process.env.VERCEL_BLOB_RETRIES || \"10\";\n        return parseInt(retries, 10);\n    } catch (e) {\n        return 10;\n    }\n}\nfunction createBlobServiceRateLimited(response) {\n    const retryAfter = response.headers.get(\"retry-after\");\n    return new BlobServiceRateLimited(retryAfter ? parseInt(retryAfter, 10) : void 0);\n}\nasync function getBlobError(response) {\n    var _a3, _b2, _c;\n    let code;\n    let message;\n    try {\n        const data = await response.json();\n        code = (_b2 = (_a3 = data.error) == null ? void 0 : _a3.code) != null ? _b2 : \"unknown_error\";\n        message = (_c = data.error) == null ? void 0 : _c.message;\n    } catch (e) {\n        code = \"unknown_error\";\n    }\n    if ((message == null ? void 0 : message.includes(\"contentType\")) && message.includes(\"is not allowed\")) {\n        code = \"content_type_not_allowed\";\n    }\n    if ((message == null ? void 0 : message.includes('\"pathname\"')) && message.includes(\"does not match the token payload\")) {\n        code = \"client_token_pathname_mismatch\";\n    }\n    if (message === \"Token expired\") {\n        code = \"client_token_expired\";\n    }\n    if (message == null ? void 0 : message.includes(\"the file length cannot be greater than\")) {\n        code = \"file_too_large\";\n    }\n    let error;\n    switch(code){\n        case \"store_suspended\":\n            error = new BlobStoreSuspendedError();\n            break;\n        case \"forbidden\":\n            error = new BlobAccessError();\n            break;\n        case \"content_type_not_allowed\":\n            error = new BlobContentTypeNotAllowedError(message);\n            break;\n        case \"client_token_pathname_mismatch\":\n            error = new BlobPathnameMismatchError(message);\n            break;\n        case \"client_token_expired\":\n            error = new BlobClientTokenExpiredError();\n            break;\n        case \"file_too_large\":\n            error = new BlobFileTooLargeError(message);\n            break;\n        case \"not_found\":\n            error = new BlobNotFoundError();\n            break;\n        case \"store_not_found\":\n            error = new BlobStoreNotFoundError();\n            break;\n        case \"bad_request\":\n            error = new BlobError(message != null ? message : \"Bad request\");\n            break;\n        case \"service_unavailable\":\n            error = new BlobServiceNotAvailable();\n            break;\n        case \"rate_limited\":\n            error = createBlobServiceRateLimited(response);\n            break;\n        case \"unknown_error\":\n        case \"not_allowed\":\n        default:\n            error = new BlobUnknownError();\n            break;\n    }\n    return {\n        code,\n        error\n    };\n}\nasync function requestApi(pathname, init, commandOptions) {\n    const apiVersion = getApiVersion();\n    const token = getTokenFromOptionsOrEnv(commandOptions);\n    const extraHeaders = getProxyThroughAlternativeApiHeaderFromEnv();\n    const [, , , storeId = \"\"] = token.split(\"_\");\n    const requestId = \"\".concat(storeId, \":\").concat(Date.now(), \":\").concat(Math.random().toString(16).slice(2));\n    let retryCount = 0;\n    let bodyLength = 0;\n    let totalLoaded = 0;\n    const sendBodyLength = (commandOptions == null ? void 0 : commandOptions.onUploadProgress) || shouldUseXContentLength();\n    if (init.body && // 1. For upload progress we always need to know the total size of the body\n    // 2. In development we need the header for put() to work correctly when passing a stream\n    sendBodyLength) {\n        bodyLength = computeBodyLength(init.body);\n    }\n    if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n        commandOptions.onUploadProgress({\n            loaded: 0,\n            total: bodyLength,\n            percentage: 0\n        });\n    }\n    const apiResponse = await async_retry__WEBPACK_IMPORTED_MODULE_3__(async (bail)=>{\n        let res;\n        try {\n            res = await blobRequest({\n                input: getApiUrl(pathname),\n                init: {\n                    ...init,\n                    headers: {\n                        \"x-api-blob-request-id\": requestId,\n                        \"x-api-blob-request-attempt\": String(retryCount),\n                        \"x-api-version\": apiVersion,\n                        ...sendBodyLength ? {\n                            \"x-content-length\": String(bodyLength)\n                        } : {},\n                        authorization: \"Bearer \".concat(token),\n                        ...extraHeaders,\n                        ...init.headers\n                    }\n                },\n                onUploadProgress: (commandOptions == null ? void 0 : commandOptions.onUploadProgress) ? (loaded)=>{\n                    var _a3;\n                    const total = bodyLength !== 0 ? bodyLength : loaded;\n                    totalLoaded = loaded;\n                    const percentage = bodyLength > 0 ? Number((loaded / total * 100).toFixed(2)) : 0;\n                    if (percentage === 100 && bodyLength > 0) {\n                        return;\n                    }\n                    (_a3 = commandOptions.onUploadProgress) == null ? void 0 : _a3.call(commandOptions, {\n                        loaded,\n                        // When passing a stream to put(), we have no way to know the total size of the body.\n                        // Instead of defining total as total?: number we decided to set the total to the currently\n                        // loaded number. This is not inaccurate and way more practical for DX.\n                        // Passing down a stream to put() is very rare\n                        total,\n                        percentage\n                    });\n                } : void 0\n            });\n        } catch (error2) {\n            if (error2 instanceof DOMException2 && error2.name === \"AbortError\") {\n                bail(new BlobRequestAbortedError());\n                return;\n            }\n            if (isNetworkError(error2)) {\n                throw error2;\n            }\n            if (error2 instanceof TypeError) {\n                bail(error2);\n                return;\n            }\n            throw error2;\n        }\n        if (res.ok) {\n            return res;\n        }\n        const { code, error } = await getBlobError(res);\n        if (code === \"unknown_error\" || code === \"service_unavailable\" || code === \"internal_server_error\") {\n            throw error;\n        }\n        bail(error);\n    }, {\n        retries: getRetries(),\n        onRetry: (error)=>{\n            if (error instanceof Error) {\n                debug(\"retrying API request to \".concat(pathname), error.message);\n            }\n            retryCount = retryCount + 1;\n        }\n    });\n    if (!apiResponse) {\n        throw new BlobUnknownError();\n    }\n    if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n        commandOptions.onUploadProgress({\n            loaded: totalLoaded,\n            total: totalLoaded,\n            percentage: 100\n        });\n    }\n    return await apiResponse.json();\n}\nfunction getProxyThroughAlternativeApiHeaderFromEnv() {\n    const extraHeaders = {};\n    try {\n        if (\"VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n            extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n        } else if (\"NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n            extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n        }\n    } catch (e) {}\n    return extraHeaders;\n}\nfunction shouldUseXContentLength() {\n    try {\n        return process.env.VERCEL_BLOB_USE_X_CONTENT_LENGTH === \"1\";\n    } catch (e) {\n        return false;\n    }\n}\n// src/put-helpers.ts\nvar putOptionHeaderMap = {\n    cacheControlMaxAge: \"x-cache-control-max-age\",\n    addRandomSuffix: \"x-add-random-suffix\",\n    allowOverwrite: \"x-allow-overwrite\",\n    contentType: \"x-content-type\"\n};\nfunction createPutHeaders(allowedOptions, options) {\n    const headers = {};\n    if (allowedOptions.includes(\"contentType\") && options.contentType) {\n        headers[putOptionHeaderMap.contentType] = options.contentType;\n    }\n    if (allowedOptions.includes(\"addRandomSuffix\") && options.addRandomSuffix !== void 0) {\n        headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix ? \"1\" : \"0\";\n    }\n    if (allowedOptions.includes(\"allowOverwrite\") && options.allowOverwrite !== void 0) {\n        headers[putOptionHeaderMap.allowOverwrite] = options.allowOverwrite ? \"1\" : \"0\";\n    }\n    if (allowedOptions.includes(\"cacheControlMaxAge\") && options.cacheControlMaxAge !== void 0) {\n        headers[putOptionHeaderMap.cacheControlMaxAge] = options.cacheControlMaxAge.toString();\n    }\n    return headers;\n}\nasync function createPutOptions(param) {\n    let { pathname, options, extraChecks, getToken } = param;\n    if (!pathname) {\n        throw new BlobError(\"pathname is required\");\n    }\n    if (pathname.length > MAXIMUM_PATHNAME_LENGTH) {\n        throw new BlobError(\"pathname is too long, maximum length is \".concat(MAXIMUM_PATHNAME_LENGTH));\n    }\n    for (const invalidCharacter of disallowedPathnameCharacters){\n        if (pathname.includes(invalidCharacter)) {\n            throw new BlobError('pathname cannot contain \"'.concat(invalidCharacter, '\", please encode it if needed'));\n        }\n    }\n    if (!options) {\n        throw new BlobError(\"missing options, see usage\");\n    }\n    if (options.access !== \"public\") {\n        throw new BlobError('access must be \"public\"');\n    }\n    if (extraChecks) {\n        extraChecks(options);\n    }\n    if (getToken) {\n        options.token = await getToken(pathname, options);\n    }\n    return options;\n}\n// src/multipart/complete.ts\nfunction createCompleteMultipartUploadMethod(param) {\n    let { allowedOptions, getToken, extraChecks } = param;\n    return async (pathname, parts, optionsInput)=>{\n        const options = await createPutOptions({\n            pathname,\n            options: optionsInput,\n            extraChecks,\n            getToken\n        });\n        const headers = createPutHeaders(allowedOptions, options);\n        return completeMultipartUpload({\n            uploadId: options.uploadId,\n            key: options.key,\n            pathname,\n            headers,\n            options,\n            parts\n        });\n    };\n}\nasync function completeMultipartUpload(param) {\n    let { uploadId, key, pathname, parts, headers, options } = param;\n    const params = new URLSearchParams({\n        pathname\n    });\n    try {\n        const response = await requestApi(\"/mpu?\".concat(params.toString()), {\n            method: \"POST\",\n            headers: {\n                ...headers,\n                \"content-type\": \"application/json\",\n                \"x-mpu-action\": \"complete\",\n                \"x-mpu-upload-id\": uploadId,\n                // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n                // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n                \"x-mpu-key\": encodeURIComponent(key)\n            },\n            body: JSON.stringify(parts),\n            signal: options.abortSignal\n        }, options);\n        debug(\"mpu: complete\", response);\n        return response;\n    } catch (error) {\n        if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n            throw new BlobServiceNotAvailable();\n        } else {\n            throw error;\n        }\n    }\n}\n// src/multipart/create.ts\nfunction createCreateMultipartUploadMethod(param) {\n    let { allowedOptions, getToken, extraChecks } = param;\n    return async (pathname, optionsInput)=>{\n        const options = await createPutOptions({\n            pathname,\n            options: optionsInput,\n            extraChecks,\n            getToken\n        });\n        const headers = createPutHeaders(allowedOptions, options);\n        const createMultipartUploadResponse = await createMultipartUpload(pathname, headers, options);\n        return {\n            key: createMultipartUploadResponse.key,\n            uploadId: createMultipartUploadResponse.uploadId\n        };\n    };\n}\nasync function createMultipartUpload(pathname, headers, options) {\n    debug(\"mpu: create\", \"pathname:\", pathname);\n    const params = new URLSearchParams({\n        pathname\n    });\n    try {\n        const response = await requestApi(\"/mpu?\".concat(params.toString()), {\n            method: \"POST\",\n            headers: {\n                ...headers,\n                \"x-mpu-action\": \"create\"\n            },\n            signal: options.abortSignal\n        }, options);\n        debug(\"mpu: create\", response);\n        return response;\n    } catch (error) {\n        if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n            throw new BlobServiceNotAvailable();\n        }\n        throw error;\n    }\n}\n// src/multipart/upload.ts\n\nfunction createUploadPartMethod(param) {\n    let { allowedOptions, getToken, extraChecks } = param;\n    return async (pathname, body, optionsInput)=>{\n        const options = await createPutOptions({\n            pathname,\n            options: optionsInput,\n            extraChecks,\n            getToken\n        });\n        const headers = createPutHeaders(allowedOptions, options);\n        if (isPlainObject(body)) {\n            throw new BlobError(\"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\");\n        }\n        const result = await uploadPart({\n            uploadId: options.uploadId,\n            key: options.key,\n            pathname,\n            part: {\n                blob: body,\n                partNumber: options.partNumber\n            },\n            headers,\n            options\n        });\n        return {\n            etag: result.etag,\n            partNumber: options.partNumber\n        };\n    };\n}\nasync function uploadPart(param) {\n    let { uploadId, key, pathname, headers, options, internalAbortController = new AbortController(), part } = param;\n    var _a3, _b2, _c;\n    const params = new URLSearchParams({\n        pathname\n    });\n    const responsePromise = requestApi(\"/mpu?\".concat(params.toString()), {\n        signal: internalAbortController.signal,\n        method: \"POST\",\n        headers: {\n            ...headers,\n            \"x-mpu-action\": \"upload\",\n            \"x-mpu-key\": encodeURIComponent(key),\n            \"x-mpu-upload-id\": uploadId,\n            \"x-mpu-part-number\": part.partNumber.toString()\n        },\n        // weird things between undici types and native fetch types\n        body: part.blob\n    }, options);\n    function handleAbort() {\n        internalAbortController.abort();\n    }\n    if ((_a3 = options.abortSignal) == null ? void 0 : _a3.aborted) {\n        handleAbort();\n    } else {\n        (_b2 = options.abortSignal) == null ? void 0 : _b2.addEventListener(\"abort\", handleAbort);\n    }\n    const response = await responsePromise;\n    (_c = options.abortSignal) == null ? void 0 : _c.removeEventListener(\"abort\", handleAbort);\n    return response;\n}\nvar maxConcurrentUploads =  true ? 6 : 0;\nvar partSizeInBytes = 8 * 1024 * 1024;\nvar maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\nfunction uploadAllParts(param) {\n    let { uploadId, key, pathname, stream, headers, options, totalToLoad } = param;\n    debug(\"mpu: upload init\", \"key:\", key);\n    const internalAbortController = new AbortController();\n    return new Promise((resolve, reject)=>{\n        const partsToUpload = [];\n        const completedParts = [];\n        const reader = stream.getReader();\n        let activeUploads = 0;\n        let reading = false;\n        let currentPartNumber = 1;\n        let rejected = false;\n        let currentBytesInMemory = 0;\n        let doneReading = false;\n        let bytesSent = 0;\n        let arrayBuffers = [];\n        let currentPartBytesRead = 0;\n        let onUploadProgress;\n        const totalLoadedPerPartNumber = {};\n        if (options.onUploadProgress) {\n            onUploadProgress = throttleit__WEBPACK_IMPORTED_MODULE_5__(()=>{\n                var _a3;\n                const loaded = Object.values(totalLoadedPerPartNumber).reduce((acc, cur)=>{\n                    return acc + cur;\n                }, 0);\n                const total = totalToLoad || loaded;\n                const percentage = totalToLoad > 0 ? Number(((loaded / totalToLoad || loaded) * 100).toFixed(2)) : 0;\n                (_a3 = options.onUploadProgress) == null ? void 0 : _a3.call(options, {\n                    loaded,\n                    total,\n                    percentage\n                });\n            }, 150);\n        }\n        read().catch(cancel);\n        async function read() {\n            debug(\"mpu: upload read start\", \"activeUploads:\", activeUploads, \"currentBytesInMemory:\", \"\".concat(bytes(currentBytesInMemory), \"/\").concat(bytes(maxBytesInMemory)), \"bytesSent:\", bytes(bytesSent));\n            reading = true;\n            while(currentBytesInMemory < maxBytesInMemory && !rejected){\n                try {\n                    const { value, done } = await reader.read();\n                    if (done) {\n                        doneReading = true;\n                        debug(\"mpu: upload read consumed the whole stream\");\n                        if (arrayBuffers.length > 0) {\n                            partsToUpload.push({\n                                partNumber: currentPartNumber++,\n                                blob: new Blob(arrayBuffers, {\n                                    type: \"application/octet-stream\"\n                                })\n                            });\n                            sendParts();\n                        }\n                        reading = false;\n                        return;\n                    }\n                    currentBytesInMemory += value.byteLength;\n                    let valueOffset = 0;\n                    while(valueOffset < value.byteLength){\n                        const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n                        const endOffset = Math.min(valueOffset + remainingPartSize, value.byteLength);\n                        const chunk = value.slice(valueOffset, endOffset);\n                        arrayBuffers.push(chunk);\n                        currentPartBytesRead += chunk.byteLength;\n                        valueOffset = endOffset;\n                        if (currentPartBytesRead === partSizeInBytes) {\n                            partsToUpload.push({\n                                partNumber: currentPartNumber++,\n                                blob: new Blob(arrayBuffers, {\n                                    type: \"application/octet-stream\"\n                                })\n                            });\n                            arrayBuffers = [];\n                            currentPartBytesRead = 0;\n                            sendParts();\n                        }\n                    }\n                } catch (error) {\n                    cancel(error);\n                }\n            }\n            debug(\"mpu: upload read end\", \"activeUploads:\", activeUploads, \"currentBytesInMemory:\", \"\".concat(bytes(currentBytesInMemory), \"/\").concat(bytes(maxBytesInMemory)), \"bytesSent:\", bytes(bytesSent));\n            reading = false;\n        }\n        async function sendPart(part) {\n            activeUploads++;\n            debug(\"mpu: upload send part start\", \"partNumber:\", part.partNumber, \"size:\", part.blob.size, \"activeUploads:\", activeUploads, \"currentBytesInMemory:\", \"\".concat(bytes(currentBytesInMemory), \"/\").concat(bytes(maxBytesInMemory)), \"bytesSent:\", bytes(bytesSent));\n            try {\n                const uploadProgressForPart = options.onUploadProgress ? (event)=>{\n                    totalLoadedPerPartNumber[part.partNumber] = event.loaded;\n                    if (onUploadProgress) {\n                        onUploadProgress();\n                    }\n                } : void 0;\n                const completedPart = await uploadPart({\n                    uploadId,\n                    key,\n                    pathname,\n                    headers,\n                    options: {\n                        ...options,\n                        onUploadProgress: uploadProgressForPart\n                    },\n                    internalAbortController,\n                    part\n                });\n                debug(\"mpu: upload send part end\", \"partNumber:\", part.partNumber, \"activeUploads\", activeUploads, \"currentBytesInMemory:\", \"\".concat(bytes(currentBytesInMemory), \"/\").concat(bytes(maxBytesInMemory)), \"bytesSent:\", bytes(bytesSent));\n                if (rejected) {\n                    return;\n                }\n                completedParts.push({\n                    partNumber: part.partNumber,\n                    etag: completedPart.etag\n                });\n                currentBytesInMemory -= part.blob.size;\n                activeUploads--;\n                bytesSent += part.blob.size;\n                if (partsToUpload.length > 0) {\n                    sendParts();\n                }\n                if (doneReading) {\n                    if (activeUploads === 0) {\n                        reader.releaseLock();\n                        resolve(completedParts);\n                    }\n                    return;\n                }\n                if (!reading) {\n                    read().catch(cancel);\n                }\n            } catch (error) {\n                cancel(error);\n            }\n        }\n        function sendParts() {\n            if (rejected) {\n                return;\n            }\n            debug(\"send parts\", \"activeUploads\", activeUploads, \"partsToUpload\", partsToUpload.length);\n            while(activeUploads < maxConcurrentUploads && partsToUpload.length > 0){\n                const partToSend = partsToUpload.shift();\n                if (partToSend) {\n                    void sendPart(partToSend);\n                }\n            }\n        }\n        function cancel(error) {\n            if (rejected) {\n                return;\n            }\n            rejected = true;\n            internalAbortController.abort();\n            reader.releaseLock();\n            if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n                reject(new BlobServiceNotAvailable());\n            } else {\n                reject(error);\n            }\n        }\n    });\n}\n// src/multipart/create-uploader.ts\nfunction createCreateMultipartUploaderMethod(param) {\n    let { allowedOptions, getToken, extraChecks } = param;\n    return async (pathname, optionsInput)=>{\n        const options = await createPutOptions({\n            pathname,\n            options: optionsInput,\n            extraChecks,\n            getToken\n        });\n        const headers = createPutHeaders(allowedOptions, options);\n        const createMultipartUploadResponse = await createMultipartUpload(pathname, headers, options);\n        return {\n            key: createMultipartUploadResponse.key,\n            uploadId: createMultipartUploadResponse.uploadId,\n            async uploadPart (partNumber, body) {\n                if (isPlainObject(body)) {\n                    throw new BlobError(\"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\");\n                }\n                const result = await uploadPart({\n                    uploadId: createMultipartUploadResponse.uploadId,\n                    key: createMultipartUploadResponse.key,\n                    pathname,\n                    part: {\n                        partNumber,\n                        blob: body\n                    },\n                    headers,\n                    options\n                });\n                return {\n                    etag: result.etag,\n                    partNumber\n                };\n            },\n            async complete (parts) {\n                return completeMultipartUpload({\n                    uploadId: createMultipartUploadResponse.uploadId,\n                    key: createMultipartUploadResponse.key,\n                    pathname,\n                    parts,\n                    headers,\n                    options\n                });\n            }\n        };\n    };\n}\n// src/put.ts\n\n// src/multipart/uncontrolled.ts\nasync function uncontrolledMultipartUpload(pathname, body, headers, options) {\n    debug(\"mpu: init\", \"pathname:\", pathname, \"headers:\", headers);\n    const optionsWithoutOnUploadProgress = {\n        ...options,\n        onUploadProgress: void 0\n    };\n    const createMultipartUploadResponse = await createMultipartUpload(pathname, headers, optionsWithoutOnUploadProgress);\n    const totalToLoad = computeBodyLength(body);\n    const stream = await toReadableStream(body);\n    const parts = await uploadAllParts({\n        uploadId: createMultipartUploadResponse.uploadId,\n        key: createMultipartUploadResponse.key,\n        pathname,\n        stream,\n        headers,\n        options,\n        totalToLoad\n    });\n    const blob = await completeMultipartUpload({\n        uploadId: createMultipartUploadResponse.uploadId,\n        key: createMultipartUploadResponse.key,\n        pathname,\n        parts,\n        headers,\n        options: optionsWithoutOnUploadProgress\n    });\n    return blob;\n}\n// src/put.ts\nfunction createPutMethod(param) {\n    let { allowedOptions, getToken, extraChecks } = param;\n    return async function put(pathname, body, optionsInput) {\n        if (!body) {\n            throw new BlobError(\"body is required\");\n        }\n        if (isPlainObject(body)) {\n            throw new BlobError(\"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\");\n        }\n        const options = await createPutOptions({\n            pathname,\n            options: optionsInput,\n            extraChecks,\n            getToken\n        });\n        const headers = createPutHeaders(allowedOptions, options);\n        if (options.multipart === true) {\n            return uncontrolledMultipartUpload(pathname, body, headers, options);\n        }\n        const onUploadProgress = options.onUploadProgress ? throttleit__WEBPACK_IMPORTED_MODULE_5__(options.onUploadProgress, 100) : void 0;\n        const params = new URLSearchParams({\n            pathname\n        });\n        const response = await requestApi(\"/?\".concat(params.toString()), {\n            method: \"PUT\",\n            body,\n            headers,\n            signal: options.abortSignal\n        }, {\n            ...options,\n            onUploadProgress\n        });\n        return {\n            url: response.url,\n            downloadUrl: response.downloadUrl,\n            pathname: response.pathname,\n            contentType: response.contentType,\n            contentDisposition: response.contentDisposition\n        };\n    };\n}\n// src/create-folder.ts\nasync function createFolder(pathname) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const folderPathname = pathname.endsWith(\"/\") ? pathname : \"\".concat(pathname, \"/\");\n    const headers = {};\n    headers[putOptionHeaderMap.addRandomSuffix] = \"0\";\n    const params = new URLSearchParams({\n        pathname: folderPathname\n    });\n    const response = await requestApi(\"/?\".concat(params.toString()), {\n        method: \"PUT\",\n        headers,\n        signal: options.abortSignal\n    }, options);\n    return {\n        url: response.url,\n        pathname: response.pathname\n    };\n}\n /*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */  //# sourceMappingURL=chunk-FN6XFH6R.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmVyY2VsL2Jsb2IvZGlzdC9jaHVuay1GTjZYRkg2Ui5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCO0FBQytCO0FBRWhELDJCQUEyQjtBQUNNO0FBQ0M7QUFDbEMsSUFBSUcsaUNBQWlDLElBQUlDLFFBQVEsQ0FBQ0M7SUFDaEQsSUFBSTtRQUNGLE1BQU1DLHFCQUFxQixJQUFJQyxXQUFXO1lBQUM7WUFBSztZQUFLO1lBQUs7WUFBSztTQUFJO1FBQ25FLE1BQU1DLE9BQU8sSUFBSUMsS0FBSztZQUFDSDtTQUFtQjtRQUMxQ0UsS0FBS0UsSUFBSSxHQUFHQyxJQUFJLENBQUMsQ0FBQ0Q7WUFDaEJMLFFBQVFLLFNBQVM7UUFDbkIsR0FBR0UsS0FBSyxDQUFDO1lBQ1BQLFFBQVE7UUFDVjtJQUNGLEVBQUUsVUFBTTtRQUNOQSxRQUFRO0lBQ1Y7QUFDRjtBQUNBLGVBQWVRLGlCQUFpQkMsS0FBSztJQUNuQyxJQUFJQSxpQkFBaUJDLGdCQUFnQjtRQUNuQyxPQUFPRDtJQUNUO0lBQ0EsSUFBSUEsaUJBQWlCTCxNQUFNO1FBQ3pCLE9BQU9LLE1BQU1FLE1BQU07SUFDckI7SUFDQSxJQUFJQyx1QkFBdUJILFFBQVE7UUFDakMsT0FBT1osNENBQVFBLENBQUNnQixLQUFLLENBQUNKO0lBQ3hCO0lBQ0EsSUFBSUs7SUFDSixJQUFJTCxpQkFBaUJNLGFBQWE7UUFDaENELGNBQWMsSUFBSVosV0FBV087SUFDL0IsT0FBTyxJQUFJTyxlQUFlUCxRQUFRO1FBQ2hDSyxjQUFjTDtJQUNoQixPQUFPO1FBQ0xLLGNBQWNHLG1CQUFtQlI7SUFDbkM7SUFDQSxJQUFJLE1BQU1YLGdDQUFnQztRQUN4QyxPQUFPLElBQUlNLEtBQUs7WUFBQ1U7U0FBWSxFQUFFSCxNQUFNO0lBQ3ZDO0lBQ0EsT0FBTyxJQUFJRCxlQUFlO1FBQ3hCUSxPQUFNQyxVQUFVO1lBQ2RBLFdBQVdDLE9BQU8sQ0FBQ047WUFDbkJLLFdBQVdFLEtBQUs7UUFDbEI7SUFDRjtBQUNGO0FBQ0EsU0FBU1QsdUJBQXVCSCxLQUFLO0lBQ25DLE9BQU8sT0FBT0EsVUFBVSxZQUFZLE9BQU9BLE1BQU1hLElBQUksS0FBSyxjQUFjYixNQUFNYyxRQUFRLElBQUksT0FBT2QsTUFBTWUsS0FBSyxLQUFLLGNBQWMsMERBQTBEO0lBQ3pMLE9BQU9mLE1BQU1nQixjQUFjLEtBQUs7QUFDbEM7QUFDQSxTQUFTUixtQkFBbUJTLENBQUM7SUFDM0IsTUFBTUMsTUFBTSxJQUFJQztJQUNoQixPQUFPRCxJQUFJRSxNQUFNLENBQUNIO0FBQ3BCO0FBQ0EsU0FBU1YsZUFBZVAsS0FBSztJQUMzQixPQUFPYixzQ0FBUUEsQ0FBQ2E7QUFDbEI7QUFFQSxlQUFlO0FBQ2YsSUFBSXFCLGNBQWM7QUFDbEIsSUFBSUMsTUFBTTtJQUNSQyxHQUFHO0lBQ0hDLElBQUksS0FBSztJQUNUQyxJQUFJLEtBQUs7SUFDVEMsSUFBSSxLQUFLO0lBQ1RDLElBQUksUUFBUTtJQUNaQyxJQUFJLFFBQVE7QUFDZDtBQUNBLFNBQVNDLE1BQU1DLEdBQUc7SUFDaEIsSUFBSSxPQUFPQSxRQUFRLFlBQVksQ0FBQ0MsT0FBT0MsS0FBSyxDQUFDRixNQUFNO1FBQ2pELE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUMzQixPQUFPO0lBQ1Q7SUFDQSxNQUFNRyxVQUFVWixZQUFZYSxJQUFJLENBQUNKO0lBQ2pDLElBQUlLO0lBQ0osSUFBSUMsT0FBTztJQUNYLElBQUksQ0FBQ0gsU0FBUztRQUNaRSxhQUFhRSxTQUFTUCxLQUFLO0lBQzdCLE9BQU87UUFDTCxNQUFNLEdBQUdRLFNBQVNDLFVBQVUsR0FBR047UUFDL0IsSUFBSSxDQUFDSyxLQUFLO1lBQ1IsT0FBTztRQUNUO1FBQ0FILGFBQWFLLFdBQVdGO1FBQ3hCLElBQUlDLFdBQVc7WUFDYkgsT0FBT0csVUFBVUUsV0FBVztRQUM5QjtJQUNGO0lBQ0EsSUFBSVYsT0FBT0MsS0FBSyxDQUFDRyxhQUFhO1FBQzVCLE9BQU87SUFDVDtJQUNBLE9BQU9PLEtBQUtDLEtBQUssQ0FBQ3JCLEdBQUcsQ0FBQ2MsS0FBSyxHQUFHRDtBQUNoQztBQUVBLGlCQUFpQjtBQUNqQixJQUFJUywwQkFBMEI7QUFDOUIsU0FBU0MseUJBQXlCQyxPQUFPO0lBQ3ZDLElBQUlBLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFDLEtBQUssRUFBRTtRQUM1QyxPQUFPRCxRQUFRQyxLQUFLO0lBQ3RCO0lBQ0EsSUFBSUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxxQkFBcUIsRUFBRTtRQUNyQyxPQUFPRixPQUFPQSxDQUFDQyxHQUFHLENBQUNDLHFCQUFxQjtJQUMxQztJQUNBLE1BQU0sSUFBSUMsVUFDUjtBQUVKO0FBQ0EsSUFBSUEsWUFBWSxjQUFjQztJQUM1QkMsWUFBWUMsT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxnQkFBd0IsT0FBUkE7SUFDeEI7QUFDRjtBQUNBLFNBQVNDLGVBQWVDLE9BQU87SUFDN0IsTUFBTUMsTUFBTSxJQUFJQyxJQUFJRjtJQUNwQkMsSUFBSUUsWUFBWSxDQUFDQyxHQUFHLENBQUMsWUFBWTtJQUNqQyxPQUFPSCxJQUFJSSxRQUFRO0FBQ3JCO0FBQ0EsU0FBU0MsY0FBYzlELEtBQUs7SUFDMUIsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsTUFBTTtRQUMvQyxPQUFPO0lBQ1Q7SUFDQSxNQUFNK0QsWUFBWUMsT0FBT0MsY0FBYyxDQUFDakU7SUFDeEMsT0FBTyxDQUFDK0QsY0FBYyxRQUFRQSxjQUFjQyxPQUFPRCxTQUFTLElBQUlDLE9BQU9DLGNBQWMsQ0FBQ0YsZUFBZSxJQUFHLEtBQU0sQ0FBRUcsQ0FBQUEsT0FBT0MsV0FBVyxJQUFJbkUsS0FBSSxLQUFNLENBQUVrRSxDQUFBQSxPQUFPRSxRQUFRLElBQUlwRSxLQUFJO0FBQzNLO0FBQ0EsSUFBSXFFLCtCQUErQjtJQUFDO0NBQUs7QUFDekMsSUFBSUMseUJBQXlCLENBQUM7SUFDNUIsSUFBSXBGLDhEQUFhQSxJQUFJO1FBQ25CLE9BQU87SUFDVDtJQUNBLE1BQU1xRixTQUFTQztJQUNmLElBQUlELE9BQU9FLFVBQVUsQ0FBQyxxQkFBcUI7UUFDekMsT0FBTztJQUNUO0lBQ0EsSUFBSUMsaUJBQWlCO0lBQ3JCLE1BQU1DLGlCQUFpQixJQUFJQyxRQUFRSixhQUFhO1FBQzlDSyxNQUFNLElBQUk1RTtRQUNWNkUsUUFBUTtRQUNSLG1KQUFtSjtRQUNuSixJQUFJQyxVQUFTO1lBQ1hMLGlCQUFpQjtZQUNqQixPQUFPO1FBQ1Q7SUFDRixHQUFHTSxPQUFPLENBQUNDLEdBQUcsQ0FBQztJQUNmLE9BQU9QLGtCQUFrQixDQUFDQztBQUM1QjtBQUNBLFNBQVNIO1FBQVVVLFdBQUFBLGlFQUFXO0lBQzVCLElBQUlDLFVBQVU7SUFDZCxJQUFJO1FBQ0ZBLFVBQVVuQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNtQyxtQkFBbUIsSUFBSXBDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ29DLCtCQUErQjtJQUMxRixFQUFFLFVBQU0sQ0FDUjtJQUNBLE9BQU8sR0FBd0NILE9BQXJDQyxXQUFXdkMseUJBQW1DLE9BQVRzQztBQUNqRDtBQUNBLElBQUlJLGVBQWUsT0FBT25FLGdCQUFnQixhQUFhLElBQUlBLGdCQUFnQjtBQUMzRSxTQUFTb0Usa0JBQWtCVixJQUFJO0lBQzdCLElBQUksQ0FBQ0EsTUFBTTtRQUNULE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0EsU0FBUyxVQUFVO1FBQzVCLElBQUlTLGNBQWM7WUFDaEIsT0FBT0EsYUFBYWxFLE1BQU0sQ0FBQ3lELE1BQU1XLFVBQVU7UUFDN0M7UUFDQSxPQUFPLElBQUk3RixLQUFLO1lBQUNrRjtTQUFLLEVBQUVZLElBQUk7SUFDOUI7SUFDQSxJQUFJLGdCQUFnQlosUUFBUSxPQUFPQSxLQUFLVyxVQUFVLEtBQUssVUFBVTtRQUMvRCxPQUFPWCxLQUFLVyxVQUFVO0lBQ3hCO0lBQ0EsSUFBSSxVQUFVWCxRQUFRLE9BQU9BLEtBQUtZLElBQUksS0FBSyxVQUFVO1FBQ25ELE9BQU9aLEtBQUtZLElBQUk7SUFDbEI7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxJQUFJQyw2QkFBNkIsQ0FBQ0MsV0FBV0M7SUFDM0MsSUFBSUMsU0FBUyxJQUFJcEcsV0FBVztJQUM1QixPQUFPLElBQUlxRyxnQkFBZ0I7UUFDekJDLFdBQVVDLEtBQUssRUFBRXRGLFVBQVU7WUFDekJ1RixlQUFlO2dCQUNiLE1BQU1DLFlBQVksSUFBSXpHLFdBQVdvRyxPQUFPTSxNQUFNLEdBQUdILE1BQU1SLFVBQVU7Z0JBQ2pFVSxVQUFVdEMsR0FBRyxDQUFDaUM7Z0JBQ2RLLFVBQVV0QyxHQUFHLENBQUMsSUFBSW5FLFdBQVd1RyxRQUFRSCxPQUFPTSxNQUFNO2dCQUNsRE4sU0FBU0s7Z0JBQ1QsTUFBT0wsT0FBT00sTUFBTSxJQUFJUixVQUFXO29CQUNqQyxNQUFNUyxXQUFXUCxPQUFPUSxLQUFLLENBQUMsR0FBR1Y7b0JBQ2pDakYsV0FBV0MsT0FBTyxDQUFDeUY7b0JBQ25CUixjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXUSxTQUFTWixVQUFVO29CQUM1REssU0FBU0EsT0FBT1EsS0FBSyxDQUFDVjtnQkFDeEI7WUFDRjtRQUNGO1FBQ0FXLE9BQU01RixVQUFVO1lBQ2R1RixlQUFlO2dCQUNiLElBQUlKLE9BQU9NLE1BQU0sR0FBRyxHQUFHO29CQUNyQnpGLFdBQVdDLE9BQU8sQ0FBQ2tGO29CQUNuQkQsY0FBYyxPQUFPLEtBQUssSUFBSUEsV0FBV0MsT0FBT0wsVUFBVTtnQkFDNUQ7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNlLGlCQUFpQnZHLEtBQUs7SUFDN0IsT0FBT3dHLFdBQVd2RyxjQUFjLElBQUksc0VBQXNFO0lBQzFHRCxpQkFBaUJDO0FBQ25CO0FBQ0EsU0FBU3dHLFNBQVN6RyxLQUFLO0lBQ3JCLElBQUl1RyxpQkFBaUJ2RyxRQUFRO1FBQzNCLE9BQU87SUFDVDtJQUNBLElBQUlHLHVCQUF1QkgsUUFBUTtRQUNqQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxhQUFhO0FBQ21CO0FBRWhDLGVBQWU7QUFDZixJQUFJMkcsZ0JBQWdCO0FBQ3BCLElBQUlDLElBQUlDO0FBQ1IsSUFBSTtJQUNGLElBQUksQ0FBQyxDQUFDRCxLQUFLNUQsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDNkQsS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJRixHQUFHRyxRQUFRLENBQUMsT0FBTSxLQUFPLEVBQUNGLEtBQUs3RCxPQUFPQSxDQUFDQyxHQUFHLENBQUMrRCxpQkFBaUIsS0FBSyxPQUFPLEtBQUssSUFBSUgsR0FBR0UsUUFBUSxDQUFDLE9BQU0sR0FBSTtRQUN0SkosZ0JBQWdCO0lBQ2xCO0FBQ0YsRUFBRSxVQUFNLENBQ1I7QUFDQSxTQUFTTSxNQUFNM0QsT0FBTztJQUFFO1FBQUc0RCxLQUFILDJCQUFPOztJQUM3QixJQUFJUCxlQUFlO1FBQ2pCUSxRQUFRRixLQUFLLENBQUMsZ0JBQXdCLE9BQVIzRCxhQUFjNEQ7SUFDOUM7QUFDRjtBQUVBLHVCQUF1QjtBQUN2QixJQUFJRTtBQUNKLElBQUlDLGdCQUFnQixDQUFDRCxNQUFNWixXQUFXYyxZQUFZLEtBQUssT0FBT0YsTUFBTSxDQUFDO0lBQ25FLElBQUk7UUFDRkcsS0FBSztJQUNQLEVBQUUsT0FBT0MsS0FBSztRQUNaLE9BQU94RCxPQUFPQyxjQUFjLENBQUN1RCxLQUFLbkUsV0FBVztJQUMvQztBQUNGO0FBRUEsMEJBQTBCO0FBQzFCLElBQUlvRSxpQkFBaUJ6RCxPQUFPRCxTQUFTLENBQUNGLFFBQVE7QUFDOUMsSUFBSTZELFVBQVUsQ0FBQzFILFFBQVV5SCxlQUFlRSxJQUFJLENBQUMzSCxXQUFXO0FBQ3hELElBQUk0SCxnQkFBZ0IsYUFBYSxHQUFHLElBQUlDLElBQUk7SUFDMUM7SUFDQSxTQUFTO0lBQ1Q7SUFDQSxTQUFTO0lBQ1Q7SUFDQSxVQUFVO0lBQ1Y7SUFDQSxZQUFZO0lBQ1o7SUFDQSxhQUFhO0lBQ2I7SUFDQSxnQkFBZ0I7SUFDaEI7SUFDQSxtQkFBbUI7SUFDbkI7Q0FFRDtBQUNELFNBQVNDLGVBQWVDLEtBQUs7SUFDM0IsTUFBTUMsVUFBVUQsU0FBU0wsUUFBUUssVUFBVUEsTUFBTUUsSUFBSSxLQUFLLGVBQWUsT0FBT0YsTUFBTXpFLE9BQU8sS0FBSztJQUNsRyxJQUFJLENBQUMwRSxTQUFTO1FBQ1osT0FBTztJQUNUO0lBQ0EsSUFBSUQsTUFBTXpFLE9BQU8sS0FBSyxlQUFlO1FBQ25DLE9BQU95RSxNQUFNRyxLQUFLLEtBQUssS0FBSztJQUM5QjtJQUNBLE9BQU9OLGNBQWMzQyxHQUFHLENBQUM4QyxNQUFNekUsT0FBTztBQUN4QztBQUVBLGVBQWU7QUFDZ0I7QUFDL0IsSUFBSThFLFdBQVcsT0FBT0QseUNBQUtBLEtBQUs7QUFDaEMsSUFBSUUsNkJBQTZCRCxZQUFZOUQ7QUFDN0MsSUFBSWdFLGFBQWEsS0FBSztBQUN0QixJQUFJQyxZQUFZO1FBQU8sRUFDckJDLEtBQUssRUFDTEMsSUFBSSxFQUNKQyxnQkFBZ0IsRUFDakI7SUFDQ3pCLE1BQU07SUFDTixJQUFJcEM7SUFDSixJQUFJNEQsS0FBSzVELElBQUksRUFBRTtRQUNiLElBQUk2RCxrQkFBa0I7WUFDcEIsTUFBTXhJLFNBQVMsTUFBTUgsaUJBQWlCMEksS0FBSzVELElBQUk7WUFDL0MsSUFBSThELFNBQVM7WUFDYixNQUFNQyx1QkFBdUJsRCwyQkFDM0I0QyxZQUNBLENBQUNPO2dCQUNDRixVQUFVRTtnQkFDVkgsaUJBQWlCQztZQUNuQjtZQUVGOUQsT0FBTzNFLE9BQU80SSxXQUFXLENBQUNGO1FBQzVCLE9BQU87WUFDTC9ELE9BQU80RCxLQUFLNUQsSUFBSTtRQUNsQjtJQUNGO0lBQ0EsTUFBTUUsU0FBU1QsMEJBQTBCTyxRQUFRNEIsU0FBUzVCLFFBQVEsU0FBUyxLQUFLO0lBQ2hGLE9BQU9zRCw2Q0FBS0EsQ0FDVkssT0FDQSxvRkFBb0Y7SUFDcEY7UUFDRSxHQUFHQyxJQUFJO1FBQ1AsR0FBR0EsS0FBSzVELElBQUksR0FBRztZQUFFQTtRQUFLLElBQUksQ0FBQyxDQUFDO1FBQzVCRTtJQUNGO0FBRUo7QUFFQSxhQUFhO0FBQ2IsSUFBSWdFLFNBQVMsT0FBT0MsbUJBQW1CO0FBQ3ZDLElBQUlDLFVBQVU7UUFBTyxFQUNuQlQsS0FBSyxFQUNMQyxJQUFJLEVBQ0pDLGdCQUFnQixFQUNqQjtJQUNDekIsTUFBTTtJQUNOLElBQUlwQyxPQUFPO0lBQ1gsSUFBSTRELEtBQUs1RCxJQUFJLEVBQUU7UUFDYixJQUFJMEIsaUJBQWlCa0MsS0FBSzVELElBQUksR0FBRztZQUMvQkEsT0FBTyxNQUFNLElBQUlxRSxTQUFTVCxLQUFLNUQsSUFBSSxFQUFFbkYsSUFBSTtRQUMzQyxPQUFPO1lBQ0xtRixPQUFPNEQsS0FBSzVELElBQUk7UUFDbEI7SUFDRjtJQUNBLE9BQU8sSUFBSXZGLFFBQVEsQ0FBQ0MsU0FBUzRKO1FBQzNCLE1BQU1DLE1BQU0sSUFBSUo7UUFDaEJJLElBQUlDLElBQUksQ0FBQ1osS0FBSzNELE1BQU0sSUFBSSxPQUFPMEQsTUFBTTNFLFFBQVEsSUFBSTtRQUNqRCxJQUFJNkUsa0JBQWtCO1lBQ3BCVSxJQUFJRSxNQUFNLENBQUNDLGdCQUFnQixDQUFDLFlBQVksQ0FBQ0M7Z0JBQ3ZDLElBQUlBLE1BQU1DLGdCQUFnQixFQUFFO29CQUMxQmYsaUJBQWlCYyxNQUFNYixNQUFNO2dCQUMvQjtZQUNGO1FBQ0Y7UUFDQVMsSUFBSU0sTUFBTSxHQUFHO1lBQ1gsSUFBSUM7WUFDSixJQUFJLENBQUNBLE1BQU1sQixLQUFLbUIsTUFBTSxLQUFLLE9BQU8sS0FBSyxJQUFJRCxJQUFJRSxPQUFPLEVBQUU7Z0JBQ3REVixPQUFPLElBQUk3QixhQUFhLGlDQUFpQztnQkFDekQ7WUFDRjtZQUNBLE1BQU10QyxVQUFVLElBQUk4RTtZQUNwQixNQUFNQyxhQUFhWCxJQUFJWSxxQkFBcUIsR0FBR0MsSUFBSSxHQUFHQyxLQUFLLENBQUM7WUFDNURILFdBQVdJLE9BQU8sQ0FBQyxDQUFDQztnQkFDbEIsTUFBTUMsUUFBUUQsS0FBS0YsS0FBSyxDQUFDO2dCQUN6QixNQUFNSSxNQUFNRCxNQUFNRSxLQUFLO2dCQUN2QixNQUFNdkssUUFBUXFLLE1BQU1HLElBQUksQ0FBQztnQkFDekIsSUFBSUYsS0FBS3RGLFFBQVFwQixHQUFHLENBQUMwRyxJQUFJN0gsV0FBVyxJQUFJekM7WUFDMUM7WUFDQSxNQUFNeUssV0FBVyxJQUFJdkIsU0FBU0UsSUFBSXFCLFFBQVEsRUFBRTtnQkFDMUNDLFFBQVF0QixJQUFJc0IsTUFBTTtnQkFDbEJDLFlBQVl2QixJQUFJdUIsVUFBVTtnQkFDMUIzRjtZQUNGO1lBQ0F6RixRQUFRa0w7UUFDVjtRQUNBckIsSUFBSXdCLE9BQU8sR0FBRztZQUNaekIsT0FBTyxJQUFJMEIsVUFBVTtRQUN2QjtRQUNBekIsSUFBSTBCLFNBQVMsR0FBRztZQUNkM0IsT0FBTyxJQUFJMEIsVUFBVTtRQUN2QjtRQUNBekIsSUFBSTJCLE9BQU8sR0FBRztZQUNaNUIsT0FBTyxJQUFJN0IsYUFBYSwrQkFBK0I7UUFDekQ7UUFDQSxJQUFJbUIsS0FBS3pELE9BQU8sRUFBRTtZQUNoQixNQUFNQSxVQUFVLElBQUk4RSxRQUFRckIsS0FBS3pELE9BQU87WUFDeENBLFFBQVFtRixPQUFPLENBQUMsQ0FBQ25LLE9BQU9zSztnQkFDdEJsQixJQUFJNEIsZ0JBQWdCLENBQUNWLEtBQUt0SztZQUM1QjtRQUNGO1FBQ0EsSUFBSXlJLEtBQUttQixNQUFNLEVBQUU7WUFDZm5CLEtBQUttQixNQUFNLENBQUNMLGdCQUFnQixDQUFDLFNBQVM7Z0JBQ3BDSCxJQUFJNkIsS0FBSztZQUNYO1lBQ0EsSUFBSXhDLEtBQUttQixNQUFNLENBQUNDLE9BQU8sRUFBRTtnQkFDdkJULElBQUk2QixLQUFLO2dCQUNUO1lBQ0Y7UUFDRjtRQUNBN0IsSUFBSThCLElBQUksQ0FBQ3JHO0lBQ1g7QUFDRjtBQUVBLGlCQUFpQjtBQUNqQixJQUFJc0csY0FBYztRQUFPLEVBQ3ZCM0MsS0FBSyxFQUNMQyxJQUFJLEVBQ0pDLGdCQUFnQixFQUNqQjtJQUNDLElBQUlBLGtCQUFrQjtRQUNwQixJQUFJTCw0QkFBNEI7WUFDOUIsT0FBT0UsVUFBVTtnQkFBRUM7Z0JBQU9DO2dCQUFNQztZQUFpQjtRQUNuRDtRQUNBLElBQUlLLFFBQVE7WUFDVixPQUFPRSxRQUFRO2dCQUFFVDtnQkFBT0M7Z0JBQU1DO1lBQWlCO1FBQ2pEO0lBQ0Y7SUFDQSxJQUFJTixVQUFVO1FBQ1osT0FBT0csVUFBVTtZQUFFQztZQUFPQztRQUFLO0lBQ2pDO0lBQ0EsSUFBSU0sUUFBUTtRQUNWLE9BQU9FLFFBQVE7WUFBRVQ7WUFBT0M7UUFBSztJQUMvQjtJQUNBLE1BQU0sSUFBSXJGLE1BQU07QUFDbEI7QUFFQSxhQUFhO0FBQ2IsSUFBSWdJLDBCQUEwQjtBQUM5QixJQUFJQyxrQkFBa0IsY0FBY2xJO0lBQ2xDRSxhQUFjO1FBQ1osS0FBSyxDQUFDO0lBQ1I7QUFDRjtBQUNBLElBQUlpSSxpQ0FBaUMsY0FBY25JO0lBQ2pERSxZQUFZQyxPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDLDBCQUFrQyxPQUFSQSxTQUFRO0lBQzFDO0FBQ0Y7QUFDQSxJQUFJaUksNEJBQTRCLGNBQWNwSTtJQUM1Q0UsWUFBWUMsT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FDSCxzQkFBOEIsT0FBUkEsU0FBUTtJQUVsQztBQUNGO0FBQ0EsSUFBSWtJLDhCQUE4QixjQUFjckk7SUFDOUNFLGFBQWM7UUFDWixLQUFLLENBQUM7SUFDUjtBQUNGO0FBQ0EsSUFBSW9JLHdCQUF3QixjQUFjdEk7SUFDeENFLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUMsc0JBQThCLE9BQVJBLFNBQVE7SUFDdEM7QUFDRjtBQUNBLElBQUlvSSx5QkFBeUIsY0FBY3ZJO0lBQ3pDRSxhQUFjO1FBQ1osS0FBSyxDQUFDO0lBQ1I7QUFDRjtBQUNBLElBQUlzSSwwQkFBMEIsY0FBY3hJO0lBQzFDRSxhQUFjO1FBQ1osS0FBSyxDQUFDO0lBQ1I7QUFDRjtBQUNBLElBQUl1SSxtQkFBbUIsY0FBY3pJO0lBQ25DRSxhQUFjO1FBQ1osS0FBSyxDQUFDO0lBQ1I7QUFDRjtBQUNBLElBQUl3SSxvQkFBb0IsY0FBYzFJO0lBQ3BDRSxhQUFjO1FBQ1osS0FBSyxDQUFDO0lBQ1I7QUFDRjtBQUNBLElBQUl5SSwwQkFBMEIsY0FBYzNJO0lBQzFDRSxhQUFjO1FBQ1osS0FBSyxDQUFDO0lBQ1I7QUFDRjtBQUNBLElBQUkwSSx5QkFBeUIsY0FBYzVJO0lBQ3pDRSxZQUFZMkksT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FDSCxvRUFBd0gsT0FBcERBLFVBQVUsbUJBQTJCLE9BQVJBLFNBQVEsY0FBWSxJQUFHO1FBRTFILElBQUksQ0FBQ0MsVUFBVSxHQUFHRCxXQUFXLE9BQU9BLFVBQVU7SUFDaEQ7QUFDRjtBQUNBLElBQUlFLDBCQUEwQixjQUFjL0k7SUFDMUNFLGFBQWM7UUFDWixLQUFLLENBQUM7SUFDUjtBQUNGO0FBQ0EsSUFBSThJLG1CQUFtQjtBQUN2QixTQUFTQztJQUNQLElBQUlDLGtCQUFrQjtJQUN0QixJQUFJO1FBQ0ZBLGtCQUFrQnJKLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ3FKLGdDQUFnQyxJQUFJdEosT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDc0osNENBQTRDO0lBQzVILEVBQUUsVUFBTSxDQUNSO0lBQ0EsT0FBTyxHQUFnRSxPQUE3REYsbUJBQW1CLE9BQU9BLGtCQUFrQkY7QUFDeEQ7QUFDQSxTQUFTSztJQUNQLElBQUk7UUFDRixNQUFNQyxVQUFVekosT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDeUosbUJBQW1CLElBQUk7UUFDbkQsT0FBT3JLLFNBQVNvSyxTQUFTO0lBQzNCLEVBQUUsVUFBTTtRQUNOLE9BQU87SUFDVDtBQUNGO0FBQ0EsU0FBU0UsNkJBQTZCbEMsUUFBUTtJQUM1QyxNQUFNd0IsYUFBYXhCLFNBQVN6RixPQUFPLENBQUM0SCxHQUFHLENBQUM7SUFDeEMsT0FBTyxJQUFJYix1QkFDVEUsYUFBYTVKLFNBQVM0SixZQUFZLE1BQU0sS0FBSztBQUVqRDtBQUNBLGVBQWVZLGFBQWFwQyxRQUFRO0lBQ2xDLElBQUlkLEtBQUttRCxLQUFLQztJQUNkLElBQUlDO0lBQ0osSUFBSTFKO0lBQ0osSUFBSTtRQUNGLE1BQU0ySixPQUFPLE1BQU14QyxTQUFTeUMsSUFBSTtRQUNoQ0YsT0FBTyxDQUFDRixNQUFNLENBQUNuRCxNQUFNc0QsS0FBS2xGLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSTRCLElBQUlxRCxJQUFJLEtBQUssT0FBT0YsTUFBTTtRQUM5RXhKLFVBQVUsQ0FBQ3lKLEtBQUtFLEtBQUtsRixLQUFLLEtBQUssT0FBTyxLQUFLLElBQUlnRixHQUFHekosT0FBTztJQUMzRCxFQUFFLFVBQU07UUFDTjBKLE9BQU87SUFDVDtJQUNBLElBQUksQ0FBQzFKLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVF5RCxRQUFRLENBQUMsY0FBYSxLQUFNekQsUUFBUXlELFFBQVEsQ0FBQyxtQkFBbUI7UUFDdEdpRyxPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUMxSixXQUFXLE9BQU8sS0FBSyxJQUFJQSxRQUFReUQsUUFBUSxDQUFDLGFBQVksS0FBTXpELFFBQVF5RCxRQUFRLENBQUMscUNBQXFDO1FBQ3ZIaUcsT0FBTztJQUNUO0lBQ0EsSUFBSTFKLFlBQVksaUJBQWlCO1FBQy9CMEosT0FBTztJQUNUO0lBQ0EsSUFBSTFKLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVF5RCxRQUFRLENBQUMsMkNBQTJDO1FBQ3pGaUcsT0FBTztJQUNUO0lBQ0EsSUFBSWpGO0lBQ0osT0FBUWlGO1FBQ04sS0FBSztZQUNIakYsUUFBUSxJQUFJNEQ7WUFDWjtRQUNGLEtBQUs7WUFDSDVELFFBQVEsSUFBSXNEO1lBQ1o7UUFDRixLQUFLO1lBQ0h0RCxRQUFRLElBQUl1RCwrQkFBK0JoSTtZQUMzQztRQUNGLEtBQUs7WUFDSHlFLFFBQVEsSUFBSXdELDBCQUEwQmpJO1lBQ3RDO1FBQ0YsS0FBSztZQUNIeUUsUUFBUSxJQUFJeUQ7WUFDWjtRQUNGLEtBQUs7WUFDSHpELFFBQVEsSUFBSTBELHNCQUFzQm5JO1lBQ2xDO1FBQ0YsS0FBSztZQUNIeUUsUUFBUSxJQUFJOEQ7WUFDWjtRQUNGLEtBQUs7WUFDSDlELFFBQVEsSUFBSTJEO1lBQ1o7UUFDRixLQUFLO1lBQ0gzRCxRQUFRLElBQUk1RSxVQUFVRyxXQUFXLE9BQU9BLFVBQVU7WUFDbEQ7UUFDRixLQUFLO1lBQ0h5RSxRQUFRLElBQUkrRDtZQUNaO1FBQ0YsS0FBSztZQUNIL0QsUUFBUTRFLDZCQUE2QmxDO1lBQ3JDO1FBQ0YsS0FBSztRQUNMLEtBQUs7UUFDTDtZQUNFMUMsUUFBUSxJQUFJNkQ7WUFDWjtJQUNKO0lBQ0EsT0FBTztRQUFFb0I7UUFBTWpGO0lBQU07QUFDdkI7QUFDQSxlQUFlb0YsV0FBV2pJLFFBQVEsRUFBRXVELElBQUksRUFBRTJFLGNBQWM7SUFDdEQsTUFBTUMsYUFBYWpCO0lBQ25CLE1BQU1ySixRQUFRRix5QkFBeUJ1SztJQUN2QyxNQUFNRSxlQUFlQztJQUNyQixNQUFNLE9BQU9DLFVBQVUsRUFBRSxDQUFDLEdBQUd6SyxNQUFNbUgsS0FBSyxDQUFDO0lBQ3pDLE1BQU11RCxZQUFZLEdBQWNDLE9BQVhGLFNBQVEsS0FBaUI5SyxPQUFkZ0wsS0FBS0MsR0FBRyxJQUFHLEtBQXVDLE9BQXBDakwsS0FBS2tMLE1BQU0sR0FBRy9KLFFBQVEsQ0FBQyxJQUFJd0MsS0FBSyxDQUFDO0lBQy9FLElBQUl3SCxhQUFhO0lBQ2pCLElBQUlDLGFBQWE7SUFDakIsSUFBSUMsY0FBYztJQUNsQixNQUFNQyxpQkFBaUIsQ0FBQ1osa0JBQWtCLE9BQU8sS0FBSyxJQUFJQSxlQUFlMUUsZ0JBQWdCLEtBQUt1RjtJQUM5RixJQUFJeEYsS0FBSzVELElBQUksSUFBSSwyRUFBMkU7SUFDNUYseUZBQXlGO0lBQ3pGbUosZ0JBQWdCO1FBQ2RGLGFBQWF2SSxrQkFBa0JrRCxLQUFLNUQsSUFBSTtJQUMxQztJQUNBLElBQUl1SSxrQkFBa0IsT0FBTyxLQUFLLElBQUlBLGVBQWUxRSxnQkFBZ0IsRUFBRTtRQUNyRTBFLGVBQWUxRSxnQkFBZ0IsQ0FBQztZQUM5QkMsUUFBUTtZQUNSdUYsT0FBT0o7WUFDUEssWUFBWTtRQUNkO0lBQ0Y7SUFDQSxNQUFNQyxjQUFjLE1BQU0xSCx3Q0FBS0EsQ0FDN0IsT0FBTzJIO1FBQ0wsSUFBSS9MO1FBQ0osSUFBSTtZQUNGQSxNQUFNLE1BQU02SSxZQUFZO2dCQUN0QjNDLE9BQU9oRSxVQUFVVTtnQkFDakJ1RCxNQUFNO29CQUNKLEdBQUdBLElBQUk7b0JBQ1B6RCxTQUFTO3dCQUNQLHlCQUF5QnlJO3dCQUN6Qiw4QkFBOEJhLE9BQU9UO3dCQUNyQyxpQkFBaUJSO3dCQUNqQixHQUFHVyxpQkFBaUI7NEJBQUUsb0JBQW9CTSxPQUFPUjt3QkFBWSxJQUFJLENBQUMsQ0FBQzt3QkFDbkVTLGVBQWUsVUFBZ0IsT0FBTnhMO3dCQUN6QixHQUFHdUssWUFBWTt3QkFDZixHQUFHN0UsS0FBS3pELE9BQU87b0JBQ2pCO2dCQUNGO2dCQUNBMEQsa0JBQWtCLENBQUMwRSxrQkFBa0IsT0FBTyxLQUFLLElBQUlBLGVBQWUxRSxnQkFBZ0IsSUFBSSxDQUFDQztvQkFDdkYsSUFBSWdCO29CQUNKLE1BQU11RSxRQUFRSixlQUFlLElBQUlBLGFBQWFuRjtvQkFDOUNvRixjQUFjcEY7b0JBQ2QsTUFBTXdGLGFBQWFMLGFBQWEsSUFBSS9MLE9BQU8sQ0FBQzRHLFNBQVN1RixRQUFRLEdBQUUsRUFBR00sT0FBTyxDQUFDLE1BQU07b0JBQ2hGLElBQUlMLGVBQWUsT0FBT0wsYUFBYSxHQUFHO3dCQUN4QztvQkFDRjtvQkFDQ25FLENBQUFBLE1BQU15RCxlQUFlMUUsZ0JBQWdCLEtBQUssT0FBTyxLQUFLLElBQUlpQixJQUFJaEMsSUFBSSxDQUFDeUYsZ0JBQWdCO3dCQUNsRnpFO3dCQUNBLHFGQUFxRjt3QkFDckYsMkZBQTJGO3dCQUMzRix1RUFBdUU7d0JBQ3ZFLDhDQUE4Qzt3QkFDOUN1Rjt3QkFDQUM7b0JBQ0Y7Z0JBQ0YsSUFBSSxLQUFLO1lBQ1g7UUFDRixFQUFFLE9BQU9NLFFBQVE7WUFDZixJQUFJQSxrQkFBa0JwSCxpQkFBaUJvSCxPQUFPeEcsSUFBSSxLQUFLLGNBQWM7Z0JBQ25Fb0csS0FBSyxJQUFJbkM7Z0JBQ1Q7WUFDRjtZQUNBLElBQUlwRSxlQUFlMkcsU0FBUztnQkFDMUIsTUFBTUE7WUFDUjtZQUNBLElBQUlBLGtCQUFrQjVELFdBQVc7Z0JBQy9Cd0QsS0FBS0k7Z0JBQ0w7WUFDRjtZQUNBLE1BQU1BO1FBQ1I7UUFDQSxJQUFJbk0sSUFBSW9NLEVBQUUsRUFBRTtZQUNWLE9BQU9wTTtRQUNUO1FBQ0EsTUFBTSxFQUFFMEssSUFBSSxFQUFFakYsS0FBSyxFQUFFLEdBQUcsTUFBTThFLGFBQWF2SztRQUMzQyxJQUFJMEssU0FBUyxtQkFBbUJBLFNBQVMseUJBQXlCQSxTQUFTLHlCQUF5QjtZQUNsRyxNQUFNakY7UUFDUjtRQUNBc0csS0FBS3RHO0lBQ1AsR0FDQTtRQUNFMEUsU0FBU0Q7UUFDVG1DLFNBQVMsQ0FBQzVHO1lBQ1IsSUFBSUEsaUJBQWlCM0UsT0FBTztnQkFDMUI2RCxNQUFNLDJCQUFvQyxPQUFUL0IsV0FBWTZDLE1BQU16RSxPQUFPO1lBQzVEO1lBQ0F1SyxhQUFhQSxhQUFhO1FBQzVCO0lBQ0Y7SUFFRixJQUFJLENBQUNPLGFBQWE7UUFDaEIsTUFBTSxJQUFJeEM7SUFDWjtJQUNBLElBQUl3QixrQkFBa0IsT0FBTyxLQUFLLElBQUlBLGVBQWUxRSxnQkFBZ0IsRUFBRTtRQUNyRTBFLGVBQWUxRSxnQkFBZ0IsQ0FBQztZQUM5QkMsUUFBUW9GO1lBQ1JHLE9BQU9IO1lBQ1BJLFlBQVk7UUFDZDtJQUNGO0lBQ0EsT0FBTyxNQUFNQyxZQUFZbEIsSUFBSTtBQUMvQjtBQUNBLFNBQVNLO0lBQ1AsTUFBTUQsZUFBZSxDQUFDO0lBQ3RCLElBQUk7UUFDRixJQUFJLCtDQUErQ3RLLE9BQU9BLENBQUNDLEdBQUcsSUFBSUQsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDMkwseUNBQXlDLEtBQUssS0FBSyxHQUFHO1lBQ2xJdEIsWUFBWSxDQUFDLGtDQUFrQyxHQUFHdEssT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDMkwseUNBQXlDO1FBQ3pHLE9BQU8sSUFBSSwyREFBMkQ1TCxPQUFPQSxDQUFDQyxHQUFHLElBQUlELE9BQU9BLENBQUNDLEdBQUcsQ0FBQzRMLHFEQUFxRCxLQUFLLEtBQUssR0FBRztZQUNqS3ZCLFlBQVksQ0FBQyxrQ0FBa0MsR0FBR3RLLE9BQU9BLENBQUNDLEdBQUcsQ0FBQzRMLHFEQUFxRDtRQUNySDtJQUNGLEVBQUUsVUFBTSxDQUNSO0lBQ0EsT0FBT3ZCO0FBQ1Q7QUFDQSxTQUFTVztJQUNQLElBQUk7UUFDRixPQUFPakwsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDNkwsZ0NBQWdDLEtBQUs7SUFDMUQsRUFBRSxVQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFFQSxxQkFBcUI7QUFDckIsSUFBSUMscUJBQXFCO0lBQ3ZCQyxvQkFBb0I7SUFDcEJDLGlCQUFpQjtJQUNqQkMsZ0JBQWdCO0lBQ2hCQyxhQUFhO0FBQ2Y7QUFDQSxTQUFTQyxpQkFBaUJDLGNBQWMsRUFBRXZNLE9BQU87SUFDL0MsTUFBTWtDLFVBQVUsQ0FBQztJQUNqQixJQUFJcUssZUFBZXRJLFFBQVEsQ0FBQyxrQkFBa0JqRSxRQUFRcU0sV0FBVyxFQUFFO1FBQ2pFbkssT0FBTyxDQUFDK0osbUJBQW1CSSxXQUFXLENBQUMsR0FBR3JNLFFBQVFxTSxXQUFXO0lBQy9EO0lBQ0EsSUFBSUUsZUFBZXRJLFFBQVEsQ0FBQyxzQkFBc0JqRSxRQUFRbU0sZUFBZSxLQUFLLEtBQUssR0FBRztRQUNwRmpLLE9BQU8sQ0FBQytKLG1CQUFtQkUsZUFBZSxDQUFDLEdBQUduTSxRQUFRbU0sZUFBZSxHQUFHLE1BQU07SUFDaEY7SUFDQSxJQUFJSSxlQUFldEksUUFBUSxDQUFDLHFCQUFxQmpFLFFBQVFvTSxjQUFjLEtBQUssS0FBSyxHQUFHO1FBQ2xGbEssT0FBTyxDQUFDK0osbUJBQW1CRyxjQUFjLENBQUMsR0FBR3BNLFFBQVFvTSxjQUFjLEdBQUcsTUFBTTtJQUM5RTtJQUNBLElBQUlHLGVBQWV0SSxRQUFRLENBQUMseUJBQXlCakUsUUFBUWtNLGtCQUFrQixLQUFLLEtBQUssR0FBRztRQUMxRmhLLE9BQU8sQ0FBQytKLG1CQUFtQkMsa0JBQWtCLENBQUMsR0FBR2xNLFFBQVFrTSxrQkFBa0IsQ0FBQ25MLFFBQVE7SUFDdEY7SUFDQSxPQUFPbUI7QUFDVDtBQUNBLGVBQWVzSyxpQkFBaUIsS0FLL0I7UUFMK0IsRUFDOUJwSyxRQUFRLEVBQ1JwQyxPQUFPLEVBQ1B5TSxXQUFXLEVBQ1hDLFFBQVEsRUFDVCxHQUwrQjtJQU05QixJQUFJLENBQUN0SyxVQUFVO1FBQ2IsTUFBTSxJQUFJL0IsVUFBVTtJQUN0QjtJQUNBLElBQUkrQixTQUFTaUIsTUFBTSxHQUFHaUYseUJBQXlCO1FBQzdDLE1BQU0sSUFBSWpJLFVBQ1IsMkNBQW1FLE9BQXhCaUk7SUFFL0M7SUFDQSxLQUFLLE1BQU1xRSxvQkFBb0JwTCw2QkFBOEI7UUFDM0QsSUFBSWEsU0FBUzZCLFFBQVEsQ0FBQzBJLG1CQUFtQjtZQUN2QyxNQUFNLElBQUl0TSxVQUNSLDRCQUE2QyxPQUFqQnNNLGtCQUFpQjtRQUVqRDtJQUNGO0lBQ0EsSUFBSSxDQUFDM00sU0FBUztRQUNaLE1BQU0sSUFBSUssVUFBVTtJQUN0QjtJQUNBLElBQUlMLFFBQVE0TSxNQUFNLEtBQUssVUFBVTtRQUMvQixNQUFNLElBQUl2TSxVQUFVO0lBQ3RCO0lBQ0EsSUFBSW9NLGFBQWE7UUFDZkEsWUFBWXpNO0lBQ2Q7SUFDQSxJQUFJME0sVUFBVTtRQUNaMU0sUUFBUUMsS0FBSyxHQUFHLE1BQU15TSxTQUFTdEssVUFBVXBDO0lBQzNDO0lBQ0EsT0FBT0E7QUFDVDtBQUVBLDRCQUE0QjtBQUM1QixTQUFTNk0sb0NBQW9DLEtBQXlDO1FBQXpDLEVBQUVOLGNBQWMsRUFBRUcsUUFBUSxFQUFFRCxXQUFXLEVBQUUsR0FBekM7SUFDM0MsT0FBTyxPQUFPckssVUFBVW1GLE9BQU91RjtRQUM3QixNQUFNOU0sVUFBVSxNQUFNd00saUJBQWlCO1lBQ3JDcEs7WUFDQXBDLFNBQVM4TTtZQUNUTDtZQUNBQztRQUNGO1FBQ0EsTUFBTXhLLFVBQVVvSyxpQkFBaUJDLGdCQUFnQnZNO1FBQ2pELE9BQU8rTSx3QkFBd0I7WUFDN0JDLFVBQVVoTixRQUFRZ04sUUFBUTtZQUMxQnhGLEtBQUt4SCxRQUFRd0gsR0FBRztZQUNoQnBGO1lBQ0FGO1lBQ0FsQztZQUNBdUg7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxlQUFld0Ysd0JBQXdCLEtBT3RDO1FBUHNDLEVBQ3JDQyxRQUFRLEVBQ1J4RixHQUFHLEVBQ0hwRixRQUFRLEVBQ1JtRixLQUFLLEVBQ0xyRixPQUFPLEVBQ1BsQyxPQUFPLEVBQ1IsR0FQc0M7SUFRckMsTUFBTWlOLFNBQVMsSUFBSUMsZ0JBQWdCO1FBQUU5SztJQUFTO0lBQzlDLElBQUk7UUFDRixNQUFNdUYsV0FBVyxNQUFNMEMsV0FDckIsUUFBMEIsT0FBbEI0QyxPQUFPbE0sUUFBUSxLQUN2QjtZQUNFaUIsUUFBUTtZQUNSRSxTQUFTO2dCQUNQLEdBQUdBLE9BQU87Z0JBQ1YsZ0JBQWdCO2dCQUNoQixnQkFBZ0I7Z0JBQ2hCLG1CQUFtQjhLO2dCQUNuQiw2RkFBNkY7Z0JBQzdGLHdEQUF3RDtnQkFDeEQsYUFBYUcsbUJBQW1CM0Y7WUFDbEM7WUFDQXpGLE1BQU1xTCxLQUFLQyxTQUFTLENBQUM5RjtZQUNyQlQsUUFBUTlHLFFBQVFzTixXQUFXO1FBQzdCLEdBQ0F0TjtRQUVGbUUsTUFBTSxpQkFBaUJ3RDtRQUN2QixPQUFPQTtJQUNULEVBQUUsT0FBTzFDLE9BQU87UUFDZCxJQUFJQSxpQkFBaUI4QyxhQUFjOUMsQ0FBQUEsTUFBTXpFLE9BQU8sS0FBSyxxQkFBcUJ5RSxNQUFNekUsT0FBTyxLQUFLLGNBQWEsR0FBSTtZQUMzRyxNQUFNLElBQUl3STtRQUNaLE9BQU87WUFDTCxNQUFNL0Q7UUFDUjtJQUNGO0FBQ0Y7QUFFQSwwQkFBMEI7QUFDMUIsU0FBU3NJLGtDQUFrQyxLQUF5QztRQUF6QyxFQUFFaEIsY0FBYyxFQUFFRyxRQUFRLEVBQUVELFdBQVcsRUFBRSxHQUF6QztJQUN6QyxPQUFPLE9BQU9ySyxVQUFVMEs7UUFDdEIsTUFBTTlNLFVBQVUsTUFBTXdNLGlCQUFpQjtZQUNyQ3BLO1lBQ0FwQyxTQUFTOE07WUFDVEw7WUFDQUM7UUFDRjtRQUNBLE1BQU14SyxVQUFVb0ssaUJBQWlCQyxnQkFBZ0J2TTtRQUNqRCxNQUFNd04sZ0NBQWdDLE1BQU1DLHNCQUMxQ3JMLFVBQ0FGLFNBQ0FsQztRQUVGLE9BQU87WUFDTHdILEtBQUtnRyw4QkFBOEJoRyxHQUFHO1lBQ3RDd0YsVUFBVVEsOEJBQThCUixRQUFRO1FBQ2xEO0lBQ0Y7QUFDRjtBQUNBLGVBQWVTLHNCQUFzQnJMLFFBQVEsRUFBRUYsT0FBTyxFQUFFbEMsT0FBTztJQUM3RG1FLE1BQU0sZUFBZSxhQUFhL0I7SUFDbEMsTUFBTTZLLFNBQVMsSUFBSUMsZ0JBQWdCO1FBQUU5SztJQUFTO0lBQzlDLElBQUk7UUFDRixNQUFNdUYsV0FBVyxNQUFNMEMsV0FDckIsUUFBMEIsT0FBbEI0QyxPQUFPbE0sUUFBUSxLQUN2QjtZQUNFaUIsUUFBUTtZQUNSRSxTQUFTO2dCQUNQLEdBQUdBLE9BQU87Z0JBQ1YsZ0JBQWdCO1lBQ2xCO1lBQ0E0RSxRQUFROUcsUUFBUXNOLFdBQVc7UUFDN0IsR0FDQXROO1FBRUZtRSxNQUFNLGVBQWV3RDtRQUNyQixPQUFPQTtJQUNULEVBQUUsT0FBTzFDLE9BQU87UUFDZCxJQUFJQSxpQkFBaUI4QyxhQUFjOUMsQ0FBQUEsTUFBTXpFLE9BQU8sS0FBSyxxQkFBcUJ5RSxNQUFNekUsT0FBTyxLQUFLLGNBQWEsR0FBSTtZQUMzRyxNQUFNLElBQUl3STtRQUNaO1FBQ0EsTUFBTS9EO0lBQ1I7QUFDRjtBQUVBLDBCQUEwQjtBQUNRO0FBQ2xDLFNBQVMwSSx1QkFBdUIsS0FBeUM7UUFBekMsRUFBRXBCLGNBQWMsRUFBRUcsUUFBUSxFQUFFRCxXQUFXLEVBQUUsR0FBekM7SUFDOUIsT0FBTyxPQUFPckssVUFBVUwsTUFBTStLO1FBQzVCLE1BQU05TSxVQUFVLE1BQU13TSxpQkFBaUI7WUFDckNwSztZQUNBcEMsU0FBUzhNO1lBQ1RMO1lBQ0FDO1FBQ0Y7UUFDQSxNQUFNeEssVUFBVW9LLGlCQUFpQkMsZ0JBQWdCdk07UUFDakQsSUFBSWdCLGNBQWNlLE9BQU87WUFDdkIsTUFBTSxJQUFJMUIsVUFDUjtRQUVKO1FBQ0EsTUFBTXVOLFNBQVMsTUFBTUMsV0FBVztZQUM5QmIsVUFBVWhOLFFBQVFnTixRQUFRO1lBQzFCeEYsS0FBS3hILFFBQVF3SCxHQUFHO1lBQ2hCcEY7WUFDQTBMLE1BQU07Z0JBQUVsUixNQUFNbUY7Z0JBQU1nTSxZQUFZL04sUUFBUStOLFVBQVU7WUFBQztZQUNuRDdMO1lBQ0FsQztRQUNGO1FBQ0EsT0FBTztZQUNMZ08sTUFBTUosT0FBT0ksSUFBSTtZQUNqQkQsWUFBWS9OLFFBQVErTixVQUFVO1FBQ2hDO0lBQ0Y7QUFDRjtBQUNBLGVBQWVGLFdBQVcsS0FRekI7UUFSeUIsRUFDeEJiLFFBQVEsRUFDUnhGLEdBQUcsRUFDSHBGLFFBQVEsRUFDUkYsT0FBTyxFQUNQbEMsT0FBTyxFQUNQaU8sMEJBQTBCLElBQUlDLGlCQUFpQixFQUMvQ0osSUFBSSxFQUNMLEdBUnlCO0lBU3hCLElBQUlqSCxLQUFLbUQsS0FBS0M7SUFDZCxNQUFNZ0QsU0FBUyxJQUFJQyxnQkFBZ0I7UUFBRTlLO0lBQVM7SUFDOUMsTUFBTStMLGtCQUFrQjlELFdBQ3RCLFFBQTBCLE9BQWxCNEMsT0FBT2xNLFFBQVEsS0FDdkI7UUFDRStGLFFBQVFtSCx3QkFBd0JuSCxNQUFNO1FBQ3RDOUUsUUFBUTtRQUNSRSxTQUFTO1lBQ1AsR0FBR0EsT0FBTztZQUNWLGdCQUFnQjtZQUNoQixhQUFhaUwsbUJBQW1CM0Y7WUFDaEMsbUJBQW1Cd0Y7WUFDbkIscUJBQXFCYyxLQUFLQyxVQUFVLENBQUNoTixRQUFRO1FBQy9DO1FBQ0EsMkRBQTJEO1FBQzNEZ0IsTUFBTStMLEtBQUtsUixJQUFJO0lBQ2pCLEdBQ0FvRDtJQUVGLFNBQVNvTztRQUNQSCx3QkFBd0I5RixLQUFLO0lBQy9CO0lBQ0EsSUFBSSxDQUFDdEIsTUFBTTdHLFFBQVFzTixXQUFXLEtBQUssT0FBTyxLQUFLLElBQUl6RyxJQUFJRSxPQUFPLEVBQUU7UUFDOURxSDtJQUNGLE9BQU87UUFDSnBFLENBQUFBLE1BQU1oSyxRQUFRc04sV0FBVyxLQUFLLE9BQU8sS0FBSyxJQUFJdEQsSUFBSXZELGdCQUFnQixDQUFDLFNBQVMySDtJQUMvRTtJQUNBLE1BQU16RyxXQUFXLE1BQU13RztJQUN0QmxFLENBQUFBLEtBQUtqSyxRQUFRc04sV0FBVyxLQUFLLE9BQU8sS0FBSyxJQUFJckQsR0FBR29FLG1CQUFtQixDQUFDLFNBQVNEO0lBQzlFLE9BQU96RztBQUNUO0FBQ0EsSUFBSTJHLHVCQUF1QixLQUE2QixHQUFHLElBQUksQ0FBQztBQUNoRSxJQUFJQyxrQkFBa0IsSUFBSSxPQUFPO0FBQ2pDLElBQUlDLG1CQUFtQkYsdUJBQXVCQyxrQkFBa0I7QUFDaEUsU0FBU0UsZUFBZSxLQVF2QjtRQVJ1QixFQUN0QnpCLFFBQVEsRUFDUnhGLEdBQUcsRUFDSHBGLFFBQVEsRUFDUmhGLE1BQU0sRUFDTjhFLE9BQU8sRUFDUGxDLE9BQU8sRUFDUDBPLFdBQVcsRUFDWixHQVJ1QjtJQVN0QnZLLE1BQU0sb0JBQW9CLFFBQVFxRDtJQUNsQyxNQUFNeUcsMEJBQTBCLElBQUlDO0lBQ3BDLE9BQU8sSUFBSTFSLFFBQVEsQ0FBQ0MsU0FBUzRKO1FBQzNCLE1BQU1zSSxnQkFBZ0IsRUFBRTtRQUN4QixNQUFNQyxpQkFBaUIsRUFBRTtRQUN6QixNQUFNQyxTQUFTelIsT0FBTzBSLFNBQVM7UUFDL0IsSUFBSUMsZ0JBQWdCO1FBQ3BCLElBQUlDLFVBQVU7UUFDZCxJQUFJQyxvQkFBb0I7UUFDeEIsSUFBSUMsV0FBVztRQUNmLElBQUlDLHVCQUF1QjtRQUMzQixJQUFJQyxjQUFjO1FBQ2xCLElBQUlDLFlBQVk7UUFDaEIsSUFBSUMsZUFBZSxFQUFFO1FBQ3JCLElBQUlDLHVCQUF1QjtRQUMzQixJQUFJM0o7UUFDSixNQUFNNEosMkJBQTJCLENBQUM7UUFDbEMsSUFBSXhQLFFBQVE0RixnQkFBZ0IsRUFBRTtZQUM1QkEsbUJBQW1COEgsdUNBQVFBLENBQUM7Z0JBQzFCLElBQUk3RztnQkFDSixNQUFNaEIsU0FBUzNFLE9BQU91TyxNQUFNLENBQUNELDBCQUEwQkUsTUFBTSxDQUMzRCxDQUFDQyxLQUFLQztvQkFDSixPQUFPRCxNQUFNQztnQkFDZixHQUNBO2dCQUVGLE1BQU14RSxRQUFRc0QsZUFBZTdJO2dCQUM3QixNQUFNd0YsYUFBYXFELGNBQWMsSUFBSXpQLE9BQU8sQ0FBQyxDQUFDNEcsU0FBUzZJLGVBQWU3SSxNQUFLLElBQUssR0FBRSxFQUFHNkYsT0FBTyxDQUFDLE1BQU07Z0JBQ2xHN0UsQ0FBQUEsTUFBTTdHLFFBQVE0RixnQkFBZ0IsS0FBSyxPQUFPLEtBQUssSUFBSWlCLElBQUloQyxJQUFJLENBQUM3RSxTQUFTO29CQUFFNkY7b0JBQVF1RjtvQkFBT0M7Z0JBQVc7WUFDcEcsR0FBRztRQUNMO1FBQ0F3RSxPQUFPN1MsS0FBSyxDQUFDOFM7UUFDYixlQUFlRDtZQUNiMUwsTUFDRSwwQkFDQSxrQkFDQTRLLGVBQ0EseUJBQ0EsR0FBa0NoUSxPQUEvQkEsTUFBTW9RLHVCQUFzQixLQUEyQixPQUF4QnBRLE1BQU15UCxvQkFDeEMsY0FDQXpQLE1BQU1zUTtZQUVSTCxVQUFVO1lBQ1YsTUFBT0csdUJBQXVCWCxvQkFBb0IsQ0FBQ1UsU0FBVTtnQkFDM0QsSUFBSTtvQkFDRixNQUFNLEVBQUVoUyxLQUFLLEVBQUU2UyxJQUFJLEVBQUUsR0FBRyxNQUFNbEIsT0FBT2dCLElBQUk7b0JBQ3pDLElBQUlFLE1BQU07d0JBQ1JYLGNBQWM7d0JBQ2RqTCxNQUFNO3dCQUNOLElBQUltTCxhQUFhak0sTUFBTSxHQUFHLEdBQUc7NEJBQzNCc0wsY0FBY3FCLElBQUksQ0FBQztnQ0FDakJqQyxZQUFZa0I7Z0NBQ1pyUyxNQUFNLElBQUlDLEtBQUt5UyxjQUFjO29DQUMzQlcsTUFBTTtnQ0FDUjs0QkFDRjs0QkFDQUM7d0JBQ0Y7d0JBQ0FsQixVQUFVO3dCQUNWO29CQUNGO29CQUNBRyx3QkFBd0JqUyxNQUFNd0YsVUFBVTtvQkFDeEMsSUFBSXlOLGNBQWM7b0JBQ2xCLE1BQU9BLGNBQWNqVCxNQUFNd0YsVUFBVSxDQUFFO3dCQUNyQyxNQUFNME4sb0JBQW9CN0Isa0JBQWtCZ0I7d0JBQzVDLE1BQU1jLFlBQVl6USxLQUFLMFEsR0FBRyxDQUN4QkgsY0FBY0MsbUJBQ2RsVCxNQUFNd0YsVUFBVTt3QkFFbEIsTUFBTVEsUUFBUWhHLE1BQU1xRyxLQUFLLENBQUM0TSxhQUFhRTt3QkFDdkNmLGFBQWFVLElBQUksQ0FBQzlNO3dCQUNsQnFNLHdCQUF3QnJNLE1BQU1SLFVBQVU7d0JBQ3hDeU4sY0FBY0U7d0JBQ2QsSUFBSWQseUJBQXlCaEIsaUJBQWlCOzRCQUM1Q0ksY0FBY3FCLElBQUksQ0FBQztnQ0FDakJqQyxZQUFZa0I7Z0NBQ1pyUyxNQUFNLElBQUlDLEtBQUt5UyxjQUFjO29DQUMzQlcsTUFBTTtnQ0FDUjs0QkFDRjs0QkFDQVgsZUFBZSxFQUFFOzRCQUNqQkMsdUJBQXVCOzRCQUN2Qlc7d0JBQ0Y7b0JBQ0Y7Z0JBQ0YsRUFBRSxPQUFPakwsT0FBTztvQkFDZDZLLE9BQU83SztnQkFDVDtZQUNGO1lBQ0FkLE1BQ0Usd0JBQ0Esa0JBQ0E0SyxlQUNBLHlCQUNBLEdBQWtDaFEsT0FBL0JBLE1BQU1vUSx1QkFBc0IsS0FBMkIsT0FBeEJwUSxNQUFNeVAsb0JBQ3hDLGNBQ0F6UCxNQUFNc1E7WUFFUkwsVUFBVTtRQUNaO1FBQ0EsZUFBZXVCLFNBQVN6QyxJQUFJO1lBQzFCaUI7WUFDQTVLLE1BQ0UsK0JBQ0EsZUFDQTJKLEtBQUtDLFVBQVUsRUFDZixTQUNBRCxLQUFLbFIsSUFBSSxDQUFDK0YsSUFBSSxFQUNkLGtCQUNBb00sZUFDQSx5QkFDQSxHQUFrQ2hRLE9BQS9CQSxNQUFNb1EsdUJBQXNCLEtBQTJCLE9BQXhCcFEsTUFBTXlQLG9CQUN4QyxjQUNBelAsTUFBTXNRO1lBRVIsSUFBSTtnQkFDRixNQUFNbUIsd0JBQXdCeFEsUUFBUTRGLGdCQUFnQixHQUFHLENBQUNjO29CQUN4RDhJLHdCQUF3QixDQUFDMUIsS0FBS0MsVUFBVSxDQUFDLEdBQUdySCxNQUFNYixNQUFNO29CQUN4RCxJQUFJRCxrQkFBa0I7d0JBQ3BCQTtvQkFDRjtnQkFDRixJQUFJLEtBQUs7Z0JBQ1QsTUFBTTZLLGdCQUFnQixNQUFNNUMsV0FBVztvQkFDckNiO29CQUNBeEY7b0JBQ0FwRjtvQkFDQUY7b0JBQ0FsQyxTQUFTO3dCQUNQLEdBQUdBLE9BQU87d0JBQ1Y0RixrQkFBa0I0SztvQkFDcEI7b0JBQ0F2QztvQkFDQUg7Z0JBQ0Y7Z0JBQ0EzSixNQUNFLDZCQUNBLGVBQ0EySixLQUFLQyxVQUFVLEVBQ2YsaUJBQ0FnQixlQUNBLHlCQUNBLEdBQWtDaFEsT0FBL0JBLE1BQU1vUSx1QkFBc0IsS0FBMkIsT0FBeEJwUSxNQUFNeVAsb0JBQ3hDLGNBQ0F6UCxNQUFNc1E7Z0JBRVIsSUFBSUgsVUFBVTtvQkFDWjtnQkFDRjtnQkFDQU4sZUFBZW9CLElBQUksQ0FBQztvQkFDbEJqQyxZQUFZRCxLQUFLQyxVQUFVO29CQUMzQkMsTUFBTXlDLGNBQWN6QyxJQUFJO2dCQUMxQjtnQkFDQW1CLHdCQUF3QnJCLEtBQUtsUixJQUFJLENBQUMrRixJQUFJO2dCQUN0Q29NO2dCQUNBTSxhQUFhdkIsS0FBS2xSLElBQUksQ0FBQytGLElBQUk7Z0JBQzNCLElBQUlnTSxjQUFjdEwsTUFBTSxHQUFHLEdBQUc7b0JBQzVCNk07Z0JBQ0Y7Z0JBQ0EsSUFBSWQsYUFBYTtvQkFDZixJQUFJTCxrQkFBa0IsR0FBRzt3QkFDdkJGLE9BQU82QixXQUFXO3dCQUNsQmpVLFFBQVFtUztvQkFDVjtvQkFDQTtnQkFDRjtnQkFDQSxJQUFJLENBQUNJLFNBQVM7b0JBQ1phLE9BQU83UyxLQUFLLENBQUM4UztnQkFDZjtZQUNGLEVBQUUsT0FBTzdLLE9BQU87Z0JBQ2Q2SyxPQUFPN0s7WUFDVDtRQUNGO1FBQ0EsU0FBU2lMO1lBQ1AsSUFBSWhCLFVBQVU7Z0JBQ1o7WUFDRjtZQUNBL0ssTUFDRSxjQUNBLGlCQUNBNEssZUFDQSxpQkFDQUosY0FBY3RMLE1BQU07WUFFdEIsTUFBTzBMLGdCQUFnQlQsd0JBQXdCSyxjQUFjdEwsTUFBTSxHQUFHLEVBQUc7Z0JBQ3ZFLE1BQU1zTixhQUFhaEMsY0FBY2xILEtBQUs7Z0JBQ3RDLElBQUlrSixZQUFZO29CQUNkLEtBQUtKLFNBQVNJO2dCQUNoQjtZQUNGO1FBQ0Y7UUFDQSxTQUFTYixPQUFPN0ssS0FBSztZQUNuQixJQUFJaUssVUFBVTtnQkFDWjtZQUNGO1lBQ0FBLFdBQVc7WUFDWGpCLHdCQUF3QjlGLEtBQUs7WUFDN0IwRyxPQUFPNkIsV0FBVztZQUNsQixJQUFJekwsaUJBQWlCOEMsYUFBYzlDLENBQUFBLE1BQU16RSxPQUFPLEtBQUsscUJBQXFCeUUsTUFBTXpFLE9BQU8sS0FBSyxjQUFhLEdBQUk7Z0JBQzNHNkYsT0FBTyxJQUFJMkM7WUFDYixPQUFPO2dCQUNMM0MsT0FBT3BCO1lBQ1Q7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxtQ0FBbUM7QUFDbkMsU0FBUzJMLG9DQUFvQyxLQUF5QztRQUF6QyxFQUFFckUsY0FBYyxFQUFFRyxRQUFRLEVBQUVELFdBQVcsRUFBRSxHQUF6QztJQUMzQyxPQUFPLE9BQU9ySyxVQUFVMEs7UUFDdEIsTUFBTTlNLFVBQVUsTUFBTXdNLGlCQUFpQjtZQUNyQ3BLO1lBQ0FwQyxTQUFTOE07WUFDVEw7WUFDQUM7UUFDRjtRQUNBLE1BQU14SyxVQUFVb0ssaUJBQWlCQyxnQkFBZ0J2TTtRQUNqRCxNQUFNd04sZ0NBQWdDLE1BQU1DLHNCQUMxQ3JMLFVBQ0FGLFNBQ0FsQztRQUVGLE9BQU87WUFDTHdILEtBQUtnRyw4QkFBOEJoRyxHQUFHO1lBQ3RDd0YsVUFBVVEsOEJBQThCUixRQUFRO1lBQ2hELE1BQU1hLFlBQVdFLFVBQVUsRUFBRWhNLElBQUk7Z0JBQy9CLElBQUlmLGNBQWNlLE9BQU87b0JBQ3ZCLE1BQU0sSUFBSTFCLFVBQ1I7Z0JBRUo7Z0JBQ0EsTUFBTXVOLFNBQVMsTUFBTUMsV0FBVztvQkFDOUJiLFVBQVVRLDhCQUE4QlIsUUFBUTtvQkFDaER4RixLQUFLZ0csOEJBQThCaEcsR0FBRztvQkFDdENwRjtvQkFDQTBMLE1BQU07d0JBQUVDO3dCQUFZblIsTUFBTW1GO29CQUFLO29CQUMvQkc7b0JBQ0FsQztnQkFDRjtnQkFDQSxPQUFPO29CQUNMZ08sTUFBTUosT0FBT0ksSUFBSTtvQkFDakJEO2dCQUNGO1lBQ0Y7WUFDQSxNQUFNOEMsVUFBU3RKLEtBQUs7Z0JBQ2xCLE9BQU93Rix3QkFBd0I7b0JBQzdCQyxVQUFVUSw4QkFBOEJSLFFBQVE7b0JBQ2hEeEYsS0FBS2dHLDhCQUE4QmhHLEdBQUc7b0JBQ3RDcEY7b0JBQ0FtRjtvQkFDQXJGO29CQUNBbEM7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLGFBQWE7QUFDc0I7QUFFbkMsZ0NBQWdDO0FBQ2hDLGVBQWUrUSw0QkFBNEIzTyxRQUFRLEVBQUVMLElBQUksRUFBRUcsT0FBTyxFQUFFbEMsT0FBTztJQUN6RW1FLE1BQU0sYUFBYSxhQUFhL0IsVUFBVSxZQUFZRjtJQUN0RCxNQUFNOE8saUNBQWlDO1FBQ3JDLEdBQUdoUixPQUFPO1FBQ1Y0RixrQkFBa0IsS0FBSztJQUN6QjtJQUNBLE1BQU00SCxnQ0FBZ0MsTUFBTUMsc0JBQzFDckwsVUFDQUYsU0FDQThPO0lBRUYsTUFBTXRDLGNBQWNqTSxrQkFBa0JWO0lBQ3RDLE1BQU0zRSxTQUFTLE1BQU1ILGlCQUFpQjhFO0lBQ3RDLE1BQU13RixRQUFRLE1BQU1rSCxlQUFlO1FBQ2pDekIsVUFBVVEsOEJBQThCUixRQUFRO1FBQ2hEeEYsS0FBS2dHLDhCQUE4QmhHLEdBQUc7UUFDdENwRjtRQUNBaEY7UUFDQThFO1FBQ0FsQztRQUNBME87SUFDRjtJQUNBLE1BQU05UixPQUFPLE1BQU1tUSx3QkFBd0I7UUFDekNDLFVBQVVRLDhCQUE4QlIsUUFBUTtRQUNoRHhGLEtBQUtnRyw4QkFBOEJoRyxHQUFHO1FBQ3RDcEY7UUFDQW1GO1FBQ0FyRjtRQUNBbEMsU0FBU2dSO0lBQ1g7SUFDQSxPQUFPcFU7QUFDVDtBQUVBLGFBQWE7QUFDYixTQUFTcVUsZ0JBQWdCLEtBSXhCO1FBSndCLEVBQ3ZCMUUsY0FBYyxFQUNkRyxRQUFRLEVBQ1JELFdBQVcsRUFDWixHQUp3QjtJQUt2QixPQUFPLGVBQWV5RSxJQUFJOU8sUUFBUSxFQUFFTCxJQUFJLEVBQUUrSyxZQUFZO1FBQ3BELElBQUksQ0FBQy9LLE1BQU07WUFDVCxNQUFNLElBQUkxQixVQUFVO1FBQ3RCO1FBQ0EsSUFBSVcsY0FBY2UsT0FBTztZQUN2QixNQUFNLElBQUkxQixVQUNSO1FBRUo7UUFDQSxNQUFNTCxVQUFVLE1BQU13TSxpQkFBaUI7WUFDckNwSztZQUNBcEMsU0FBUzhNO1lBQ1RMO1lBQ0FDO1FBQ0Y7UUFDQSxNQUFNeEssVUFBVW9LLGlCQUFpQkMsZ0JBQWdCdk07UUFDakQsSUFBSUEsUUFBUW1SLFNBQVMsS0FBSyxNQUFNO1lBQzlCLE9BQU9KLDRCQUE0QjNPLFVBQVVMLE1BQU1HLFNBQVNsQztRQUM5RDtRQUNBLE1BQU00RixtQkFBbUI1RixRQUFRNEYsZ0JBQWdCLEdBQUdrTCx1Q0FBU0EsQ0FBQzlRLFFBQVE0RixnQkFBZ0IsRUFBRSxPQUFPLEtBQUs7UUFDcEcsTUFBTXFILFNBQVMsSUFBSUMsZ0JBQWdCO1lBQUU5SztRQUFTO1FBQzlDLE1BQU11RixXQUFXLE1BQU0wQyxXQUNyQixLQUF1QixPQUFsQjRDLE9BQU9sTSxRQUFRLEtBQ3BCO1lBQ0VpQixRQUFRO1lBQ1JEO1lBQ0FHO1lBQ0E0RSxRQUFROUcsUUFBUXNOLFdBQVc7UUFDN0IsR0FDQTtZQUNFLEdBQUd0TixPQUFPO1lBQ1Y0RjtRQUNGO1FBRUYsT0FBTztZQUNMakYsS0FBS2dILFNBQVNoSCxHQUFHO1lBQ2pCeVEsYUFBYXpKLFNBQVN5SixXQUFXO1lBQ2pDaFAsVUFBVXVGLFNBQVN2RixRQUFRO1lBQzNCaUssYUFBYTFFLFNBQVMwRSxXQUFXO1lBQ2pDZ0Ysb0JBQW9CMUosU0FBUzBKLGtCQUFrQjtRQUNqRDtJQUNGO0FBQ0Y7QUFFQSx1QkFBdUI7QUFDdkIsZUFBZUMsYUFBYWxQLFFBQVE7UUFBRXBDLFVBQUFBLGlFQUFVLENBQUM7SUFDL0MsTUFBTXVSLGlCQUFpQm5QLFNBQVNvUCxRQUFRLENBQUMsT0FBT3BQLFdBQVcsR0FBWSxPQUFUQSxVQUFTO0lBQ3ZFLE1BQU1GLFVBQVUsQ0FBQztJQUNqQkEsT0FBTyxDQUFDK0osbUJBQW1CRSxlQUFlLENBQUMsR0FBRztJQUM5QyxNQUFNYyxTQUFTLElBQUlDLGdCQUFnQjtRQUFFOUssVUFBVW1QO0lBQWU7SUFDOUQsTUFBTTVKLFdBQVcsTUFBTTBDLFdBQ3JCLEtBQXVCLE9BQWxCNEMsT0FBT2xNLFFBQVEsS0FDcEI7UUFDRWlCLFFBQVE7UUFDUkU7UUFDQTRFLFFBQVE5RyxRQUFRc04sV0FBVztJQUM3QixHQUNBdE47SUFFRixPQUFPO1FBQ0xXLEtBQUtnSCxTQUFTaEgsR0FBRztRQUNqQnlCLFVBQVV1RixTQUFTdkYsUUFBUTtJQUM3QjtBQUNGO0FBMkJFLENBQ0Y7Ozs7O0NBS0MsSUFDRCwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvYmxvYi9kaXN0L2NodW5rLUZONlhGSDZSLmpzPzJhNGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2hlbHBlcnMudHNcbmltcG9ydCB7IGlzTm9kZVByb2Nlc3MgfSBmcm9tIFwiaXMtbm9kZS1wcm9jZXNzXCI7XG5cbi8vIHNyYy9tdWx0aXBhcnQvaGVscGVycy50c1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gXCJpcy1idWZmZXJcIjtcbmltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSBcInN0cmVhbVwiO1xudmFyIHN1cHBvcnRzTmV3QmxvYkZyb21BcnJheUJ1ZmZlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgaGVsbG9Bc0FycmF5QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExXSk7XG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtoZWxsb0FzQXJyYXlCdWZmZXJdKTtcbiAgICBibG9iLnRleHQoKS50aGVuKCh0ZXh0KSA9PiB7XG4gICAgICByZXNvbHZlKHRleHQgPT09IFwiaGVsbG9cIik7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgfSk7XG4gIH0gY2F0Y2gge1xuICAgIHJlc29sdmUoZmFsc2UpO1xuICB9XG59KTtcbmFzeW5jIGZ1bmN0aW9uIHRvUmVhZGFibGVTdHJlYW0odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiB2YWx1ZS5zdHJlYW0oKTtcbiAgfVxuICBpZiAoaXNOb2RlSnNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gUmVhZGFibGUudG9XZWIodmFsdWUpO1xuICB9XG4gIGxldCBzdHJlYW1WYWx1ZTtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBzdHJlYW1WYWx1ZSA9IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc05vZGVKc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICBzdHJlYW1WYWx1ZSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbVZhbHVlID0gc3RyaW5nVG9VaW50OEFycmF5KHZhbHVlKTtcbiAgfVxuICBpZiAoYXdhaXQgc3VwcG9ydHNOZXdCbG9iRnJvbUFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtzdHJlYW1WYWx1ZV0pLnN0cmVhbSgpO1xuICB9XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShzdHJlYW1WYWx1ZSk7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzTm9kZUpzUmVhZGFibGVTdHJlYW0odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUucGlwZSA9PT0gXCJmdW5jdGlvblwiICYmIHZhbHVlLnJlYWRhYmxlICYmIHR5cGVvZiB2YWx1ZS5fcmVhZCA9PT0gXCJmdW5jdGlvblwiICYmIC8vIEB0cy1leHBlY3QtZXJyb3IgX3JlYWRhYmxlU3RhdGUgZG9lcyBleGlzdHMgb24gUmVhZGFibGVcbiAgdHlwZW9mIHZhbHVlLl9yZWFkYWJsZVN0YXRlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9VaW50OEFycmF5KHMpIHtcbiAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHJldHVybiBlbmMuZW5jb2RlKHMpO1xufVxuZnVuY3Rpb24gaXNOb2RlSnNCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIGlzQnVmZmVyKHZhbHVlKTtcbn1cblxuLy8gc3JjL2J5dGVzLnRzXG52YXIgcGFyc2VSZWdFeHAgPSAvXigoLXxcXCspPyhcXGQrKD86XFwuXFxkKyk/KSkgKihrYnxtYnxnYnx0YnxwYikkL2k7XG52YXIgbWFwID0ge1xuICBiOiAxLFxuICBrYjogMSA8PCAxMCxcbiAgbWI6IDEgPDwgMjAsXG4gIGdiOiAxIDw8IDMwLFxuICB0YjogMTAyNCAqKiA0LFxuICBwYjogMTAyNCAqKiA1XG59O1xuZnVuY3Rpb24gYnl0ZXModmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmICFOdW1iZXIuaXNOYU4odmFsKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCByZXN1bHRzID0gcGFyc2VSZWdFeHAuZXhlYyh2YWwpO1xuICBsZXQgZmxvYXRWYWx1ZTtcbiAgbGV0IHVuaXQgPSBcImJcIjtcbiAgaWYgKCFyZXN1bHRzKSB7XG4gICAgZmxvYXRWYWx1ZSA9IHBhcnNlSW50KHZhbCwgMTApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFssIHJlcywgLCAsIHVuaXRNYXRjaF0gPSByZXN1bHRzO1xuICAgIGlmICghcmVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQocmVzKTtcbiAgICBpZiAodW5pdE1hdGNoKSB7XG4gICAgICB1bml0ID0gdW5pdE1hdGNoLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZmxvYXRWYWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gTWF0aC5mbG9vcihtYXBbdW5pdF0gKiBmbG9hdFZhbHVlKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMudHNcbnZhciBkZWZhdWx0VmVyY2VsQmxvYkFwaVVybCA9IFwiaHR0cHM6Ly92ZXJjZWwuY29tL2FwaS9ibG9iXCI7XG5mdW5jdGlvbiBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50b2tlbikge1xuICAgIHJldHVybiBvcHRpb25zLnRva2VuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5CTE9CX1JFQURfV1JJVEVfVE9LRU4pIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuQkxPQl9SRUFEX1dSSVRFX1RPS0VOO1xuICB9XG4gIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgXCJObyB0b2tlbiBmb3VuZC4gRWl0aGVyIGNvbmZpZ3VyZSB0aGUgYEJMT0JfUkVBRF9XUklURV9UT0tFTmAgZW52aXJvbm1lbnQgdmFyaWFibGUsIG9yIHBhc3MgYSBgdG9rZW5gIG9wdGlvbiB0byB5b3VyIGNhbGxzLlwiXG4gICk7XG59XG52YXIgQmxvYkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihgVmVyY2VsIEJsb2I6ICR7bWVzc2FnZX1gKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldERvd25sb2FkVXJsKGJsb2JVcmwpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChibG9iVXJsKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJkb3dubG9hZFwiLCBcIjFcIik7XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSk7XG59XG52YXIgZGlzYWxsb3dlZFBhdGhuYW1lQ2hhcmFjdGVycyA9IFtcIi8vXCJdO1xudmFyIHN1cHBvcnRzUmVxdWVzdFN0cmVhbXMgPSAoKCkgPT4ge1xuICBpZiAoaXNOb2RlUHJvY2VzcygpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYXBpVXJsID0gZ2V0QXBpVXJsKCk7XG4gIGlmIChhcGlVcmwuc3RhcnRzV2l0aChcImh0dHA6Ly9sb2NhbGhvc3RcIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGR1cGxleEFjY2Vzc2VkID0gZmFsc2U7XG4gIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gbmV3IFJlcXVlc3QoZ2V0QXBpVXJsKCksIHtcbiAgICBib2R5OiBuZXcgUmVhZGFibGVTdHJlYW0oKSxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gVHlwZVNjcmlwdCBkb2Vzbid0IHlldCBoYXZlIGR1cGxleCBidXQgaXQncyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0LURPTS1saWItZ2VuZXJhdG9yL3B1bGwvMTcyOVxuICAgIGdldCBkdXBsZXgoKSB7XG4gICAgICBkdXBsZXhBY2Nlc3NlZCA9IHRydWU7XG4gICAgICByZXR1cm4gXCJoYWxmXCI7XG4gICAgfVxuICB9KS5oZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKTtcbiAgcmV0dXJuIGR1cGxleEFjY2Vzc2VkICYmICFoYXNDb250ZW50VHlwZTtcbn0pKCk7XG5mdW5jdGlvbiBnZXRBcGlVcmwocGF0aG5hbWUgPSBcIlwiKSB7XG4gIGxldCBiYXNlVXJsID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBiYXNlVXJsID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfQVBJX1VSTCB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVVJMO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gYCR7YmFzZVVybCB8fCBkZWZhdWx0VmVyY2VsQmxvYkFwaVVybH0ke3BhdGhuYW1lfWA7XG59XG52YXIgVEVYVF9FTkNPREVSID0gdHlwZW9mIFRleHRFbmNvZGVyID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgVGV4dEVuY29kZXIoKSA6IG51bGw7XG5mdW5jdGlvbiBjb21wdXRlQm9keUxlbmd0aChib2R5KSB7XG4gIGlmICghYm9keSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChURVhUX0VOQ09ERVIpIHtcbiAgICAgIHJldHVybiBURVhUX0VOQ09ERVIuZW5jb2RlKGJvZHkpLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQmxvYihbYm9keV0pLnNpemU7XG4gIH1cbiAgaWYgKFwiYnl0ZUxlbmd0aFwiIGluIGJvZHkgJiYgdHlwZW9mIGJvZHkuYnl0ZUxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGg7XG4gIH1cbiAgaWYgKFwic2l6ZVwiIGluIGJvZHkgJiYgdHlwZW9mIGJvZHkuc2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBib2R5LnNpemU7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgY3JlYXRlQ2h1bmtUcmFuc2Zvcm1TdHJlYW0gPSAoY2h1bmtTaXplLCBvblByb2dyZXNzKSA9PiB7XG4gIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIubGVuZ3RoICsgY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIG5ld0J1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgbmV3QnVmZmVyLnNldChuZXcgVWludDhBcnJheShjaHVuayksIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICBidWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoID49IGNodW5rU2l6ZSkge1xuICAgICAgICAgIGNvbnN0IG5ld0NodW5rID0gYnVmZmVyLnNsaWNlKDAsIGNodW5rU2l6ZSk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ld0NodW5rKTtcbiAgICAgICAgICBvblByb2dyZXNzID09IG51bGwgPyB2b2lkIDAgOiBvblByb2dyZXNzKG5ld0NodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShjaHVua1NpemUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICAgICAgb25Qcm9ncmVzcyA9PSBudWxsID8gdm9pZCAwIDogb25Qcm9ncmVzcyhidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSAmJiAvLyBUT0RPOiBDYW4gYmUgcmVtb3ZlZCBvbmNlIE5vZGUuanMgMTYgaXMgbm8gbW9yZSByZXF1aXJlZCBpbnRlcm5hbGx5XG4gIHZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG59XG5mdW5jdGlvbiBpc1N0cmVhbSh2YWx1ZSkge1xuICBpZiAoaXNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNOb2RlSnNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9hcGkudHNcbmltcG9ydCByZXRyeSBmcm9tIFwiYXN5bmMtcmV0cnlcIjtcblxuLy8gc3JjL2RlYnVnLnRzXG52YXIgZGVidWdJc0FjdGl2ZSA9IGZhbHNlO1xudmFyIF9hLCBfYjtcbnRyeSB7XG4gIGlmICgoKF9hID0gcHJvY2Vzcy5lbnYuREVCVUcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhcImJsb2JcIikpIHx8ICgoX2IgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19ERUJVRykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwiYmxvYlwiKSkpIHtcbiAgICBkZWJ1Z0lzQWN0aXZlID0gdHJ1ZTtcbiAgfVxufSBjYXRjaCB7XG59XG5mdW5jdGlvbiBkZWJ1ZyhtZXNzYWdlLCAuLi5hcmdzKSB7XG4gIGlmIChkZWJ1Z0lzQWN0aXZlKSB7XG4gICAgY29uc29sZS5kZWJ1ZyhgdmVyY2VsLWJsb2I6ICR7bWVzc2FnZX1gLCAuLi5hcmdzKTtcbiAgfVxufVxuXG4vLyBzcmMvZG9tLWV4Y2VwdGlvbi50c1xudmFyIF9hMjtcbnZhciBET01FeGNlcHRpb24yID0gKF9hMiA9IGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uKSAhPSBudWxsID8gX2EyIDogKCgpID0+IHtcbiAgdHJ5IHtcbiAgICBhdG9iKFwiflwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihlcnIpLmNvbnN0cnVjdG9yO1xuICB9XG59KSgpO1xuXG4vLyBzcmMvaXMtbmV0d29yay1lcnJvci50c1xudmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0Vycm9yID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IEVycm9yXVwiO1xudmFyIGVycm9yTWVzc2FnZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwibmV0d29yayBlcnJvclwiLFxuICAvLyBDaHJvbWVcbiAgXCJGYWlsZWQgdG8gZmV0Y2hcIixcbiAgLy8gQ2hyb21lXG4gIFwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS5cIixcbiAgLy8gRmlyZWZveFxuICBcIlRoZSBJbnRlcm5ldCBjb25uZWN0aW9uIGFwcGVhcnMgdG8gYmUgb2ZmbGluZS5cIixcbiAgLy8gU2FmYXJpIDE2XG4gIFwiTG9hZCBmYWlsZWRcIixcbiAgLy8gU2FmYXJpIDE3K1xuICBcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWRcIixcbiAgLy8gYGNyb3NzLWZldGNoYFxuICBcImZldGNoIGZhaWxlZFwiLFxuICAvLyBVbmRpY2kgKE5vZGUuanMpXG4gIFwidGVybWluYXRlZFwiXG4gIC8vIFVuZGljaSAoTm9kZS5qcylcbl0pO1xuZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IoZXJyb3IpIHtcbiAgY29uc3QgaXNWYWxpZCA9IGVycm9yICYmIGlzRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09IFwiVHlwZUVycm9yXCIgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09IFwic3RyaW5nXCI7XG4gIGlmICghaXNWYWxpZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gXCJMb2FkIGZhaWxlZFwiKSB7XG4gICAgcmV0dXJuIGVycm9yLnN0YWNrID09PSB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGVycm9yTWVzc2FnZXMuaGFzKGVycm9yLm1lc3NhZ2UpO1xufVxuXG4vLyBzcmMvZmV0Y2gudHNcbmltcG9ydCB7IGZldGNoIH0gZnJvbSBcInVuZGljaVwiO1xudmFyIGhhc0ZldGNoID0gdHlwZW9mIGZldGNoID09PSBcImZ1bmN0aW9uXCI7XG52YXIgaGFzRmV0Y2hXaXRoVXBsb2FkUHJvZ3Jlc3MgPSBoYXNGZXRjaCAmJiBzdXBwb3J0c1JlcXVlc3RTdHJlYW1zO1xudmFyIENIVU5LX1NJWkUgPSA2NCAqIDEwMjQ7XG52YXIgYmxvYkZldGNoID0gYXN5bmMgKHtcbiAgaW5wdXQsXG4gIGluaXQsXG4gIG9uVXBsb2FkUHJvZ3Jlc3Ncbn0pID0+IHtcbiAgZGVidWcoXCJ1c2luZyBmZXRjaFwiKTtcbiAgbGV0IGJvZHk7XG4gIGlmIChpbml0LmJvZHkpIHtcbiAgICBpZiAob25VcGxvYWRQcm9ncmVzcykge1xuICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdG9SZWFkYWJsZVN0cmVhbShpbml0LmJvZHkpO1xuICAgICAgbGV0IGxvYWRlZCA9IDA7XG4gICAgICBjb25zdCBjaHVua1RyYW5zZm9ybVN0cmVhbSA9IGNyZWF0ZUNodW5rVHJhbnNmb3JtU3RyZWFtKFxuICAgICAgICBDSFVOS19TSVpFLFxuICAgICAgICAobmV3TG9hZGVkKSA9PiB7XG4gICAgICAgICAgbG9hZGVkICs9IG5ld0xvYWRlZDtcbiAgICAgICAgICBvblVwbG9hZFByb2dyZXNzKGxvYWRlZCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBib2R5ID0gc3RyZWFtLnBpcGVUaHJvdWdoKGNodW5rVHJhbnNmb3JtU3RyZWFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keSA9IGluaXQuYm9keTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZHVwbGV4ID0gc3VwcG9ydHNSZXF1ZXN0U3RyZWFtcyAmJiBib2R5ICYmIGlzU3RyZWFtKGJvZHkpID8gXCJoYWxmXCIgOiB2b2lkIDA7XG4gIHJldHVybiBmZXRjaChcbiAgICBpbnB1dCxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIEJsb2IgYW5kIE5vZGVqcyBCbG9iIGFyZSB0cmlnZ2VyaW5nIHR5cGUgZXJyb3JzLCBmaW5lIHdpdGggaXRcbiAgICB7XG4gICAgICAuLi5pbml0LFxuICAgICAgLi4uaW5pdC5ib2R5ID8geyBib2R5IH0gOiB7fSxcbiAgICAgIGR1cGxleFxuICAgIH1cbiAgKTtcbn07XG5cbi8vIHNyYy94aHIudHNcbnZhciBoYXNYaHIgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgYmxvYlhociA9IGFzeW5jICh7XG4gIGlucHV0LFxuICBpbml0LFxuICBvblVwbG9hZFByb2dyZXNzXG59KSA9PiB7XG4gIGRlYnVnKFwidXNpbmcgeGhyXCIpO1xuICBsZXQgYm9keSA9IG51bGw7XG4gIGlmIChpbml0LmJvZHkpIHtcbiAgICBpZiAoaXNSZWFkYWJsZVN0cmVhbShpbml0LmJvZHkpKSB7XG4gICAgICBib2R5ID0gYXdhaXQgbmV3IFJlc3BvbnNlKGluaXQuYm9keSkuYmxvYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0gaW5pdC5ib2R5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKGluaXQubWV0aG9kIHx8IFwiR0VUXCIsIGlucHV0LnRvU3RyaW5nKCksIHRydWUpO1xuICAgIGlmIChvblVwbG9hZFByb2dyZXNzKSB7XG4gICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICBvblVwbG9hZFByb2dyZXNzKGV2ZW50LmxvYWRlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgICAgdmFyIF9hMztcbiAgICAgIGlmICgoX2EzID0gaW5pdC5zaWduYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuYWJvcnRlZCkge1xuICAgICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbihcIlRoZSB1c2VyIGFib3J0ZWQgdGhlIHJlcXVlc3QuXCIsIFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgY29uc3QgcmF3SGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS50cmltKCkuc3BsaXQoL1tcXHJcXG5dKy8pO1xuICAgICAgcmF3SGVhZGVycy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdChcIjogXCIpO1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnRzLmpvaW4oXCI6IFwiKTtcbiAgICAgICAgaWYgKGtleSkgaGVhZGVycy5zZXQoa2V5LnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoeGhyLnJlc3BvbnNlLCB7XG4gICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKFwiTmV0d29yayByZXF1ZXN0IGZhaWxlZFwiKSk7XG4gICAgfTtcbiAgICB4aHIub250aW1lb3V0ID0gKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJOZXR3b3JrIHJlcXVlc3QgdGltZWQgb3V0XCIpKTtcbiAgICB9O1xuICAgIHhoci5vbmFib3J0ID0gKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBET01FeGNlcHRpb24oXCJUaGUgdXNlciBhYm9ydGVkIGEgcmVxdWVzdC5cIiwgXCJBYm9ydEVycm9yXCIpKTtcbiAgICB9O1xuICAgIGlmIChpbml0LmhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMpO1xuICAgICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbml0LnNpZ25hbCkge1xuICAgICAgaW5pdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbml0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHhoci5zZW5kKGJvZHkpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9yZXF1ZXN0LnRzXG52YXIgYmxvYlJlcXVlc3QgPSBhc3luYyAoe1xuICBpbnB1dCxcbiAgaW5pdCxcbiAgb25VcGxvYWRQcm9ncmVzc1xufSkgPT4ge1xuICBpZiAob25VcGxvYWRQcm9ncmVzcykge1xuICAgIGlmIChoYXNGZXRjaFdpdGhVcGxvYWRQcm9ncmVzcykge1xuICAgICAgcmV0dXJuIGJsb2JGZXRjaCh7IGlucHV0LCBpbml0LCBvblVwbG9hZFByb2dyZXNzIH0pO1xuICAgIH1cbiAgICBpZiAoaGFzWGhyKSB7XG4gICAgICByZXR1cm4gYmxvYlhocih7IGlucHV0LCBpbml0LCBvblVwbG9hZFByb2dyZXNzIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzRmV0Y2gpIHtcbiAgICByZXR1cm4gYmxvYkZldGNoKHsgaW5wdXQsIGluaXQgfSk7XG4gIH1cbiAgaWYgKGhhc1hocikge1xuICAgIHJldHVybiBibG9iWGhyKHsgaW5wdXQsIGluaXQgfSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVxdWVzdCBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGVcIik7XG59O1xuXG4vLyBzcmMvYXBpLnRzXG52YXIgTUFYSU1VTV9QQVRITkFNRV9MRU5HVEggPSA5NTA7XG52YXIgQmxvYkFjY2Vzc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkFjY2VzcyBkZW5pZWQsIHBsZWFzZSBwcm92aWRlIGEgdmFsaWQgdG9rZW4gZm9yIHRoaXMgcmVzb3VyY2UuXCIpO1xuICB9XG59O1xudmFyIEJsb2JDb250ZW50VHlwZU5vdEFsbG93ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKGBDb250ZW50IHR5cGUgbWlzbWF0Y2gsICR7bWVzc2FnZX0uYCk7XG4gIH1cbn07XG52YXIgQmxvYlBhdGhuYW1lTWlzbWF0Y2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKFxuICAgICAgYFBhdGhuYW1lIG1pc21hdGNoLCAke21lc3NhZ2V9LiBDaGVjayB0aGUgcGF0aG5hbWUgdXNlZCBpbiB1cGxvYWQoKSBvciBwdXQoKSBtYXRjaGVzIHRoZSBvbmUgZnJvbSB0aGUgY2xpZW50IHRva2VuLmBcbiAgICApO1xuICB9XG59O1xudmFyIEJsb2JDbGllbnRUb2tlbkV4cGlyZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJDbGllbnQgdG9rZW4gaGFzIGV4cGlyZWQuXCIpO1xuICB9XG59O1xudmFyIEJsb2JGaWxlVG9vTGFyZ2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKGBGaWxlIGlzIHRvbyBsYXJnZSwgJHttZXNzYWdlfS5gKTtcbiAgfVxufTtcbnZhciBCbG9iU3RvcmVOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoaXMgc3RvcmUgZG9lcyBub3QgZXhpc3QuXCIpO1xuICB9XG59O1xudmFyIEJsb2JTdG9yZVN1c3BlbmRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoaXMgc3RvcmUgaGFzIGJlZW4gc3VzcGVuZGVkLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iVW5rbm93bkVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlVua25vd24gZXJyb3IsIHBsZWFzZSB2aXNpdCBodHRwczovL3ZlcmNlbC5jb20vaGVscC5cIik7XG4gIH1cbn07XG52YXIgQmxvYk5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhlIHJlcXVlc3RlZCBibG9iIGRvZXMgbm90IGV4aXN0XCIpO1xuICB9XG59O1xudmFyIEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoZSBibG9iIHNlcnZpY2UgaXMgY3VycmVudGx5IG5vdCBhdmFpbGFibGUuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICB9XG59O1xudmFyIEJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNlY29uZHMpIHtcbiAgICBzdXBlcihcbiAgICAgIGBUb28gbWFueSByZXF1ZXN0cyBwbGVhc2UgbG93ZXIgdGhlIG51bWJlciBvZiBjb25jdXJyZW50IHJlcXVlc3RzICR7c2Vjb25kcyA/IGAgLSB0cnkgYWdhaW4gaW4gJHtzZWNvbmRzfSBzZWNvbmRzYCA6IFwiXCJ9LmBcbiAgICApO1xuICAgIHRoaXMucmV0cnlBZnRlciA9IHNlY29uZHMgIT0gbnVsbCA/IHNlY29uZHMgOiAwO1xuICB9XG59O1xudmFyIEJsb2JSZXF1ZXN0QWJvcnRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkLlwiKTtcbiAgfVxufTtcbnZhciBCTE9CX0FQSV9WRVJTSU9OID0gMTE7XG5mdW5jdGlvbiBnZXRBcGlWZXJzaW9uKCkge1xuICBsZXQgdmVyc2lvbk92ZXJyaWRlID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2ZXJzaW9uT3ZlcnJpZGUgPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9BUElfVkVSU0lPTl9PVkVSUklERSB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVkVSU0lPTl9PVkVSUklERTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGAke3ZlcnNpb25PdmVycmlkZSAhPSBudWxsID8gdmVyc2lvbk92ZXJyaWRlIDogQkxPQl9BUElfVkVSU0lPTn1gO1xufVxuZnVuY3Rpb24gZ2V0UmV0cmllcygpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXRyaWVzID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfUkVUUklFUyB8fCBcIjEwXCI7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJldHJpZXMsIDEwKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIDEwO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9iU2VydmljZVJhdGVMaW1pdGVkKHJlc3BvbnNlKSB7XG4gIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcInJldHJ5LWFmdGVyXCIpO1xuICByZXR1cm4gbmV3IEJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQoXG4gICAgcmV0cnlBZnRlciA/IHBhcnNlSW50KHJldHJ5QWZ0ZXIsIDEwKSA6IHZvaWQgMFxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QmxvYkVycm9yKHJlc3BvbnNlKSB7XG4gIHZhciBfYTMsIF9iMiwgX2M7XG4gIGxldCBjb2RlO1xuICBsZXQgbWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvZGUgPSAoX2IyID0gKF9hMyA9IGRhdGEuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY29kZSkgIT0gbnVsbCA/IF9iMiA6IFwidW5rbm93bl9lcnJvclwiO1xuICAgIG1lc3NhZ2UgPSAoX2MgPSBkYXRhLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MubWVzc2FnZTtcbiAgfSBjYXRjaCB7XG4gICAgY29kZSA9IFwidW5rbm93bl9lcnJvclwiO1xuICB9XG4gIGlmICgobWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbWVzc2FnZS5pbmNsdWRlcyhcImNvbnRlbnRUeXBlXCIpKSAmJiBtZXNzYWdlLmluY2x1ZGVzKFwiaXMgbm90IGFsbG93ZWRcIikpIHtcbiAgICBjb2RlID0gXCJjb250ZW50X3R5cGVfbm90X2FsbG93ZWRcIjtcbiAgfVxuICBpZiAoKG1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2UuaW5jbHVkZXMoJ1wicGF0aG5hbWVcIicpKSAmJiBtZXNzYWdlLmluY2x1ZGVzKFwiZG9lcyBub3QgbWF0Y2ggdGhlIHRva2VuIHBheWxvYWRcIikpIHtcbiAgICBjb2RlID0gXCJjbGllbnRfdG9rZW5fcGF0aG5hbWVfbWlzbWF0Y2hcIjtcbiAgfVxuICBpZiAobWVzc2FnZSA9PT0gXCJUb2tlbiBleHBpcmVkXCIpIHtcbiAgICBjb2RlID0gXCJjbGllbnRfdG9rZW5fZXhwaXJlZFwiO1xuICB9XG4gIGlmIChtZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlLmluY2x1ZGVzKFwidGhlIGZpbGUgbGVuZ3RoIGNhbm5vdCBiZSBncmVhdGVyIHRoYW5cIikpIHtcbiAgICBjb2RlID0gXCJmaWxlX3Rvb19sYXJnZVwiO1xuICB9XG4gIGxldCBlcnJvcjtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSBcInN0b3JlX3N1c3BlbmRlZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmb3JiaWRkZW5cIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JBY2Nlc3NFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvbnRlbnRfdHlwZV9ub3RfYWxsb3dlZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkNvbnRlbnRUeXBlTm90QWxsb3dlZEVycm9yKG1lc3NhZ2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNsaWVudF90b2tlbl9wYXRobmFtZV9taXNtYXRjaFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlBhdGhuYW1lTWlzbWF0Y2hFcnJvcihtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjbGllbnRfdG9rZW5fZXhwaXJlZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkNsaWVudFRva2VuRXhwaXJlZEVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZmlsZV90b29fbGFyZ2VcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JGaWxlVG9vTGFyZ2VFcnJvcihtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub3RfZm91bmRcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JOb3RGb3VuZEVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic3RvcmVfbm90X2ZvdW5kXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iU3RvcmVOb3RGb3VuZEVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYmFkX3JlcXVlc3RcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JFcnJvcihtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlIDogXCJCYWQgcmVxdWVzdFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzZXJ2aWNlX3VuYXZhaWxhYmxlXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJhdGVfbGltaXRlZFwiOlxuICAgICAgZXJyb3IgPSBjcmVhdGVCbG9iU2VydmljZVJhdGVMaW1pdGVkKHJlc3BvbnNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ1bmtub3duX2Vycm9yXCI6XG4gICAgY2FzZSBcIm5vdF9hbGxvd2VkXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JVbmtub3duRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7IGNvZGUsIGVycm9yIH07XG59XG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0QXBpKHBhdGhuYW1lLCBpbml0LCBjb21tYW5kT3B0aW9ucykge1xuICBjb25zdCBhcGlWZXJzaW9uID0gZ2V0QXBpVmVyc2lvbigpO1xuICBjb25zdCB0b2tlbiA9IGdldFRva2VuRnJvbU9wdGlvbnNPckVudihjb21tYW5kT3B0aW9ucyk7XG4gIGNvbnN0IGV4dHJhSGVhZGVycyA9IGdldFByb3h5VGhyb3VnaEFsdGVybmF0aXZlQXBpSGVhZGVyRnJvbUVudigpO1xuICBjb25zdCBbLCAsICwgc3RvcmVJZCA9IFwiXCJdID0gdG9rZW4uc3BsaXQoXCJfXCIpO1xuICBjb25zdCByZXF1ZXN0SWQgPSBgJHtzdG9yZUlkfToke0RhdGUubm93KCl9OiR7TWF0aC5yYW5kb20oKS50b1N0cmluZygxNikuc2xpY2UoMil9YDtcbiAgbGV0IHJldHJ5Q291bnQgPSAwO1xuICBsZXQgYm9keUxlbmd0aCA9IDA7XG4gIGxldCB0b3RhbExvYWRlZCA9IDA7XG4gIGNvbnN0IHNlbmRCb2R5TGVuZ3RoID0gKGNvbW1hbmRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSB8fCBzaG91bGRVc2VYQ29udGVudExlbmd0aCgpO1xuICBpZiAoaW5pdC5ib2R5ICYmIC8vIDEuIEZvciB1cGxvYWQgcHJvZ3Jlc3Mgd2UgYWx3YXlzIG5lZWQgdG8ga25vdyB0aGUgdG90YWwgc2l6ZSBvZiB0aGUgYm9keVxuICAvLyAyLiBJbiBkZXZlbG9wbWVudCB3ZSBuZWVkIHRoZSBoZWFkZXIgZm9yIHB1dCgpIHRvIHdvcmsgY29ycmVjdGx5IHdoZW4gcGFzc2luZyBhIHN0cmVhbVxuICBzZW5kQm9keUxlbmd0aCkge1xuICAgIGJvZHlMZW5ndGggPSBjb21wdXRlQm9keUxlbmd0aChpbml0LmJvZHkpO1xuICB9XG4gIGlmIChjb21tYW5kT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykge1xuICAgIGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3Moe1xuICAgICAgbG9hZGVkOiAwLFxuICAgICAgdG90YWw6IGJvZHlMZW5ndGgsXG4gICAgICBwZXJjZW50YWdlOiAwXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYXBpUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICBhc3luYyAoYmFpbCkgPT4ge1xuICAgICAgbGV0IHJlcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IGJsb2JSZXF1ZXN0KHtcbiAgICAgICAgICBpbnB1dDogZ2V0QXBpVXJsKHBhdGhuYW1lKSxcbiAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIngtYXBpLWJsb2ItcmVxdWVzdC1pZFwiOiByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIFwieC1hcGktYmxvYi1yZXF1ZXN0LWF0dGVtcHRcIjogU3RyaW5nKHJldHJ5Q291bnQpLFxuICAgICAgICAgICAgICBcIngtYXBpLXZlcnNpb25cIjogYXBpVmVyc2lvbixcbiAgICAgICAgICAgICAgLi4uc2VuZEJvZHlMZW5ndGggPyB7IFwieC1jb250ZW50LWxlbmd0aFwiOiBTdHJpbmcoYm9keUxlbmd0aCkgfSA6IHt9LFxuICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICAgLi4uZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAuLi5pbml0LmhlYWRlcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IChjb21tYW5kT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykgPyAobG9hZGVkKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSBib2R5TGVuZ3RoICE9PSAwID8gYm9keUxlbmd0aCA6IGxvYWRlZDtcbiAgICAgICAgICAgIHRvdGFsTG9hZGVkID0gbG9hZGVkO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGJvZHlMZW5ndGggPiAwID8gTnVtYmVyKChsb2FkZWQgLyB0b3RhbCAqIDEwMCkudG9GaXhlZCgyKSkgOiAwO1xuICAgICAgICAgICAgaWYgKHBlcmNlbnRhZ2UgPT09IDEwMCAmJiBib2R5TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2EzID0gY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKGNvbW1hbmRPcHRpb25zLCB7XG4gICAgICAgICAgICAgIGxvYWRlZCxcbiAgICAgICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGEgc3RyZWFtIHRvIHB1dCgpLCB3ZSBoYXZlIG5vIHdheSB0byBrbm93IHRoZSB0b3RhbCBzaXplIG9mIHRoZSBib2R5LlxuICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGRlZmluaW5nIHRvdGFsIGFzIHRvdGFsPzogbnVtYmVyIHdlIGRlY2lkZWQgdG8gc2V0IHRoZSB0b3RhbCB0byB0aGUgY3VycmVudGx5XG4gICAgICAgICAgICAgIC8vIGxvYWRlZCBudW1iZXIuIFRoaXMgaXMgbm90IGluYWNjdXJhdGUgYW5kIHdheSBtb3JlIHByYWN0aWNhbCBmb3IgRFguXG4gICAgICAgICAgICAgIC8vIFBhc3NpbmcgZG93biBhIHN0cmVhbSB0byBwdXQoKSBpcyB2ZXJ5IHJhcmVcbiAgICAgICAgICAgICAgdG90YWwsXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbjIgJiYgZXJyb3IyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgYmFpbChuZXcgQmxvYlJlcXVlc3RBYm9ydGVkRXJyb3IoKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldHdvcmtFcnJvcihlcnJvcjIpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICBiYWlsKGVycm9yMik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29kZSwgZXJyb3IgfSA9IGF3YWl0IGdldEJsb2JFcnJvcihyZXMpO1xuICAgICAgaWYgKGNvZGUgPT09IFwidW5rbm93bl9lcnJvclwiIHx8IGNvZGUgPT09IFwic2VydmljZV91bmF2YWlsYWJsZVwiIHx8IGNvZGUgPT09IFwiaW50ZXJuYWxfc2VydmVyX2Vycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBiYWlsKGVycm9yKTtcbiAgICB9LFxuICAgIHtcbiAgICAgIHJldHJpZXM6IGdldFJldHJpZXMoKSxcbiAgICAgIG9uUmV0cnk6IChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGRlYnVnKGByZXRyeWluZyBBUEkgcmVxdWVzdCB0byAke3BhdGhuYW1lfWAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHJ5Q291bnQgPSByZXRyeUNvdW50ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGlmICghYXBpUmVzcG9uc2UpIHtcbiAgICB0aHJvdyBuZXcgQmxvYlVua25vd25FcnJvcigpO1xuICB9XG4gIGlmIChjb21tYW5kT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykge1xuICAgIGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3Moe1xuICAgICAgbG9hZGVkOiB0b3RhbExvYWRlZCxcbiAgICAgIHRvdGFsOiB0b3RhbExvYWRlZCxcbiAgICAgIHBlcmNlbnRhZ2U6IDEwMFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhd2FpdCBhcGlSZXNwb25zZS5qc29uKCk7XG59XG5mdW5jdGlvbiBnZXRQcm94eVRocm91Z2hBbHRlcm5hdGl2ZUFwaUhlYWRlckZyb21FbnYoKSB7XG4gIGNvbnN0IGV4dHJhSGVhZGVycyA9IHt9O1xuICB0cnkge1xuICAgIGlmIChcIlZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJXCIgaW4gcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfUFJPWFlfVEhST1VHSF9BTFRFUk5BVElWRV9BUEkgIT09IHZvaWQgMCkge1xuICAgICAgZXh0cmFIZWFkZXJzW1wieC1wcm94eS10aHJvdWdoLWFsdGVybmF0aXZlLWFwaVwiXSA9IHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJO1xuICAgIH0gZWxzZSBpZiAoXCJORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSVwiIGluIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJICE9PSB2b2lkIDApIHtcbiAgICAgIGV4dHJhSGVhZGVyc1tcIngtcHJveHktdGhyb3VnaC1hbHRlcm5hdGl2ZS1hcGlcIl0gPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBleHRyYUhlYWRlcnM7XG59XG5mdW5jdGlvbiBzaG91bGRVc2VYQ29udGVudExlbmd0aCgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfVVNFX1hfQ09OVEVOVF9MRU5HVEggPT09IFwiMVwiO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gc3JjL3B1dC1oZWxwZXJzLnRzXG52YXIgcHV0T3B0aW9uSGVhZGVyTWFwID0ge1xuICBjYWNoZUNvbnRyb2xNYXhBZ2U6IFwieC1jYWNoZS1jb250cm9sLW1heC1hZ2VcIixcbiAgYWRkUmFuZG9tU3VmZml4OiBcIngtYWRkLXJhbmRvbS1zdWZmaXhcIixcbiAgYWxsb3dPdmVyd3JpdGU6IFwieC1hbGxvdy1vdmVyd3JpdGVcIixcbiAgY29udGVudFR5cGU6IFwieC1jb250ZW50LXR5cGVcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJjb250ZW50VHlwZVwiKSAmJiBvcHRpb25zLmNvbnRlbnRUeXBlKSB7XG4gICAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuY29udGVudFR5cGVdID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgfVxuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJhZGRSYW5kb21TdWZmaXhcIikgJiYgb3B0aW9ucy5hZGRSYW5kb21TdWZmaXggIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmFkZFJhbmRvbVN1ZmZpeF0gPSBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCA/IFwiMVwiIDogXCIwXCI7XG4gIH1cbiAgaWYgKGFsbG93ZWRPcHRpb25zLmluY2x1ZGVzKFwiYWxsb3dPdmVyd3JpdGVcIikgJiYgb3B0aW9ucy5hbGxvd092ZXJ3cml0ZSAhPT0gdm9pZCAwKSB7XG4gICAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuYWxsb3dPdmVyd3JpdGVdID0gb3B0aW9ucy5hbGxvd092ZXJ3cml0ZSA/IFwiMVwiIDogXCIwXCI7XG4gIH1cbiAgaWYgKGFsbG93ZWRPcHRpb25zLmluY2x1ZGVzKFwiY2FjaGVDb250cm9sTWF4QWdlXCIpICYmIG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5jYWNoZUNvbnRyb2xNYXhBZ2VdID0gb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVB1dE9wdGlvbnMoe1xuICBwYXRobmFtZSxcbiAgb3B0aW9ucyxcbiAgZXh0cmFDaGVja3MsXG4gIGdldFRva2VuXG59KSB7XG4gIGlmICghcGF0aG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwicGF0aG5hbWUgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgaWYgKHBhdGhuYW1lLmxlbmd0aCA+IE1BWElNVU1fUEFUSE5BTUVfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgIGBwYXRobmFtZSBpcyB0b28gbG9uZywgbWF4aW11bSBsZW5ndGggaXMgJHtNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSH1gXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IGludmFsaWRDaGFyYWN0ZXIgb2YgZGlzYWxsb3dlZFBhdGhuYW1lQ2hhcmFjdGVycykge1xuICAgIGlmIChwYXRobmFtZS5pbmNsdWRlcyhpbnZhbGlkQ2hhcmFjdGVyKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgYHBhdGhuYW1lIGNhbm5vdCBjb250YWluIFwiJHtpbnZhbGlkQ2hhcmFjdGVyfVwiLCBwbGVhc2UgZW5jb2RlIGl0IGlmIG5lZWRlZGBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJtaXNzaW5nIG9wdGlvbnMsIHNlZSB1c2FnZVwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5hY2Nlc3MgIT09IFwicHVibGljXCIpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKCdhY2Nlc3MgbXVzdCBiZSBcInB1YmxpY1wiJyk7XG4gIH1cbiAgaWYgKGV4dHJhQ2hlY2tzKSB7XG4gICAgZXh0cmFDaGVja3Mob3B0aW9ucyk7XG4gIH1cbiAgaWYgKGdldFRva2VuKSB7XG4gICAgb3B0aW9ucy50b2tlbiA9IGF3YWl0IGdldFRva2VuKHBhdGhuYW1lLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLy8gc3JjL211bHRpcGFydC9jb21wbGV0ZS50c1xuZnVuY3Rpb24gY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgcGFydHMsIG9wdGlvbnNJbnB1dCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICAgICAgdXBsb2FkSWQ6IG9wdGlvbnMudXBsb2FkSWQsXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHBhcnRzXG4gICAgfSk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gIHVwbG9hZElkLFxuICBrZXksXG4gIHBhdGhuYW1lLFxuICBwYXJ0cyxcbiAgaGVhZGVycyxcbiAgb3B0aW9uc1xufSkge1xuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgcGF0aG5hbWUgfSk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgICAgYC9tcHU/JHtwYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICBcIngtbXB1LWFjdGlvblwiOiBcImNvbXBsZXRlXCIsXG4gICAgICAgICAgXCJ4LW1wdS11cGxvYWQtaWRcIjogdXBsb2FkSWQsXG4gICAgICAgICAgLy8ga2V5IGNhbiBiZSBhbnkgdXRmOCBjaGFyYWN0ZXIgc28gd2UgbmVlZCB0byBlbmNvZGUgaXQgYXMgSFRUUCBoZWFkZXJzIGNhbiBvbmx5IGJlIHVzLWFzY2lpXG4gICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzAjc3dlY3Rpb24tMy4yLjRcbiAgICAgICAgICBcIngtbXB1LWtleVwiOiBlbmNvZGVVUklDb21wb25lbnQoa2V5KVxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJ0cyksXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGRlYnVnKFwibXB1OiBjb21wbGV0ZVwiLCByZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyb3IubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L2NyZWF0ZS50c1xuZnVuY3Rpb24gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kKHsgYWxsb3dlZE9wdGlvbnMsIGdldFRva2VuLCBleHRyYUNoZWNrcyB9KSB7XG4gIHJldHVybiBhc3luYyAocGF0aG5hbWUsIG9wdGlvbnNJbnB1dCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZU11bHRpcGFydFVwbG9hZChcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZFxuICAgIH07XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVNdWx0aXBhcnRVcGxvYWQocGF0aG5hbWUsIGhlYWRlcnMsIG9wdGlvbnMpIHtcbiAgZGVidWcoXCJtcHU6IGNyZWF0ZVwiLCBcInBhdGhuYW1lOlwiLCBwYXRobmFtZSk7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBwYXRobmFtZSB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgICBgL21wdT8ke3BhcmFtcy50b1N0cmluZygpfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgIFwieC1tcHUtYWN0aW9uXCI6IFwiY3JlYXRlXCJcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgZGVidWcoXCJtcHU6IGNyZWF0ZVwiLCByZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyb3IubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIHNyYy9tdWx0aXBhcnQvdXBsb2FkLnRzXG5pbXBvcnQgdGhyb3R0bGUgZnJvbSBcInRocm90dGxlaXRcIjtcbmZ1bmN0aW9uIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgYm9keSwgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBcIkJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbS4gWW91IHNlbnQgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCwgZG91YmxlIGNoZWNrIHdoYXQgeW91J3JlIHRyeWluZyB0byB1cGxvYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwbG9hZFBhcnQoe1xuICAgICAgdXBsb2FkSWQ6IG9wdGlvbnMudXBsb2FkSWQsXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBwYXJ0OiB7IGJsb2I6IGJvZHksIHBhcnROdW1iZXI6IG9wdGlvbnMucGFydE51bWJlciB9LFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZXRhZzogcmVzdWx0LmV0YWcsXG4gICAgICBwYXJ0TnVtYmVyOiBvcHRpb25zLnBhcnROdW1iZXJcbiAgICB9O1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkUGFydCh7XG4gIHVwbG9hZElkLFxuICBrZXksXG4gIHBhdGhuYW1lLFxuICBoZWFkZXJzLFxuICBvcHRpb25zLFxuICBpbnRlcm5hbEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSxcbiAgcGFydFxufSkge1xuICB2YXIgX2EzLCBfYjIsIF9jO1xuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgcGF0aG5hbWUgfSk7XG4gIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHJlcXVlc3RBcGkoXG4gICAgYC9tcHU/JHtwYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgIHtcbiAgICAgIHNpZ25hbDogaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgXCJ4LW1wdS1hY3Rpb25cIjogXCJ1cGxvYWRcIixcbiAgICAgICAgXCJ4LW1wdS1rZXlcIjogZW5jb2RlVVJJQ29tcG9uZW50KGtleSksXG4gICAgICAgIFwieC1tcHUtdXBsb2FkLWlkXCI6IHVwbG9hZElkLFxuICAgICAgICBcIngtbXB1LXBhcnQtbnVtYmVyXCI6IHBhcnQucGFydE51bWJlci50b1N0cmluZygpXG4gICAgICB9LFxuICAgICAgLy8gd2VpcmQgdGhpbmdzIGJldHdlZW4gdW5kaWNpIHR5cGVzIGFuZCBuYXRpdmUgZmV0Y2ggdHlwZXNcbiAgICAgIGJvZHk6IHBhcnQuYmxvYlxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApO1xuICBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICBpbnRlcm5hbEFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG4gIGlmICgoX2EzID0gb3B0aW9ucy5hYm9ydFNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5hYm9ydGVkKSB7XG4gICAgaGFuZGxlQWJvcnQoKTtcbiAgfSBlbHNlIHtcbiAgICAoX2IyID0gb3B0aW9ucy5hYm9ydFNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgaGFuZGxlQWJvcnQpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2VQcm9taXNlO1xuICAoX2MgPSBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGhhbmRsZUFib3J0KTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxudmFyIG1heENvbmN1cnJlbnRVcGxvYWRzID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IDYgOiA4O1xudmFyIHBhcnRTaXplSW5CeXRlcyA9IDggKiAxMDI0ICogMTAyNDtcbnZhciBtYXhCeXRlc0luTWVtb3J5ID0gbWF4Q29uY3VycmVudFVwbG9hZHMgKiBwYXJ0U2l6ZUluQnl0ZXMgKiAyO1xuZnVuY3Rpb24gdXBsb2FkQWxsUGFydHMoe1xuICB1cGxvYWRJZCxcbiAga2V5LFxuICBwYXRobmFtZSxcbiAgc3RyZWFtLFxuICBoZWFkZXJzLFxuICBvcHRpb25zLFxuICB0b3RhbFRvTG9hZFxufSkge1xuICBkZWJ1ZyhcIm1wdTogdXBsb2FkIGluaXRcIiwgXCJrZXk6XCIsIGtleSk7XG4gIGNvbnN0IGludGVybmFsQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHBhcnRzVG9VcGxvYWQgPSBbXTtcbiAgICBjb25zdCBjb21wbGV0ZWRQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgYWN0aXZlVXBsb2FkcyA9IDA7XG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgY3VycmVudFBhcnROdW1iZXIgPSAxO1xuICAgIGxldCByZWplY3RlZCA9IGZhbHNlO1xuICAgIGxldCBjdXJyZW50Qnl0ZXNJbk1lbW9yeSA9IDA7XG4gICAgbGV0IGRvbmVSZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IGJ5dGVzU2VudCA9IDA7XG4gICAgbGV0IGFycmF5QnVmZmVycyA9IFtdO1xuICAgIGxldCBjdXJyZW50UGFydEJ5dGVzUmVhZCA9IDA7XG4gICAgbGV0IG9uVXBsb2FkUHJvZ3Jlc3M7XG4gICAgY29uc3QgdG90YWxMb2FkZWRQZXJQYXJ0TnVtYmVyID0ge307XG4gICAgaWYgKG9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykge1xuICAgICAgb25VcGxvYWRQcm9ncmVzcyA9IHRocm90dGxlKCgpID0+IHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgY29uc3QgbG9hZGVkID0gT2JqZWN0LnZhbHVlcyh0b3RhbExvYWRlZFBlclBhcnROdW1iZXIpLnJlZHVjZShcbiAgICAgICAgICAoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhY2MgKyBjdXI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gdG90YWxUb0xvYWQgfHwgbG9hZGVkO1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gdG90YWxUb0xvYWQgPiAwID8gTnVtYmVyKCgobG9hZGVkIC8gdG90YWxUb0xvYWQgfHwgbG9hZGVkKSAqIDEwMCkudG9GaXhlZCgyKSkgOiAwO1xuICAgICAgICAoX2EzID0gb3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwob3B0aW9ucywgeyBsb2FkZWQsIHRvdGFsLCBwZXJjZW50YWdlIH0pO1xuICAgICAgfSwgMTUwKTtcbiAgICB9XG4gICAgcmVhZCgpLmNhdGNoKGNhbmNlbCk7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgIGRlYnVnKFxuICAgICAgICBcIm1wdTogdXBsb2FkIHJlYWQgc3RhcnRcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzOlwiLFxuICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICBcImN1cnJlbnRCeXRlc0luTWVtb3J5OlwiLFxuICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgIGJ5dGVzKGJ5dGVzU2VudClcbiAgICAgICk7XG4gICAgICByZWFkaW5nID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChjdXJyZW50Qnl0ZXNJbk1lbW9yeSA8IG1heEJ5dGVzSW5NZW1vcnkgJiYgIXJlamVjdGVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgZG9uZVJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgZGVidWcoXCJtcHU6IHVwbG9hZCByZWFkIGNvbnN1bWVkIHRoZSB3aG9sZSBzdHJlYW1cIik7XG4gICAgICAgICAgICBpZiAoYXJyYXlCdWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcGFydHNUb1VwbG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBjdXJyZW50UGFydE51bWJlcisrLFxuICAgICAgICAgICAgICAgIGJsb2I6IG5ldyBCbG9iKGFycmF5QnVmZmVycywge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZW5kUGFydHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudEJ5dGVzSW5NZW1vcnkgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBsZXQgdmFsdWVPZmZzZXQgPSAwO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZU9mZnNldCA8IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1BhcnRTaXplID0gcGFydFNpemVJbkJ5dGVzIC0gY3VycmVudFBhcnRCeXRlc1JlYWQ7XG4gICAgICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgdmFsdWVPZmZzZXQgKyByZW1haW5pbmdQYXJ0U2l6ZSxcbiAgICAgICAgICAgICAgdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdmFsdWUuc2xpY2UodmFsdWVPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICBhcnJheUJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICBjdXJyZW50UGFydEJ5dGVzUmVhZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVPZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcnRCeXRlc1JlYWQgPT09IHBhcnRTaXplSW5CeXRlcykge1xuICAgICAgICAgICAgICBwYXJ0c1RvVXBsb2FkLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhcnROdW1iZXI6IGN1cnJlbnRQYXJ0TnVtYmVyKyssXG4gICAgICAgICAgICAgICAgYmxvYjogbmV3IEJsb2IoYXJyYXlCdWZmZXJzLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFycmF5QnVmZmVycyA9IFtdO1xuICAgICAgICAgICAgICBjdXJyZW50UGFydEJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICAgIHNlbmRQYXJ0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYW5jZWwoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJtcHU6IHVwbG9hZCByZWFkIGVuZFwiLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2VuZFBhcnQocGFydCkge1xuICAgICAgYWN0aXZlVXBsb2FkcysrO1xuICAgICAgZGVidWcoXG4gICAgICAgIFwibXB1OiB1cGxvYWQgc2VuZCBwYXJ0IHN0YXJ0XCIsXG4gICAgICAgIFwicGFydE51bWJlcjpcIixcbiAgICAgICAgcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICBcInNpemU6XCIsXG4gICAgICAgIHBhcnQuYmxvYi5zaXplLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVwbG9hZFByb2dyZXNzRm9yUGFydCA9IG9wdGlvbnMub25VcGxvYWRQcm9ncmVzcyA/IChldmVudCkgPT4ge1xuICAgICAgICAgIHRvdGFsTG9hZGVkUGVyUGFydE51bWJlcltwYXJ0LnBhcnROdW1iZXJdID0gZXZlbnQubG9hZGVkO1xuICAgICAgICAgIGlmIChvblVwbG9hZFByb2dyZXNzKSB7XG4gICAgICAgICAgICBvblVwbG9hZFByb2dyZXNzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IDogdm9pZCAwO1xuICAgICAgICBjb25zdCBjb21wbGV0ZWRQYXJ0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICAgICAgdXBsb2FkSWQsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IHVwbG9hZFByb2dyZXNzRm9yUGFydFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIsXG4gICAgICAgICAgcGFydFxuICAgICAgICB9KTtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgXCJtcHU6IHVwbG9hZCBzZW5kIHBhcnQgZW5kXCIsXG4gICAgICAgICAgXCJwYXJ0TnVtYmVyOlwiLFxuICAgICAgICAgIHBhcnQucGFydE51bWJlcixcbiAgICAgICAgICBcImFjdGl2ZVVwbG9hZHNcIixcbiAgICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgICAgYCR7Ynl0ZXMoY3VycmVudEJ5dGVzSW5NZW1vcnkpfS8ke2J5dGVzKG1heEJ5dGVzSW5NZW1vcnkpfWAsXG4gICAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgICApO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29tcGxldGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgcGFydE51bWJlcjogcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICAgIGV0YWc6IGNvbXBsZXRlZFBhcnQuZXRhZ1xuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudEJ5dGVzSW5NZW1vcnkgLT0gcGFydC5ibG9iLnNpemU7XG4gICAgICAgIGFjdGl2ZVVwbG9hZHMtLTtcbiAgICAgICAgYnl0ZXNTZW50ICs9IHBhcnQuYmxvYi5zaXplO1xuICAgICAgICBpZiAocGFydHNUb1VwbG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2VuZFBhcnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbmVSZWFkaW5nKSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZVVwbG9hZHMgPT09IDApIHtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgcmVzb2x2ZShjb21wbGV0ZWRQYXJ0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlYWRpbmcpIHtcbiAgICAgICAgICByZWFkKCkuY2F0Y2goY2FuY2VsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FuY2VsKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2VuZFBhcnRzKCkge1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlYnVnKFxuICAgICAgICBcInNlbmQgcGFydHNcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzXCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwicGFydHNUb1VwbG9hZFwiLFxuICAgICAgICBwYXJ0c1RvVXBsb2FkLmxlbmd0aFxuICAgICAgKTtcbiAgICAgIHdoaWxlIChhY3RpdmVVcGxvYWRzIDwgbWF4Q29uY3VycmVudFVwbG9hZHMgJiYgcGFydHNUb1VwbG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcnRUb1NlbmQgPSBwYXJ0c1RvVXBsb2FkLnNoaWZ0KCk7XG4gICAgICAgIGlmIChwYXJ0VG9TZW5kKSB7XG4gICAgICAgICAgdm9pZCBzZW5kUGFydChwYXJ0VG9TZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoZXJyb3IpIHtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICBpbnRlcm5hbEFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgKGVycm9yLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL211bHRpcGFydC9jcmVhdGUtdXBsb2FkZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZGVyTWV0aG9kKHsgYWxsb3dlZE9wdGlvbnMsIGdldFRva2VuLCBleHRyYUNoZWNrcyB9KSB7XG4gIHJldHVybiBhc3luYyAocGF0aG5hbWUsIG9wdGlvbnNJbnB1dCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZU11bHRpcGFydFVwbG9hZChcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICAgIGFzeW5jIHVwbG9hZFBhcnQocGFydE51bWJlciwgYm9keSkge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChib2R5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgICAgICBcIkJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbS4gWW91IHNlbnQgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCwgZG91YmxlIGNoZWNrIHdoYXQgeW91J3JlIHRyeWluZyB0byB1cGxvYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwbG9hZFBhcnQoe1xuICAgICAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICAgICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBwYXJ0OiB7IHBhcnROdW1iZXIsIGJsb2I6IGJvZHkgfSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXRhZzogcmVzdWx0LmV0YWcsXG4gICAgICAgICAgcGFydE51bWJlclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGNvbXBsZXRlKHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gICAgICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgICAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuXG4vLyBzcmMvcHV0LnRzXG5pbXBvcnQgdGhyb3R0bGUyIGZyb20gXCJ0aHJvdHRsZWl0XCI7XG5cbi8vIHNyYy9tdWx0aXBhcnQvdW5jb250cm9sbGVkLnRzXG5hc3luYyBmdW5jdGlvbiB1bmNvbnRyb2xsZWRNdWx0aXBhcnRVcGxvYWQocGF0aG5hbWUsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpIHtcbiAgZGVidWcoXCJtcHU6IGluaXRcIiwgXCJwYXRobmFtZTpcIiwgcGF0aG5hbWUsIFwiaGVhZGVyczpcIiwgaGVhZGVycyk7XG4gIGNvbnN0IG9wdGlvbnNXaXRob3V0T25VcGxvYWRQcm9ncmVzcyA9IHtcbiAgICAuLi5vcHRpb25zLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IHZvaWQgMFxuICB9O1xuICBjb25zdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZU11bHRpcGFydFVwbG9hZChcbiAgICBwYXRobmFtZSxcbiAgICBoZWFkZXJzLFxuICAgIG9wdGlvbnNXaXRob3V0T25VcGxvYWRQcm9ncmVzc1xuICApO1xuICBjb25zdCB0b3RhbFRvTG9hZCA9IGNvbXB1dGVCb2R5TGVuZ3RoKGJvZHkpO1xuICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0b1JlYWRhYmxlU3RyZWFtKGJvZHkpO1xuICBjb25zdCBwYXJ0cyA9IGF3YWl0IHVwbG9hZEFsbFBhcnRzKHtcbiAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWQsXG4gICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgcGF0aG5hbWUsXG4gICAgc3RyZWFtLFxuICAgIGhlYWRlcnMsXG4gICAgb3B0aW9ucyxcbiAgICB0b3RhbFRvTG9hZFxuICB9KTtcbiAgY29uc3QgYmxvYiA9IGF3YWl0IGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKHtcbiAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWQsXG4gICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgcGF0aG5hbWUsXG4gICAgcGFydHMsXG4gICAgaGVhZGVycyxcbiAgICBvcHRpb25zOiBvcHRpb25zV2l0aG91dE9uVXBsb2FkUHJvZ3Jlc3NcbiAgfSk7XG4gIHJldHVybiBibG9iO1xufVxuXG4vLyBzcmMvcHV0LnRzXG5mdW5jdGlvbiBjcmVhdGVQdXRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9ucyxcbiAgZ2V0VG9rZW4sXG4gIGV4dHJhQ2hlY2tzXG59KSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBwdXQocGF0aG5hbWUsIGJvZHksIG9wdGlvbnNJbnB1dCkge1xuICAgIGlmICghYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcImJvZHkgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBcIkJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbS4gWW91IHNlbnQgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCwgZG91YmxlIGNoZWNrIHdoYXQgeW91J3JlIHRyeWluZyB0byB1cGxvYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5tdWx0aXBhcnQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB1bmNvbnRyb2xsZWRNdWx0aXBhcnRVcGxvYWQocGF0aG5hbWUsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBvblVwbG9hZFByb2dyZXNzID0gb3B0aW9ucy5vblVwbG9hZFByb2dyZXNzID8gdGhyb3R0bGUyKG9wdGlvbnMub25VcGxvYWRQcm9ncmVzcywgMTAwKSA6IHZvaWQgMDtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgcGF0aG5hbWUgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgICAgYC8/JHtwYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgb25VcGxvYWRQcm9ncmVzc1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgZG93bmxvYWRVcmw6IHJlc3BvbnNlLmRvd25sb2FkVXJsLFxuICAgICAgcGF0aG5hbWU6IHJlc3BvbnNlLnBhdGhuYW1lLFxuICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uOiByZXNwb25zZS5jb250ZW50RGlzcG9zaXRpb25cbiAgICB9O1xuICB9O1xufVxuXG4vLyBzcmMvY3JlYXRlLWZvbGRlci50c1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRm9sZGVyKHBhdGhuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZm9sZGVyUGF0aG5hbWUgPSBwYXRobmFtZS5lbmRzV2l0aChcIi9cIikgPyBwYXRobmFtZSA6IGAke3BhdGhuYW1lfS9gO1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmFkZFJhbmRvbVN1ZmZpeF0gPSBcIjBcIjtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHBhdGhuYW1lOiBmb2xkZXJQYXRobmFtZSB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgIGAvPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCxcbiAgICB7XG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIHJldHVybiB7XG4gICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgcGF0aG5hbWU6IHJlc3BvbnNlLnBhdGhuYW1lXG4gIH07XG59XG5cbmV4cG9ydCB7XG4gIGdldFRva2VuRnJvbU9wdGlvbnNPckVudixcbiAgQmxvYkVycm9yLFxuICBnZXREb3dubG9hZFVybCxcbiAgZGlzYWxsb3dlZFBhdGhuYW1lQ2hhcmFjdGVycyxcbiAgTUFYSU1VTV9QQVRITkFNRV9MRU5HVEgsXG4gIEJsb2JBY2Nlc3NFcnJvcixcbiAgQmxvYkNvbnRlbnRUeXBlTm90QWxsb3dlZEVycm9yLFxuICBCbG9iUGF0aG5hbWVNaXNtYXRjaEVycm9yLFxuICBCbG9iQ2xpZW50VG9rZW5FeHBpcmVkRXJyb3IsXG4gIEJsb2JGaWxlVG9vTGFyZ2VFcnJvcixcbiAgQmxvYlN0b3JlTm90Rm91bmRFcnJvcixcbiAgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IsXG4gIEJsb2JVbmtub3duRXJyb3IsXG4gIEJsb2JOb3RGb3VuZEVycm9yLFxuICBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSxcbiAgQmxvYlNlcnZpY2VSYXRlTGltaXRlZCxcbiAgQmxvYlJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gIHJlcXVlc3RBcGksXG4gIGNyZWF0ZUNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kLFxuICBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZGVyTWV0aG9kLFxuICBjcmVhdGVQdXRNZXRob2QsXG4gIGNyZWF0ZUZvbGRlclxufTtcbi8qIVxuICogYnl0ZXNcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgVEogSG9sb3dheWNodWtcbiAqIENvcHlyaWdodChjKSAyMDE1IEplZCBXYXRzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1GTjZYRkg2Ui5qcy5tYXAiXSwibmFtZXMiOlsiaXNOb2RlUHJvY2VzcyIsImlzQnVmZmVyIiwiUmVhZGFibGUiLCJzdXBwb3J0c05ld0Jsb2JGcm9tQXJyYXlCdWZmZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsImhlbGxvQXNBcnJheUJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJibG9iIiwiQmxvYiIsInRleHQiLCJ0aGVuIiwiY2F0Y2giLCJ0b1JlYWRhYmxlU3RyZWFtIiwidmFsdWUiLCJSZWFkYWJsZVN0cmVhbSIsInN0cmVhbSIsImlzTm9kZUpzUmVhZGFibGVTdHJlYW0iLCJ0b1dlYiIsInN0cmVhbVZhbHVlIiwiQXJyYXlCdWZmZXIiLCJpc05vZGVKc0J1ZmZlciIsInN0cmluZ1RvVWludDhBcnJheSIsInN0YXJ0IiwiY29udHJvbGxlciIsImVucXVldWUiLCJjbG9zZSIsInBpcGUiLCJyZWFkYWJsZSIsIl9yZWFkIiwiX3JlYWRhYmxlU3RhdGUiLCJzIiwiZW5jIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJwYXJzZVJlZ0V4cCIsIm1hcCIsImIiLCJrYiIsIm1iIiwiZ2IiLCJ0YiIsInBiIiwiYnl0ZXMiLCJ2YWwiLCJOdW1iZXIiLCJpc05hTiIsInJlc3VsdHMiLCJleGVjIiwiZmxvYXRWYWx1ZSIsInVuaXQiLCJwYXJzZUludCIsInJlcyIsInVuaXRNYXRjaCIsInBhcnNlRmxvYXQiLCJ0b0xvd2VyQ2FzZSIsIk1hdGgiLCJmbG9vciIsImRlZmF1bHRWZXJjZWxCbG9iQXBpVXJsIiwiZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52Iiwib3B0aW9ucyIsInRva2VuIiwicHJvY2VzcyIsImVudiIsIkJMT0JfUkVBRF9XUklURV9UT0tFTiIsIkJsb2JFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiZ2V0RG93bmxvYWRVcmwiLCJibG9iVXJsIiwidXJsIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwidG9TdHJpbmciLCJpc1BsYWluT2JqZWN0IiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIml0ZXJhdG9yIiwiZGlzYWxsb3dlZFBhdGhuYW1lQ2hhcmFjdGVycyIsInN1cHBvcnRzUmVxdWVzdFN0cmVhbXMiLCJhcGlVcmwiLCJnZXRBcGlVcmwiLCJzdGFydHNXaXRoIiwiZHVwbGV4QWNjZXNzZWQiLCJoYXNDb250ZW50VHlwZSIsIlJlcXVlc3QiLCJib2R5IiwibWV0aG9kIiwiZHVwbGV4IiwiaGVhZGVycyIsImhhcyIsInBhdGhuYW1lIiwiYmFzZVVybCIsIlZFUkNFTF9CTE9CX0FQSV9VUkwiLCJORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVVJMIiwiVEVYVF9FTkNPREVSIiwiY29tcHV0ZUJvZHlMZW5ndGgiLCJieXRlTGVuZ3RoIiwic2l6ZSIsImNyZWF0ZUNodW5rVHJhbnNmb3JtU3RyZWFtIiwiY2h1bmtTaXplIiwib25Qcm9ncmVzcyIsImJ1ZmZlciIsIlRyYW5zZm9ybVN0cmVhbSIsInRyYW5zZm9ybSIsImNodW5rIiwicXVldWVNaWNyb3Rhc2siLCJuZXdCdWZmZXIiLCJsZW5ndGgiLCJuZXdDaHVuayIsInNsaWNlIiwiZmx1c2giLCJpc1JlYWRhYmxlU3RyZWFtIiwiZ2xvYmFsVGhpcyIsImlzU3RyZWFtIiwicmV0cnkiLCJkZWJ1Z0lzQWN0aXZlIiwiX2EiLCJfYiIsIkRFQlVHIiwiaW5jbHVkZXMiLCJORVhUX1BVQkxJQ19ERUJVRyIsImRlYnVnIiwiYXJncyIsImNvbnNvbGUiLCJfYTIiLCJET01FeGNlcHRpb24yIiwiRE9NRXhjZXB0aW9uIiwiYXRvYiIsImVyciIsIm9iamVjdFRvU3RyaW5nIiwiaXNFcnJvciIsImNhbGwiLCJlcnJvck1lc3NhZ2VzIiwiU2V0IiwiaXNOZXR3b3JrRXJyb3IiLCJlcnJvciIsImlzVmFsaWQiLCJuYW1lIiwic3RhY2siLCJmZXRjaCIsImhhc0ZldGNoIiwiaGFzRmV0Y2hXaXRoVXBsb2FkUHJvZ3Jlc3MiLCJDSFVOS19TSVpFIiwiYmxvYkZldGNoIiwiaW5wdXQiLCJpbml0Iiwib25VcGxvYWRQcm9ncmVzcyIsImxvYWRlZCIsImNodW5rVHJhbnNmb3JtU3RyZWFtIiwibmV3TG9hZGVkIiwicGlwZVRocm91Z2giLCJoYXNYaHIiLCJYTUxIdHRwUmVxdWVzdCIsImJsb2JYaHIiLCJSZXNwb25zZSIsInJlamVjdCIsInhociIsIm9wZW4iLCJ1cGxvYWQiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJsZW5ndGhDb21wdXRhYmxlIiwib25sb2FkIiwiX2EzIiwic2lnbmFsIiwiYWJvcnRlZCIsIkhlYWRlcnMiLCJyYXdIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwidHJpbSIsInNwbGl0IiwiZm9yRWFjaCIsImxpbmUiLCJwYXJ0cyIsImtleSIsInNoaWZ0Iiwiam9pbiIsInJlc3BvbnNlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIm9uZXJyb3IiLCJUeXBlRXJyb3IiLCJvbnRpbWVvdXQiLCJvbmFib3J0Iiwic2V0UmVxdWVzdEhlYWRlciIsImFib3J0Iiwic2VuZCIsImJsb2JSZXF1ZXN0IiwiTUFYSU1VTV9QQVRITkFNRV9MRU5HVEgiLCJCbG9iQWNjZXNzRXJyb3IiLCJCbG9iQ29udGVudFR5cGVOb3RBbGxvd2VkRXJyb3IiLCJCbG9iUGF0aG5hbWVNaXNtYXRjaEVycm9yIiwiQmxvYkNsaWVudFRva2VuRXhwaXJlZEVycm9yIiwiQmxvYkZpbGVUb29MYXJnZUVycm9yIiwiQmxvYlN0b3JlTm90Rm91bmRFcnJvciIsIkJsb2JTdG9yZVN1c3BlbmRlZEVycm9yIiwiQmxvYlVua25vd25FcnJvciIsIkJsb2JOb3RGb3VuZEVycm9yIiwiQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUiLCJCbG9iU2VydmljZVJhdGVMaW1pdGVkIiwic2Vjb25kcyIsInJldHJ5QWZ0ZXIiLCJCbG9iUmVxdWVzdEFib3J0ZWRFcnJvciIsIkJMT0JfQVBJX1ZFUlNJT04iLCJnZXRBcGlWZXJzaW9uIiwidmVyc2lvbk92ZXJyaWRlIiwiVkVSQ0VMX0JMT0JfQVBJX1ZFUlNJT05fT1ZFUlJJREUiLCJORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVkVSU0lPTl9PVkVSUklERSIsImdldFJldHJpZXMiLCJyZXRyaWVzIiwiVkVSQ0VMX0JMT0JfUkVUUklFUyIsImNyZWF0ZUJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQiLCJnZXQiLCJnZXRCbG9iRXJyb3IiLCJfYjIiLCJfYyIsImNvZGUiLCJkYXRhIiwianNvbiIsInJlcXVlc3RBcGkiLCJjb21tYW5kT3B0aW9ucyIsImFwaVZlcnNpb24iLCJleHRyYUhlYWRlcnMiLCJnZXRQcm94eVRocm91Z2hBbHRlcm5hdGl2ZUFwaUhlYWRlckZyb21FbnYiLCJzdG9yZUlkIiwicmVxdWVzdElkIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInJldHJ5Q291bnQiLCJib2R5TGVuZ3RoIiwidG90YWxMb2FkZWQiLCJzZW5kQm9keUxlbmd0aCIsInNob3VsZFVzZVhDb250ZW50TGVuZ3RoIiwidG90YWwiLCJwZXJjZW50YWdlIiwiYXBpUmVzcG9uc2UiLCJiYWlsIiwiU3RyaW5nIiwiYXV0aG9yaXphdGlvbiIsInRvRml4ZWQiLCJlcnJvcjIiLCJvayIsIm9uUmV0cnkiLCJWRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSSIsIk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJIiwiVkVSQ0VMX0JMT0JfVVNFX1hfQ09OVEVOVF9MRU5HVEgiLCJwdXRPcHRpb25IZWFkZXJNYXAiLCJjYWNoZUNvbnRyb2xNYXhBZ2UiLCJhZGRSYW5kb21TdWZmaXgiLCJhbGxvd092ZXJ3cml0ZSIsImNvbnRlbnRUeXBlIiwiY3JlYXRlUHV0SGVhZGVycyIsImFsbG93ZWRPcHRpb25zIiwiY3JlYXRlUHV0T3B0aW9ucyIsImV4dHJhQ2hlY2tzIiwiZ2V0VG9rZW4iLCJpbnZhbGlkQ2hhcmFjdGVyIiwiYWNjZXNzIiwiY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QiLCJvcHRpb25zSW5wdXQiLCJjb21wbGV0ZU11bHRpcGFydFVwbG9hZCIsInVwbG9hZElkIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsImFib3J0U2lnbmFsIiwiY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kIiwiY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UiLCJjcmVhdGVNdWx0aXBhcnRVcGxvYWQiLCJ0aHJvdHRsZSIsImNyZWF0ZVVwbG9hZFBhcnRNZXRob2QiLCJyZXN1bHQiLCJ1cGxvYWRQYXJ0IiwicGFydCIsInBhcnROdW1iZXIiLCJldGFnIiwiaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJyZXNwb25zZVByb21pc2UiLCJoYW5kbGVBYm9ydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJtYXhDb25jdXJyZW50VXBsb2FkcyIsInBhcnRTaXplSW5CeXRlcyIsIm1heEJ5dGVzSW5NZW1vcnkiLCJ1cGxvYWRBbGxQYXJ0cyIsInRvdGFsVG9Mb2FkIiwicGFydHNUb1VwbG9hZCIsImNvbXBsZXRlZFBhcnRzIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiYWN0aXZlVXBsb2FkcyIsInJlYWRpbmciLCJjdXJyZW50UGFydE51bWJlciIsInJlamVjdGVkIiwiY3VycmVudEJ5dGVzSW5NZW1vcnkiLCJkb25lUmVhZGluZyIsImJ5dGVzU2VudCIsImFycmF5QnVmZmVycyIsImN1cnJlbnRQYXJ0Qnl0ZXNSZWFkIiwidG90YWxMb2FkZWRQZXJQYXJ0TnVtYmVyIiwidmFsdWVzIiwicmVkdWNlIiwiYWNjIiwiY3VyIiwicmVhZCIsImNhbmNlbCIsImRvbmUiLCJwdXNoIiwidHlwZSIsInNlbmRQYXJ0cyIsInZhbHVlT2Zmc2V0IiwicmVtYWluaW5nUGFydFNpemUiLCJlbmRPZmZzZXQiLCJtaW4iLCJzZW5kUGFydCIsInVwbG9hZFByb2dyZXNzRm9yUGFydCIsImNvbXBsZXRlZFBhcnQiLCJyZWxlYXNlTG9jayIsInBhcnRUb1NlbmQiLCJjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCIsImNvbXBsZXRlIiwidGhyb3R0bGUyIiwidW5jb250cm9sbGVkTXVsdGlwYXJ0VXBsb2FkIiwib3B0aW9uc1dpdGhvdXRPblVwbG9hZFByb2dyZXNzIiwiY3JlYXRlUHV0TWV0aG9kIiwicHV0IiwibXVsdGlwYXJ0IiwiZG93bmxvYWRVcmwiLCJjb250ZW50RGlzcG9zaXRpb24iLCJjcmVhdGVGb2xkZXIiLCJmb2xkZXJQYXRobmFtZSIsImVuZHNXaXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@vercel/blob/dist/client.js":
/*!**************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/client.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   completeMultipartUpload: function() { return /* binding */ completeMultipartUpload; },\n/* harmony export */   createFolder: function() { return /* reexport safe */ _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.createFolder; },\n/* harmony export */   createMultipartUpload: function() { return /* binding */ createMultipartUpload; },\n/* harmony export */   createMultipartUploader: function() { return /* binding */ createMultipartUploader; },\n/* harmony export */   generateClientTokenFromReadWriteToken: function() { return /* binding */ generateClientTokenFromReadWriteToken; },\n/* harmony export */   getPayloadFromClientToken: function() { return /* binding */ getPayloadFromClientToken; },\n/* harmony export */   handleUpload: function() { return /* binding */ handleUpload; },\n/* harmony export */   put: function() { return /* binding */ put; },\n/* harmony export */   upload: function() { return /* binding */ upload; },\n/* harmony export */   uploadPart: function() { return /* binding */ uploadPart; }\n/* harmony export */ });\n/* harmony import */ var _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-FN6XFH6R.js */ \"(app-pages-browser)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"(app-pages-browser)/./node_modules/@vercel/blob/dist/crypto-browser.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! undici */ \"(app-pages-browser)/./node_modules/@vercel/blob/dist/undici-browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n\n// src/client.ts\n\n\nfunction createPutExtraChecks(methodName) {\n    return function extraChecks(options) {\n        if (!options.token.startsWith(\"vercel_blob_client_\")) {\n            throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"\".concat(methodName, \" must be called with a client token\"));\n        }\n        if (// @ts-expect-error -- Runtime check for DX.\n        options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n        options.allowOverwrite !== void 0 || // @ts-expect-error -- Runtime check for DX.\n        options.cacheControlMaxAge !== void 0) {\n            throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"\".concat(methodName, \" doesn't allow `addRandomSuffix`, `cacheControlMaxAge` or `allowOverwrite`. Configure these options at the server side when generating client tokens.\"));\n        }\n    };\n}\nvar put = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.createPutMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks: createPutExtraChecks(\"client/`put`\")\n});\nvar createMultipartUpload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.createCreateMultipartUploadMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n});\nvar createMultipartUploader = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.createCreateMultipartUploaderMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n});\nvar uploadPart = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.createUploadPartMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks: createPutExtraChecks(\"client/`multipartUpload`\")\n});\nvar completeMultipartUpload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.createCompleteMultipartUploadMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks: createPutExtraChecks(\"client/`completeMultipartUpload`\")\n});\nvar upload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.createPutMethod)({\n    allowedOptions: [\n        \"contentType\"\n    ],\n    extraChecks (options) {\n        if (options.handleUploadUrl === void 0) {\n            throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"client/`upload` requires the 'handleUploadUrl' parameter\");\n        }\n        if (// @ts-expect-error -- Runtime check for DX.\n        options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n        options.createPutExtraChecks !== void 0 || // @ts-expect-error -- Runtime check for DX.\n        options.cacheControlMaxAge !== void 0) {\n            throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"client/`upload` doesn't allow `addRandomSuffix`, `cacheControlMaxAge` or `allowOverwrite`. Configure these options at the server side when generating client tokens.\");\n        }\n    },\n    async getToken (pathname, options) {\n        var _a, _b;\n        return retrieveClientToken({\n            handleUploadUrl: options.handleUploadUrl,\n            pathname,\n            clientPayload: (_a = options.clientPayload) != null ? _a : null,\n            multipart: (_b = options.multipart) != null ? _b : false,\n            headers: options.headers\n        });\n    }\n});\nasync function importKey(token) {\n    return globalThis.crypto.subtle.importKey(\"raw\", new TextEncoder().encode(token), {\n        name: \"HMAC\",\n        hash: \"SHA-256\"\n    }, false, [\n        \"sign\",\n        \"verify\"\n    ]);\n}\nasync function signPayload(payload, token) {\n    if (!globalThis.crypto) {\n        return crypto__WEBPACK_IMPORTED_MODULE_1__.createHmac(\"sha256\", token).update(payload).digest(\"hex\");\n    }\n    const signature = await globalThis.crypto.subtle.sign(\"HMAC\", await importKey(token), new TextEncoder().encode(payload));\n    return Buffer.from(new Uint8Array(signature)).toString(\"hex\");\n}\nasync function verifyCallbackSignature(param) {\n    let { token, signature, body } = param;\n    const secret = token;\n    if (!globalThis.crypto) {\n        const digest = crypto__WEBPACK_IMPORTED_MODULE_1__.createHmac(\"sha256\", secret).update(body).digest(\"hex\");\n        const digestBuffer = Buffer.from(digest);\n        const signatureBuffer = Buffer.from(signature);\n        return digestBuffer.length === signatureBuffer.length && crypto__WEBPACK_IMPORTED_MODULE_1__.timingSafeEqual(digestBuffer, signatureBuffer);\n    }\n    const verified = await globalThis.crypto.subtle.verify(\"HMAC\", await importKey(token), hexToArrayByte(signature), new TextEncoder().encode(body));\n    return verified;\n}\nfunction hexToArrayByte(input) {\n    if (input.length % 2 !== 0) {\n        throw new RangeError(\"Expected string to be an even number of characters\");\n    }\n    const view = new Uint8Array(input.length / 2);\n    for(let i = 0; i < input.length; i += 2){\n        view[i / 2] = Number.parseInt(input.substring(i, i + 2), 16);\n    }\n    return Buffer.from(view);\n}\nfunction getPayloadFromClientToken(clientToken) {\n    const [, , , , encodedToken] = clientToken.split(\"_\");\n    const encodedPayload = Buffer.from(encodedToken != null ? encodedToken : \"\", \"base64\").toString().split(\".\")[1];\n    const decodedPayload = Buffer.from(encodedPayload != null ? encodedPayload : \"\", \"base64\").toString();\n    return JSON.parse(decodedPayload);\n}\nvar EventTypes = {\n    generateClientToken: \"blob.generate-client-token\",\n    uploadCompleted: \"blob.upload-completed\"\n};\nasync function handleUpload(param) {\n    let { token, request, body, onBeforeGenerateToken, onUploadCompleted } = param;\n    var _a, _b, _c, _d;\n    const resolvedToken = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.getTokenFromOptionsOrEnv)({\n        token\n    });\n    const type = body.type;\n    switch(type){\n        case \"blob.generate-client-token\":\n            {\n                const { pathname, clientPayload, multipart } = body.payload;\n                const payload = await onBeforeGenerateToken(pathname, clientPayload, multipart);\n                const tokenPayload = (_a = payload.tokenPayload) != null ? _a : clientPayload;\n                const { callbackUrl: providedCallbackUrl, ...tokenOptions } = payload;\n                let callbackUrl = providedCallbackUrl;\n                if (onUploadCompleted && !callbackUrl) {\n                    callbackUrl = getCallbackUrl(request);\n                }\n                if (!onUploadCompleted && callbackUrl) {\n                    console.warn(\"callbackUrl was provided but onUploadCompleted is not defined. The callback will not be handled.\");\n                }\n                const oneHourInSeconds = 60 * 60;\n                const now = /* @__PURE__ */ new Date();\n                const validUntil = (_b = payload.validUntil) != null ? _b : now.setSeconds(now.getSeconds() + oneHourInSeconds);\n                return {\n                    type,\n                    clientToken: await generateClientTokenFromReadWriteToken({\n                        ...tokenOptions,\n                        token: resolvedToken,\n                        pathname,\n                        onUploadCompleted: callbackUrl ? {\n                            callbackUrl,\n                            tokenPayload\n                        } : void 0,\n                        validUntil\n                    })\n                };\n            }\n        case \"blob.upload-completed\":\n            {\n                const signatureHeader = \"x-vercel-signature\";\n                const signature = \"credentials\" in request ? (_c = request.headers.get(signatureHeader)) != null ? _c : \"\" : (_d = request.headers[signatureHeader]) != null ? _d : \"\";\n                if (!signature) {\n                    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"Missing callback signature\");\n                }\n                const isVerified = await verifyCallbackSignature({\n                    token: resolvedToken,\n                    signature,\n                    body: JSON.stringify(body)\n                });\n                if (!isVerified) {\n                    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"Invalid callback signature\");\n                }\n                if (onUploadCompleted) {\n                    await onUploadCompleted(body.payload);\n                }\n                return {\n                    type,\n                    response: \"ok\"\n                };\n            }\n        default:\n            throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"Invalid event type\");\n    }\n}\nasync function retrieveClientToken(options) {\n    const { handleUploadUrl, pathname } = options;\n    const url = isAbsoluteUrl(handleUploadUrl) ? handleUploadUrl : toAbsoluteUrl(handleUploadUrl);\n    const event = {\n        type: EventTypes.generateClientToken,\n        payload: {\n            pathname,\n            clientPayload: options.clientPayload,\n            multipart: options.multipart\n        }\n    };\n    const res = await (0,undici__WEBPACK_IMPORTED_MODULE_2__.fetch)(url, {\n        method: \"POST\",\n        body: JSON.stringify(event),\n        headers: {\n            \"content-type\": \"application/json\",\n            ...options.headers\n        },\n        signal: options.abortSignal\n    });\n    if (!res.ok) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"Failed to  retrieve the client token\");\n    }\n    try {\n        const { clientToken } = await res.json();\n        return clientToken;\n    } catch (e) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"Failed to retrieve the client token\");\n    }\n}\nfunction toAbsoluteUrl(url) {\n    return new URL(url, location.href).href;\n}\nfunction isAbsoluteUrl(url) {\n    try {\n        return Boolean(new URL(url));\n    } catch (e) {\n        return false;\n    }\n}\nasync function generateClientTokenFromReadWriteToken(param) {\n    let { token, ...argsWithoutToken } = param;\n    var _a;\n    if (true) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError('\"generateClientTokenFromReadWriteToken\" must be called from a server environment');\n    }\n    const timestamp = /* @__PURE__ */ new Date();\n    timestamp.setSeconds(timestamp.getSeconds() + 30);\n    const readWriteToken = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.getTokenFromOptionsOrEnv)({\n        token\n    });\n    const [, , , storeId = null] = readWriteToken.split(\"_\");\n    if (!storeId) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(token ? \"Invalid `token` parameter\" : \"Invalid `BLOB_READ_WRITE_TOKEN`\");\n    }\n    const payload = Buffer.from(JSON.stringify({\n        ...argsWithoutToken,\n        validUntil: (_a = argsWithoutToken.validUntil) != null ? _a : timestamp.getTime()\n    })).toString(\"base64\");\n    const securedKey = await signPayload(payload, readWriteToken);\n    if (!securedKey) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"Unable to sign client token\");\n    }\n    return \"vercel_blob_client_\".concat(storeId, \"_\").concat(Buffer.from(\"\".concat(securedKey, \".\").concat(payload)).toString(\"base64\"));\n}\nfunction getCallbackUrl(request) {\n    const reqPath = getPathFromRequestUrl(request.url);\n    if (!reqPath) {\n        console.warn(\"onUploadCompleted provided but no callbackUrl could be determined. Please provide a callbackUrl in onBeforeGenerateToken or set the VERCEL_BLOB_CALLBACK_URL environment variable.\");\n        return void 0;\n    }\n    if (process.env.VERCEL_BLOB_CALLBACK_URL) {\n        return \"\".concat(process.env.VERCEL_BLOB_CALLBACK_URL).concat(reqPath);\n    }\n    if (process.env.VERCEL !== \"1\") {\n        console.warn(\"onUploadCompleted provided but no callbackUrl could be determined. Please provide a callbackUrl in onBeforeGenerateToken or set the VERCEL_BLOB_CALLBACK_URL environment variable.\");\n        return void 0;\n    }\n    if (process.env.VERCEL_ENV === \"preview\") {\n        if (process.env.VERCEL_BRANCH_URL) {\n            return \"https://\".concat(process.env.VERCEL_BRANCH_URL).concat(reqPath);\n        }\n        if (process.env.VERCEL_URL) {\n            return \"https://\".concat(process.env.VERCEL_URL).concat(reqPath);\n        }\n    }\n    if (process.env.VERCEL_ENV === \"production\" && process.env.VERCEL_PROJECT_PRODUCTION_URL) {\n        return \"https://\".concat(process.env.VERCEL_PROJECT_PRODUCTION_URL).concat(reqPath);\n    }\n    return void 0;\n}\nfunction getPathFromRequestUrl(url) {\n    try {\n        const parsedUrl = new URL(url, \"https://dummy.com\");\n        return parsedUrl.pathname + parsedUrl.search;\n    } catch (e) {\n        return null;\n    }\n}\n //# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmVyY2VsL2Jsb2IvZGlzdC9jbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUzZCO0FBRTdCLGdCQUFnQjtBQUNpQjtBQUNGO0FBQy9CLFNBQVNVLHFCQUFxQkMsVUFBVTtJQUN0QyxPQUFPLFNBQVNDLFlBQVlDLE9BQU87UUFDakMsSUFBSSxDQUFDQSxRQUFRQyxLQUFLLENBQUNDLFVBQVUsQ0FBQyx3QkFBd0I7WUFDcEQsTUFBTSxJQUFJZix5REFBU0EsQ0FBQyxHQUFjLE9BQVhXLFlBQVc7UUFDcEM7UUFDQSxJQUNFLDRDQUE0QztRQUM1Q0UsUUFBUUcsZUFBZSxLQUFLLEtBQUssS0FBSyw0Q0FBNEM7UUFDbEZILFFBQVFJLGNBQWMsS0FBSyxLQUFLLEtBQUssNENBQTRDO1FBQ2pGSixRQUFRSyxrQkFBa0IsS0FBSyxLQUFLLEdBQ3BDO1lBQ0EsTUFBTSxJQUFJbEIseURBQVNBLENBQ2pCLEdBQWMsT0FBWFcsWUFBVztRQUVsQjtJQUNGO0FBQ0Y7QUFDQSxJQUFJUSxNQUFNZCxtRUFBZUEsQ0FBQztJQUN4QmUsZ0JBQWdCO1FBQUM7S0FBYztJQUMvQlIsYUFBYUYscUJBQXFCO0FBQ3BDO0FBQ0EsSUFBSVcsd0JBQXdCbkIscUZBQWlDQSxDQUFDO0lBQzVEa0IsZ0JBQWdCO1FBQUM7S0FBYztJQUMvQlIsYUFBYUYscUJBQXFCO0FBQ3BDO0FBQ0EsSUFBSVksMEJBQTBCbkIsdUZBQW1DQSxDQUMvRDtJQUNFaUIsZ0JBQWdCO1FBQUM7S0FBYztJQUMvQlIsYUFBYUYscUJBQXFCO0FBQ3BDO0FBRUYsSUFBSWEsYUFBYWpCLDBFQUFzQkEsQ0FBQztJQUN0Q2MsZ0JBQWdCO1FBQUM7S0FBYztJQUMvQlIsYUFBYUYscUJBQXFCO0FBQ3BDO0FBQ0EsSUFBSWMsMEJBQTBCdkIsdUZBQW1DQSxDQUMvRDtJQUNFbUIsZ0JBQWdCO1FBQUM7S0FBYztJQUMvQlIsYUFBYUYscUJBQXFC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Tl9FLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvYmxvYi9kaXN0L2NsaWVudC5qcz85NmIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJsb2JFcnJvcixcbiAgY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QsXG4gIGNyZWF0ZUZvbGRlcixcbiAgY3JlYXRlUHV0TWV0aG9kLFxuICBjcmVhdGVVcGxvYWRQYXJ0TWV0aG9kLFxuICBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnZcbn0gZnJvbSBcIi4vY2h1bmstRk42WEZINlIuanNcIjtcblxuLy8gc3JjL2NsaWVudC50c1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gXCJjcnlwdG9cIjtcbmltcG9ydCB7IGZldGNoIH0gZnJvbSBcInVuZGljaVwiO1xuZnVuY3Rpb24gY3JlYXRlUHV0RXh0cmFDaGVja3MobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZXh0cmFDaGVja3Mob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy50b2tlbi5zdGFydHNXaXRoKFwidmVyY2VsX2Jsb2JfY2xpZW50X1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihgJHttZXRob2ROYW1lfSBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgY2xpZW50IHRva2VuYCk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCAhPT0gdm9pZCAwIHx8IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmFsbG93T3ZlcndyaXRlICE9PSB2b2lkIDAgfHwgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlICE9PSB2b2lkIDBcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIGAke21ldGhvZE5hbWV9IGRvZXNuJ3QgYWxsb3cgXFxgYWRkUmFuZG9tU3VmZml4XFxgLCBcXGBjYWNoZUNvbnRyb2xNYXhBZ2VcXGAgb3IgXFxgYWxsb3dPdmVyd3JpdGVcXGAuIENvbmZpZ3VyZSB0aGVzZSBvcHRpb25zIGF0IHRoZSBzZXJ2ZXIgc2lkZSB3aGVuIGdlbmVyYXRpbmcgY2xpZW50IHRva2Vucy5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbnZhciBwdXQgPSBjcmVhdGVQdXRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gIGV4dHJhQ2hlY2tzOiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhcImNsaWVudC9gcHV0YFwiKVxufSk7XG52YXIgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkID0gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kKHtcbiAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICBleHRyYUNoZWNrczogY3JlYXRlUHV0RXh0cmFDaGVja3MoXCJjbGllbnQvYGNyZWF0ZU11bHRpcGFydFVwbG9hZGBcIilcbn0pO1xudmFyIGNyZWF0ZU11bHRpcGFydFVwbG9hZGVyID0gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QoXG4gIHtcbiAgICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gICAgZXh0cmFDaGVja3M6IGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKFwiY2xpZW50L2BjcmVhdGVNdWx0aXBhcnRVcGxvYWRgXCIpXG4gIH1cbik7XG52YXIgdXBsb2FkUGFydCA9IGNyZWF0ZVVwbG9hZFBhcnRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gIGV4dHJhQ2hlY2tzOiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhcImNsaWVudC9gbXVsdGlwYXJ0VXBsb2FkYFwiKVxufSk7XG52YXIgY29tcGxldGVNdWx0aXBhcnRVcGxvYWQgPSBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZChcbiAge1xuICAgIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgICBleHRyYUNoZWNrczogY3JlYXRlUHV0RXh0cmFDaGVja3MoXCJjbGllbnQvYGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkYFwiKVxuICB9XG4pO1xudmFyIHVwbG9hZCA9IGNyZWF0ZVB1dE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgZXh0cmFDaGVja3Mob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhbmRsZVVwbG9hZFVybCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBcImNsaWVudC9gdXBsb2FkYCByZXF1aXJlcyB0aGUgJ2hhbmRsZVVwbG9hZFVybCcgcGFyYW1ldGVyXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCAhPT0gdm9pZCAwIHx8IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmNyZWF0ZVB1dEV4dHJhQ2hlY2tzICE9PSB2b2lkIDAgfHwgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlICE9PSB2b2lkIDBcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIFwiY2xpZW50L2B1cGxvYWRgIGRvZXNuJ3QgYWxsb3cgYGFkZFJhbmRvbVN1ZmZpeGAsIGBjYWNoZUNvbnRyb2xNYXhBZ2VgIG9yIGBhbGxvd092ZXJ3cml0ZWAuIENvbmZpZ3VyZSB0aGVzZSBvcHRpb25zIGF0IHRoZSBzZXJ2ZXIgc2lkZSB3aGVuIGdlbmVyYXRpbmcgY2xpZW50IHRva2Vucy5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGFzeW5jIGdldFRva2VuKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gcmV0cmlldmVDbGllbnRUb2tlbih7XG4gICAgICBoYW5kbGVVcGxvYWRVcmw6IG9wdGlvbnMuaGFuZGxlVXBsb2FkVXJsLFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBjbGllbnRQYXlsb2FkOiAoX2EgPSBvcHRpb25zLmNsaWVudFBheWxvYWQpICE9IG51bGwgPyBfYSA6IG51bGwsXG4gICAgICBtdWx0aXBhcnQ6IChfYiA9IG9wdGlvbnMubXVsdGlwYXJ0KSAhPSBudWxsID8gX2IgOiBmYWxzZSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICB9XG59KTtcbmFzeW5jIGZ1bmN0aW9uIGltcG9ydEtleSh0b2tlbikge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICBcInJhd1wiLFxuICAgIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0b2tlbiksXG4gICAgeyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogXCJTSEEtMjU2XCIgfSxcbiAgICBmYWxzZSxcbiAgICBbXCJzaWduXCIsIFwidmVyaWZ5XCJdXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBzaWduUGF5bG9hZChwYXlsb2FkLCB0b2tlbikge1xuICBpZiAoIWdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKFwic2hhMjU2XCIsIHRva2VuKS51cGRhdGUocGF5bG9hZCkuZGlnZXN0KFwiaGV4XCIpO1xuICB9XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS5zaWduKFxuICAgIFwiSE1BQ1wiLFxuICAgIGF3YWl0IGltcG9ydEtleSh0b2tlbiksXG4gICAgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHBheWxvYWQpXG4gICk7XG4gIHJldHVybiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShzaWduYXR1cmUpKS50b1N0cmluZyhcImhleFwiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUNhbGxiYWNrU2lnbmF0dXJlKHtcbiAgdG9rZW4sXG4gIHNpZ25hdHVyZSxcbiAgYm9keVxufSkge1xuICBjb25zdCBzZWNyZXQgPSB0b2tlbjtcbiAgaWYgKCFnbG9iYWxUaGlzLmNyeXB0bykge1xuICAgIGNvbnN0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIbWFjKFwic2hhMjU2XCIsIHNlY3JldCkudXBkYXRlKGJvZHkpLmRpZ2VzdChcImhleFwiKTtcbiAgICBjb25zdCBkaWdlc3RCdWZmZXIgPSBCdWZmZXIuZnJvbShkaWdlc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIGRpZ2VzdEJ1ZmZlci5sZW5ndGggPT09IHNpZ25hdHVyZUJ1ZmZlci5sZW5ndGggJiYgY3J5cHRvLnRpbWluZ1NhZmVFcXVhbChkaWdlc3RCdWZmZXIsIHNpZ25hdHVyZUJ1ZmZlcik7XG4gIH1cbiAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUudmVyaWZ5KFxuICAgIFwiSE1BQ1wiLFxuICAgIGF3YWl0IGltcG9ydEtleSh0b2tlbiksXG4gICAgaGV4VG9BcnJheUJ5dGUoc2lnbmF0dXJlKSxcbiAgICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoYm9keSlcbiAgKTtcbiAgcmV0dXJuIHZlcmlmaWVkO1xufVxuZnVuY3Rpb24gaGV4VG9BcnJheUJ5dGUoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV4cGVjdGVkIHN0cmluZyB0byBiZSBhbiBldmVuIG51bWJlciBvZiBjaGFyYWN0ZXJzXCIpO1xuICB9XG4gIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggLyAyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZpZXdbaSAvIDJdID0gTnVtYmVyLnBhcnNlSW50KGlucHV0LnN1YnN0cmluZyhpLCBpICsgMiksIDE2KTtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20odmlldyk7XG59XG5mdW5jdGlvbiBnZXRQYXlsb2FkRnJvbUNsaWVudFRva2VuKGNsaWVudFRva2VuKSB7XG4gIGNvbnN0IFssICwgLCAsIGVuY29kZWRUb2tlbl0gPSBjbGllbnRUb2tlbi5zcGxpdChcIl9cIik7XG4gIGNvbnN0IGVuY29kZWRQYXlsb2FkID0gQnVmZmVyLmZyb20oZW5jb2RlZFRva2VuICE9IG51bGwgPyBlbmNvZGVkVG9rZW4gOiBcIlwiLCBcImJhc2U2NFwiKS50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXTtcbiAgY29uc3QgZGVjb2RlZFBheWxvYWQgPSBCdWZmZXIuZnJvbShlbmNvZGVkUGF5bG9hZCAhPSBudWxsID8gZW5jb2RlZFBheWxvYWQgOiBcIlwiLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVkUGF5bG9hZCk7XG59XG52YXIgRXZlbnRUeXBlcyA9IHtcbiAgZ2VuZXJhdGVDbGllbnRUb2tlbjogXCJibG9iLmdlbmVyYXRlLWNsaWVudC10b2tlblwiLFxuICB1cGxvYWRDb21wbGV0ZWQ6IFwiYmxvYi51cGxvYWQtY29tcGxldGVkXCJcbn07XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVVcGxvYWQoe1xuICB0b2tlbixcbiAgcmVxdWVzdCxcbiAgYm9keSxcbiAgb25CZWZvcmVHZW5lcmF0ZVRva2VuLFxuICBvblVwbG9hZENvbXBsZXRlZFxufSkge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IHJlc29sdmVkVG9rZW4gPSBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYoeyB0b2tlbiB9KTtcbiAgY29uc3QgdHlwZSA9IGJvZHkudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImJsb2IuZ2VuZXJhdGUtY2xpZW50LXRva2VuXCI6IHtcbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIGNsaWVudFBheWxvYWQsIG11bHRpcGFydCB9ID0gYm9keS5wYXlsb2FkO1xuICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IG9uQmVmb3JlR2VuZXJhdGVUb2tlbihcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIGNsaWVudFBheWxvYWQsXG4gICAgICAgIG11bHRpcGFydFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRva2VuUGF5bG9hZCA9IChfYSA9IHBheWxvYWQudG9rZW5QYXlsb2FkKSAhPSBudWxsID8gX2EgOiBjbGllbnRQYXlsb2FkO1xuICAgICAgY29uc3QgeyBjYWxsYmFja1VybDogcHJvdmlkZWRDYWxsYmFja1VybCwgLi4udG9rZW5PcHRpb25zIH0gPSBwYXlsb2FkO1xuICAgICAgbGV0IGNhbGxiYWNrVXJsID0gcHJvdmlkZWRDYWxsYmFja1VybDtcbiAgICAgIGlmIChvblVwbG9hZENvbXBsZXRlZCAmJiAhY2FsbGJhY2tVcmwpIHtcbiAgICAgICAgY2FsbGJhY2tVcmwgPSBnZXRDYWxsYmFja1VybChyZXF1ZXN0KTtcbiAgICAgIH1cbiAgICAgIGlmICghb25VcGxvYWRDb21wbGV0ZWQgJiYgY2FsbGJhY2tVcmwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY2FsbGJhY2tVcmwgd2FzIHByb3ZpZGVkIGJ1dCBvblVwbG9hZENvbXBsZXRlZCBpcyBub3QgZGVmaW5lZC4gVGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGhhbmRsZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZUhvdXJJblNlY29uZHMgPSA2MCAqIDYwO1xuICAgICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB2YWxpZFVudGlsID0gKF9iID0gcGF5bG9hZC52YWxpZFVudGlsKSAhPSBudWxsID8gX2IgOiBub3cuc2V0U2Vjb25kcyhub3cuZ2V0U2Vjb25kcygpICsgb25lSG91ckluU2Vjb25kcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBjbGllbnRUb2tlbjogYXdhaXQgZ2VuZXJhdGVDbGllbnRUb2tlbkZyb21SZWFkV3JpdGVUb2tlbih7XG4gICAgICAgICAgLi4udG9rZW5PcHRpb25zLFxuICAgICAgICAgIHRva2VuOiByZXNvbHZlZFRva2VuLFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIG9uVXBsb2FkQ29tcGxldGVkOiBjYWxsYmFja1VybCA/IHtcbiAgICAgICAgICAgIGNhbGxiYWNrVXJsLFxuICAgICAgICAgICAgdG9rZW5QYXlsb2FkXG4gICAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgICB2YWxpZFVudGlsXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiYmxvYi51cGxvYWQtY29tcGxldGVkXCI6IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUhlYWRlciA9IFwieC12ZXJjZWwtc2lnbmF0dXJlXCI7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBcImNyZWRlbnRpYWxzXCIgaW4gcmVxdWVzdCA/IChfYyA9IHJlcXVlc3QuaGVhZGVycy5nZXQoc2lnbmF0dXJlSGVhZGVyKSkgIT0gbnVsbCA/IF9jIDogXCJcIiA6IChfZCA9IHJlcXVlc3QuaGVhZGVyc1tzaWduYXR1cmVIZWFkZXJdKSAhPSBudWxsID8gX2QgOiBcIlwiO1xuICAgICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIk1pc3NpbmcgY2FsbGJhY2sgc2lnbmF0dXJlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IHZlcmlmeUNhbGxiYWNrU2lnbmF0dXJlKHtcbiAgICAgICAgdG9rZW46IHJlc29sdmVkVG9rZW4sXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc1ZlcmlmaWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJJbnZhbGlkIGNhbGxiYWNrIHNpZ25hdHVyZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvblVwbG9hZENvbXBsZXRlZCkge1xuICAgICAgICBhd2FpdCBvblVwbG9hZENvbXBsZXRlZChib2R5LnBheWxvYWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZSwgcmVzcG9uc2U6IFwib2tcIiB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkludmFsaWQgZXZlbnQgdHlwZVwiKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmV0cmlldmVDbGllbnRUb2tlbihvcHRpb25zKSB7XG4gIGNvbnN0IHsgaGFuZGxlVXBsb2FkVXJsLCBwYXRobmFtZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgdXJsID0gaXNBYnNvbHV0ZVVybChoYW5kbGVVcGxvYWRVcmwpID8gaGFuZGxlVXBsb2FkVXJsIDogdG9BYnNvbHV0ZVVybChoYW5kbGVVcGxvYWRVcmwpO1xuICBjb25zdCBldmVudCA9IHtcbiAgICB0eXBlOiBFdmVudFR5cGVzLmdlbmVyYXRlQ2xpZW50VG9rZW4sXG4gICAgcGF5bG9hZDoge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBjbGllbnRQYXlsb2FkOiBvcHRpb25zLmNsaWVudFBheWxvYWQsXG4gICAgICBtdWx0aXBhcnQ6IG9wdGlvbnMubXVsdGlwYXJ0XG4gICAgfVxuICB9O1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGV2ZW50KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgIH0sXG4gICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gIH0pO1xuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJGYWlsZWQgdG8gIHJldHJpZXZlIHRoZSBjbGllbnQgdG9rZW5cIik7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGNsaWVudFRva2VuIH0gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiBjbGllbnRUb2tlbjtcbiAgfSBjYXRjaCB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkZhaWxlZCB0byByZXRyaWV2ZSB0aGUgY2xpZW50IHRva2VuXCIpO1xuICB9XG59XG5mdW5jdGlvbiB0b0Fic29sdXRlVXJsKHVybCkge1xuICByZXR1cm4gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpLmhyZWY7XG59XG5mdW5jdGlvbiBpc0Fic29sdXRlVXJsKHVybCkge1xuICB0cnkge1xuICAgIHJldHVybiBCb29sZWFuKG5ldyBVUkwodXJsKSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVDbGllbnRUb2tlbkZyb21SZWFkV3JpdGVUb2tlbih7XG4gIHRva2VuLFxuICAuLi5hcmdzV2l0aG91dFRva2VuXG59KSB7XG4gIHZhciBfYTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgJ1wiZ2VuZXJhdGVDbGllbnRUb2tlbkZyb21SZWFkV3JpdGVUb2tlblwiIG11c3QgYmUgY2FsbGVkIGZyb20gYSBzZXJ2ZXIgZW52aXJvbm1lbnQnXG4gICAgKTtcbiAgfVxuICBjb25zdCB0aW1lc3RhbXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgdGltZXN0YW1wLnNldFNlY29uZHModGltZXN0YW1wLmdldFNlY29uZHMoKSArIDMwKTtcbiAgY29uc3QgcmVhZFdyaXRlVG9rZW4gPSBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYoeyB0b2tlbiB9KTtcbiAgY29uc3QgWywgLCAsIHN0b3JlSWQgPSBudWxsXSA9IHJlYWRXcml0ZVRva2VuLnNwbGl0KFwiX1wiKTtcbiAgaWYgKCFzdG9yZUlkKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgIHRva2VuID8gXCJJbnZhbGlkIGB0b2tlbmAgcGFyYW1ldGVyXCIgOiBcIkludmFsaWQgYEJMT0JfUkVBRF9XUklURV9UT0tFTmBcIlxuICAgICk7XG4gIH1cbiAgY29uc3QgcGF5bG9hZCA9IEJ1ZmZlci5mcm9tKFxuICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIC4uLmFyZ3NXaXRob3V0VG9rZW4sXG4gICAgICB2YWxpZFVudGlsOiAoX2EgPSBhcmdzV2l0aG91dFRva2VuLnZhbGlkVW50aWwpICE9IG51bGwgPyBfYSA6IHRpbWVzdGFtcC5nZXRUaW1lKClcbiAgICB9KVxuICApLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICBjb25zdCBzZWN1cmVkS2V5ID0gYXdhaXQgc2lnblBheWxvYWQocGF5bG9hZCwgcmVhZFdyaXRlVG9rZW4pO1xuICBpZiAoIXNlY3VyZWRLZXkpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiVW5hYmxlIHRvIHNpZ24gY2xpZW50IHRva2VuXCIpO1xuICB9XG4gIHJldHVybiBgdmVyY2VsX2Jsb2JfY2xpZW50XyR7c3RvcmVJZH1fJHtCdWZmZXIuZnJvbShcbiAgICBgJHtzZWN1cmVkS2V5fS4ke3BheWxvYWR9YFxuICApLnRvU3RyaW5nKFwiYmFzZTY0XCIpfWA7XG59XG5mdW5jdGlvbiBnZXRDYWxsYmFja1VybChyZXF1ZXN0KSB7XG4gIGNvbnN0IHJlcVBhdGggPSBnZXRQYXRoRnJvbVJlcXVlc3RVcmwocmVxdWVzdC51cmwpO1xuICBpZiAoIXJlcVBhdGgpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIm9uVXBsb2FkQ29tcGxldGVkIHByb3ZpZGVkIGJ1dCBubyBjYWxsYmFja1VybCBjb3VsZCBiZSBkZXRlcm1pbmVkLiBQbGVhc2UgcHJvdmlkZSBhIGNhbGxiYWNrVXJsIGluIG9uQmVmb3JlR2VuZXJhdGVUb2tlbiBvciBzZXQgdGhlIFZFUkNFTF9CTE9CX0NBTExCQUNLX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZS5cIlxuICAgICk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfQ0FMTEJBQ0tfVVJMKSB7XG4gICAgcmV0dXJuIGAke3Byb2Nlc3MuZW52LlZFUkNFTF9CTE9CX0NBTExCQUNLX1VSTH0ke3JlcVBhdGh9YDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuVkVSQ0VMICE9PSBcIjFcIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwib25VcGxvYWRDb21wbGV0ZWQgcHJvdmlkZWQgYnV0IG5vIGNhbGxiYWNrVXJsIGNvdWxkIGJlIGRldGVybWluZWQuIFBsZWFzZSBwcm92aWRlIGEgY2FsbGJhY2tVcmwgaW4gb25CZWZvcmVHZW5lcmF0ZVRva2VuIG9yIHNldCB0aGUgVkVSQ0VMX0JMT0JfQ0FMTEJBQ0tfVVJMIGVudmlyb25tZW50IHZhcmlhYmxlLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5WRVJDRUxfRU5WID09PSBcInByZXZpZXdcIikge1xuICAgIGlmIChwcm9jZXNzLmVudi5WRVJDRUxfQlJBTkNIX1VSTCkge1xuICAgICAgcmV0dXJuIGBodHRwczovLyR7cHJvY2Vzcy5lbnYuVkVSQ0VMX0JSQU5DSF9VUkx9JHtyZXFQYXRofWA7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5WRVJDRUxfVVJMKSB7XG4gICAgICByZXR1cm4gYGh0dHBzOi8vJHtwcm9jZXNzLmVudi5WRVJDRUxfVVJMfSR7cmVxUGF0aH1gO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuVkVSQ0VMX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgJiYgcHJvY2Vzcy5lbnYuVkVSQ0VMX1BST0pFQ1RfUFJPRFVDVElPTl9VUkwpIHtcbiAgICByZXR1cm4gYGh0dHBzOi8vJHtwcm9jZXNzLmVudi5WRVJDRUxfUFJPSkVDVF9QUk9EVUNUSU9OX1VSTH0ke3JlcVBhdGh9YDtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0UGF0aEZyb21SZXF1ZXN0VXJsKHVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsLCBcImh0dHBzOi8vZHVtbXkuY29tXCIpO1xuICAgIHJldHVybiBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZXhwb3J0IHtcbiAgY29tcGxldGVNdWx0aXBhcnRVcGxvYWQsXG4gIGNyZWF0ZUZvbGRlcixcbiAgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkLFxuICBjcmVhdGVNdWx0aXBhcnRVcGxvYWRlcixcbiAgZ2VuZXJhdGVDbGllbnRUb2tlbkZyb21SZWFkV3JpdGVUb2tlbixcbiAgZ2V0UGF5bG9hZEZyb21DbGllbnRUb2tlbixcbiAgaGFuZGxlVXBsb2FkLFxuICBwdXQsXG4gIHVwbG9hZCxcbiAgdXBsb2FkUGFydFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiQmxvYkVycm9yIiwiY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QiLCJjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2QiLCJjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCIsImNyZWF0ZUZvbGRlciIsImNyZWF0ZVB1dE1ldGhvZCIsImNyZWF0ZVVwbG9hZFBhcnRNZXRob2QiLCJnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYiLCJjcnlwdG8iLCJmZXRjaCIsImNyZWF0ZVB1dEV4dHJhQ2hlY2tzIiwibWV0aG9kTmFtZSIsImV4dHJhQ2hlY2tzIiwib3B0aW9ucyIsInRva2VuIiwic3RhcnRzV2l0aCIsImFkZFJhbmRvbVN1ZmZpeCIsImFsbG93T3ZlcndyaXRlIiwiY2FjaGVDb250cm9sTWF4QWdlIiwicHV0IiwiYWxsb3dlZE9wdGlvbnMiLCJjcmVhdGVNdWx0aXBhcnRVcGxvYWQiLCJjcmVhdGVNdWx0aXBhcnRVcGxvYWRlciIsInVwbG9hZFBhcnQiLCJjb21wbGV0ZU11bHRpcGFydFVwbG9hZCIsInVwbG9hZCIsImhhbmRsZVVwbG9hZFVybCIsImdldFRva2VuIiwicGF0aG5hbWUiLCJfYSIsIl9iIiwicmV0cmlldmVDbGllbnRUb2tlbiIsImNsaWVudFBheWxvYWQiLCJtdWx0aXBhcnQiLCJoZWFkZXJzIiwiaW1wb3J0S2V5IiwiZ2xvYmFsVGhpcyIsInN1YnRsZSIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwibmFtZSIsImhhc2giLCJzaWduUGF5bG9hZCIsInBheWxvYWQiLCJjcmVhdGVIbWFjIiwidXBkYXRlIiwiZGlnZXN0Iiwic2lnbmF0dXJlIiwic2lnbiIsIkJ1ZmZlciIsImZyb20iLCJVaW50OEFycmF5IiwidG9TdHJpbmciLCJ2ZXJpZnlDYWxsYmFja1NpZ25hdHVyZSIsImJvZHkiLCJzZWNyZXQiLCJkaWdlc3RCdWZmZXIiLCJzaWduYXR1cmVCdWZmZXIiLCJsZW5ndGgiLCJ0aW1pbmdTYWZlRXF1YWwiLCJ2ZXJpZmllZCIsInZlcmlmeSIsImhleFRvQXJyYXlCeXRlIiwiaW5wdXQiLCJSYW5nZUVycm9yIiwidmlldyIsImkiLCJOdW1iZXIiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImdldFBheWxvYWRGcm9tQ2xpZW50VG9rZW4iLCJjbGllbnRUb2tlbiIsImVuY29kZWRUb2tlbiIsInNwbGl0IiwiZW5jb2RlZFBheWxvYWQiLCJkZWNvZGVkUGF5bG9hZCIsIkpTT04iLCJwYXJzZSIsIkV2ZW50VHlwZXMiLCJnZW5lcmF0ZUNsaWVudFRva2VuIiwidXBsb2FkQ29tcGxldGVkIiwiaGFuZGxlVXBsb2FkIiwicmVxdWVzdCIsIm9uQmVmb3JlR2VuZXJhdGVUb2tlbiIsIm9uVXBsb2FkQ29tcGxldGVkIiwiX2MiLCJfZCIsInJlc29sdmVkVG9rZW4iLCJ0eXBlIiwidG9rZW5QYXlsb2FkIiwiY2FsbGJhY2tVcmwiLCJwcm92aWRlZENhbGxiYWNrVXJsIiwidG9rZW5PcHRpb25zIiwiZ2V0Q2FsbGJhY2tVcmwiLCJjb25zb2xlIiwid2FybiIsIm9uZUhvdXJJblNlY29uZHMiLCJub3ciLCJEYXRlIiwidmFsaWRVbnRpbCIsInNldFNlY29uZHMiLCJnZXRTZWNvbmRzIiwiZ2VuZXJhdGVDbGllbnRUb2tlbkZyb21SZWFkV3JpdGVUb2tlbiIsInNpZ25hdHVyZUhlYWRlciIsImdldCIsImlzVmVyaWZpZWQiLCJzdHJpbmdpZnkiLCJyZXNwb25zZSIsInVybCIsImlzQWJzb2x1dGVVcmwiLCJ0b0Fic29sdXRlVXJsIiwiZXZlbnQiLCJyZXMiLCJtZXRob2QiLCJzaWduYWwiLCJhYm9ydFNpZ25hbCIsIm9rIiwianNvbiIsIlVSTCIsImxvY2F0aW9uIiwiaHJlZiIsIkJvb2xlYW4iLCJhcmdzV2l0aG91dFRva2VuIiwidGltZXN0YW1wIiwicmVhZFdyaXRlVG9rZW4iLCJzdG9yZUlkIiwiZ2V0VGltZSIsInNlY3VyZWRLZXkiLCJyZXFQYXRoIiwiZ2V0UGF0aEZyb21SZXF1ZXN0VXJsIiwicHJvY2VzcyIsImVudiIsIlZFUkNFTF9CTE9CX0NBTExCQUNLX1VSTCIsIlZFUkNFTCIsIlZFUkNFTF9FTlYiLCJWRVJDRUxfQlJBTkNIX1VSTCIsIlZFUkNFTF9VUkwiLCJWRVJDRUxfUFJPSkVDVF9QUk9EVUNUSU9OX1VSTCIsInBhcnNlZFVybCIsInNlYXJjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vercel/blob/dist/client.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@vercel/blob/dist/crypto-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/crypto-browser.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHmac: function() { return /* binding */ createHmac; },\n/* harmony export */   timingSafeEqual: function() { return /* binding */ timingSafeEqual; }\n/* harmony export */ });\nfunction createHmac() {\n    throw new Error(\"Not implemented\");\n}\nfunction timingSafeEqual() {\n    throw new Error(\"Not implemented\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmVyY2VsL2Jsb2IvZGlzdC9jcnlwdG8tYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLFNBQVNBO0lBQ2QsTUFBTSxJQUFJQyxNQUFNO0FBQ2xCO0FBRU8sU0FBU0M7SUFDZCxNQUFNLElBQUlELE1BQU07QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvYmxvYi9kaXN0L2NyeXB0by1icm93c2VyLmpzPzNjMjAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWMoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1pbmdTYWZlRXF1YWwoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlSG1hYyIsIkVycm9yIiwidGltaW5nU2FmZUVxdWFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vercel/blob/dist/crypto-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@vercel/blob/dist/stream-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/stream-browser.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Readable: function() { return /* binding */ Readable; }\n/* harmony export */ });\n// This file is here because Edge Functions have no support for Node.js streams by default\n// It's unlikely someone would try to read/use a Node.js stream in an Edge function but we still put\n// a message in case this happens\nconst Readable = {\n    toWeb () {\n        throw new Error(\"Vercel Blob: Sorry, we cannot get a Readable stream in this environment. If you see this message please open an issue here: https://github.com/vercel/storage/ with details on your environment.\");\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmVyY2VsL2Jsb2IvZGlzdC9zdHJlYW0tYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsMEZBQTBGO0FBQzFGLG9HQUFvRztBQUNwRyxpQ0FBaUM7QUFFMUIsTUFBTUEsV0FBVztJQUN0QkM7UUFDRSxNQUFNLElBQUlDLE1BQ1I7SUFFSjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvYmxvYi9kaXN0L3N0cmVhbS1icm93c2VyLmpzP2I3M2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGlzIGhlcmUgYmVjYXVzZSBFZGdlIEZ1bmN0aW9ucyBoYXZlIG5vIHN1cHBvcnQgZm9yIE5vZGUuanMgc3RyZWFtcyBieSBkZWZhdWx0XG4vLyBJdCdzIHVubGlrZWx5IHNvbWVvbmUgd291bGQgdHJ5IHRvIHJlYWQvdXNlIGEgTm9kZS5qcyBzdHJlYW0gaW4gYW4gRWRnZSBmdW5jdGlvbiBidXQgd2Ugc3RpbGwgcHV0XG4vLyBhIG1lc3NhZ2UgaW4gY2FzZSB0aGlzIGhhcHBlbnNcblxuZXhwb3J0IGNvbnN0IFJlYWRhYmxlID0ge1xuICB0b1dlYigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnVmVyY2VsIEJsb2I6IFNvcnJ5LCB3ZSBjYW5ub3QgZ2V0IGEgUmVhZGFibGUgc3RyZWFtIGluIHRoaXMgZW52aXJvbm1lbnQuIElmIHlvdSBzZWUgdGhpcyBtZXNzYWdlIHBsZWFzZSBvcGVuIGFuIGlzc3VlIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvc3RvcmFnZS8gd2l0aCBkZXRhaWxzIG9uIHlvdXIgZW52aXJvbm1lbnQuJyxcbiAgICApO1xuICB9LFxufTtcbiJdLCJuYW1lcyI6WyJSZWFkYWJsZSIsInRvV2ViIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vercel/blob/dist/stream-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@vercel/blob/dist/undici-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/undici-browser.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetch: function() { return /* binding */ fetch; }\n/* harmony export */ });\n// this file gets copied to the dist folder\n// it makes undici work in the browser by reusing the global fetch\n// it's the simplest way I've found to make http requests work in Node.js, Serverles Functions, Edge Functions, and the browser\n// this should work as long as this module is used via Next.js/Webpack\n// moving forward we will have to solve this problem in a more robust way\n// reusing https://github.com/inrupt/universal-fetch\n// or seeing how/if cross-fetch solves https://github.com/lquixada/cross-fetch/issues/69\nconst fetch = globalThis.fetch.bind(globalThis);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmVyY2VsL2Jsb2IvZGlzdC91bmRpY2ktYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsMkNBQTJDO0FBQzNDLGtFQUFrRTtBQUNsRSwrSEFBK0g7QUFDL0gsc0VBQXNFO0FBQ3RFLHlFQUF5RTtBQUN6RSxvREFBb0Q7QUFDcEQsd0ZBQXdGO0FBQ2pGLE1BQU1BLFFBQVFDLFdBQVdELEtBQUssQ0FBQ0UsSUFBSSxDQUFDRCxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdmVyY2VsL2Jsb2IvZGlzdC91bmRpY2ktYnJvd3Nlci5qcz80YzY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoaXMgZmlsZSBnZXRzIGNvcGllZCB0byB0aGUgZGlzdCBmb2xkZXJcbi8vIGl0IG1ha2VzIHVuZGljaSB3b3JrIGluIHRoZSBicm93c2VyIGJ5IHJldXNpbmcgdGhlIGdsb2JhbCBmZXRjaFxuLy8gaXQncyB0aGUgc2ltcGxlc3Qgd2F5IEkndmUgZm91bmQgdG8gbWFrZSBodHRwIHJlcXVlc3RzIHdvcmsgaW4gTm9kZS5qcywgU2VydmVybGVzIEZ1bmN0aW9ucywgRWRnZSBGdW5jdGlvbnMsIGFuZCB0aGUgYnJvd3NlclxuLy8gdGhpcyBzaG91bGQgd29yayBhcyBsb25nIGFzIHRoaXMgbW9kdWxlIGlzIHVzZWQgdmlhIE5leHQuanMvV2VicGFja1xuLy8gbW92aW5nIGZvcndhcmQgd2Ugd2lsbCBoYXZlIHRvIHNvbHZlIHRoaXMgcHJvYmxlbSBpbiBhIG1vcmUgcm9idXN0IHdheVxuLy8gcmV1c2luZyBodHRwczovL2dpdGh1Yi5jb20vaW5ydXB0L3VuaXZlcnNhbC1mZXRjaFxuLy8gb3Igc2VlaW5nIGhvdy9pZiBjcm9zcy1mZXRjaCBzb2x2ZXMgaHR0cHM6Ly9naXRodWIuY29tL2xxdWl4YWRhL2Nyb3NzLWZldGNoL2lzc3Vlcy82OVxuZXhwb3J0IGNvbnN0IGZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaC5iaW5kKGdsb2JhbFRoaXMpO1xuIl0sIm5hbWVzIjpbImZldGNoIiwiZ2xvYmFsVGhpcyIsImJpbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vercel/blob/dist/undici-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/is-node-process/lib/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/is-node-process/lib/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isNodeProcess: function() { return /* binding */ isNodeProcess; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n// src/index.ts\nfunction isNodeProcess() {\n    if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n        return true;\n    }\n    if (typeof process !== \"undefined\") {\n        const type = process.type;\n        if (type === \"renderer\" || type === \"worker\") {\n            return false;\n        }\n        return !!(process.versions && process.versions.node);\n    }\n    return false;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pcy1ub2RlLXByb2Nlc3MvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGVBQWU7QUFDZixTQUFTQTtJQUNQLElBQUksT0FBT0MsY0FBYyxlQUFlQSxVQUFVQyxPQUFPLEtBQUssZUFBZTtRQUMzRSxPQUFPO0lBQ1Q7SUFDQSxJQUFJLE9BQU9DLE9BQU9BLEtBQUssYUFBYTtRQUNsQyxNQUFNQyxPQUFPRCxPQUFPQSxDQUFDQyxJQUFJO1FBQ3pCLElBQUlBLFNBQVMsY0FBY0EsU0FBUyxVQUFVO1lBQzVDLE9BQU87UUFDVDtRQUNBLE9BQU8sQ0FBQyxDQUFFRCxDQUFBQSxPQUFPQSxDQUFDRSxRQUFRLElBQUlGLE9BQU9BLENBQUNFLFFBQVEsQ0FBQ0MsSUFBSTtJQUNyRDtJQUNBLE9BQU87QUFDVDtBQUdFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pcy1ub2RlLXByb2Nlc3MvbGliL2luZGV4Lm1qcz9kZTAxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gaXNOb2RlUHJvY2VzcygpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IHR5cGUgPSBwcm9jZXNzLnR5cGU7XG4gICAgaWYgKHR5cGUgPT09IFwicmVuZGVyZXJcIiB8fCB0eXBlID09PSBcIndvcmtlclwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhIShwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IHtcbiAgaXNOb2RlUHJvY2Vzc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiaXNOb2RlUHJvY2VzcyIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJwcm9jZXNzIiwidHlwZSIsInZlcnNpb25zIiwibm9kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/is-node-process/lib/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=X%3A%5Cprojects%5CDropCode%5Ccomponents%5CMainApp.tsx&modules=X%3A%5Cprojects%5CDropCode%5Ccomponents%5Cproviders%5CAppProvider.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);